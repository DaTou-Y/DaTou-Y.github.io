<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> centos使用问题查询 · 随记</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="centos使用问题查询 - daTou"><meta name="keywords" content="datou，博客，java，随记，web"><meta name="author" content="daTou"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://datou-y.github.io/atom.xml" title="随记"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">centos使用问题查询</h1><div class="post-info">2019-06-29<p class="visit"><i data-identity="posts/3997c9eb.html/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><p><img src="https://ae01.alicdn.com/kf/HTB1LZv6bLBj_uVjSZFpq6A0SXXaM.jpg" alt></p>
<h2 id="centOs使用常用命令"><a href="#centOs使用常用命令" class="headerlink" title="centOs使用常用命令"></a>centOs使用常用命令</h2><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><ul>
<li>查看网卡名称<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="centos系统目录结构"><a href="#centos系统目录结构" class="headerlink" title="centos系统目录结构"></a>centos系统目录结构</h2><p><div class="tip"><br>CentOS的目录大体上可分为四类：管理类、用户类、应用程序类、信息类文件目录。<br></div><br><a id="more"></a></p>
<h3 id="管理类目录"><a href="#管理类目录" class="headerlink" title="管理类目录"></a>管理类目录</h3><ul>
<li><code>/boot</code><br>　　linux的内核及引导系统程序所需要的文件目录</li>
<li><code>/bin</code><br>　　存放标准 linux 的工具，在终端里输入ls，系统就系统将会到该目录查看是否存在该命令程序。</li>
<li><code>/sbin</code><br>　　大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令</li>
<li><code>/var</code><br>　　这个目录的内容是经常变动的，用来存储经常被修改的文件，如日志、数据文件、邮箱等</li>
<li><code>/etc</code><br>　　主要存放系统配置方面的文件</li>
<li><code>/dev</code><br>　　主要存放与设备有关的文件<br><code>/mnt</code><br>　　这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义</li>
</ul>
<h3 id="用户类目录"><a href="#用户类目录" class="headerlink" title="用户类目录"></a>用户类目录</h3><ul>
<li><code>/root</code><br>　　系统管理员目录</li>
<li><code>/home</code><br>　　主要存放个人数据</li>
</ul>
<h3 id="应用程序类目录："><a href="#应用程序类目录：" class="headerlink" title="应用程序类目录："></a>应用程序类目录：</h3><ul>
<li><code>/lib</code><br>　　该目录用来存放系统动态链接共享库，几乎所有的应用程序都会用到该目录下的共享库</li>
<li><code>/tmp</code><br>　　临时目录，有些linux会定期清理</li>
<li><code>/usr</code><br>　　存放一些不适合放在/bin 或 /etc 目录下的额外工具，如个人安装的程序或工具</li>
<li><code>/usr/local</code><br>　　主要存放那些手动安装的软件，</li>
<li><code>/usr/bin</code><br>　　用于存放程序</li>
<li><code>/usr/share</code><br>　　用于存放一些共享数据</li>
<li><code>/usr/lib</code><br>　　存放一些不能不能直接运行，但却是许多程序运行所必需的一些函数库文件</li>
<li><code>/opt</code><br>　　主要存放可选程序，直接删除程序不影响系统其设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面</li>
</ul>
<h3 id="信息类目录："><a href="#信息类目录：" class="headerlink" title="信息类目录："></a>信息类目录：</h3><ul>
<li><code>/lost+found</code><br>　　在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。但当突然停电、或者非正常关机后，有些文件就临时存放在这里。</li>
<li><code>/proc</code><br>　　操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里</li>
</ul>
<h3 id="其他重要目录："><a href="#其他重要目录：" class="headerlink" title="其他重要目录："></a>其他重要目录：</h3><ul>
<li><code>/etc/rc.d</code><br>　　放置开机和关机的脚本。</li>
<li><code>/etc/rc.d/init.d</code><br>　　放置启动脚本</li>
<li><code>/etc/xinetd.d</code><br>　　配置<code>xinetd.conf</code>可以配置启动其他额外服务。</li>
<li><code>/usr/include</code><br>　　一些<code>distribution</code>套件的头文件放置目录，安装程序时可能会用到。</li>
<li><code>/usr/lib*</code><br>　　套件的程序库</li>
<li><code>/usr/local</code><br>　　默认的软件安装目录。</li>
<li><code>/usr/share/doc</code><br>　　系统说明文件的放置目录</li>
<li><code>/usr/share/man</code><br>　　程序说明文件放置目录</li>
<li><code>/usr/src</code><br>　　内核源代码目录</li>
<li><p><code>/usr/X11R6</code><br>　　X的存放目录</p>
</li>
<li><p><code>/：</code><br>　　根目录，一般根目录下只存放目录，不要存放文件，<code>/etc、/bin、/dev、/lib、/sbin</code>应该和根目录放置在一个分区中</p>
</li>
<li><code>/bin:/usr/bin:</code><br>　　可执行二进制文件的目录，如常用的命令<code>ls、tar、mv、cat</code>等。</li>
<li><code>/boot：</code><br>　　放置linux系统启动时用到的一些文件。<code>/boot/vmlinuz</code>为<code>linux</code>的内核文件，以及<code>/boot/gurb。</code>建议单独分区，分区大小100M即可</li>
<li><code>/dev：</code><br>　　存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt。</code></li>
<li><code>/etc：</code><br>　　系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有<code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d</code>修改配置文件之前记得备份。注：<code>/etc/X11</code>存放与<code>x windows</code>有关的设置。</li>
<li><code>/home：</code><br>　　系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户<code>test</code>的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</li>
<li><code>/lib:/usr/lib:/usr/local/lib：</code><br>　　系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为<code>/lib/modules。</code></li>
<li><code>/lost+fount：</code><br>　　系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于<code>/disk</code> 中，此目录下就会自动产生目录<code>/disk/lost+found</code></li>
<li><code>/mnt:/media：</code><br>　　光盘默认挂载点，通常光盘挂载于<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li>
<li><code>/opt：</code><br>　　给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 <code>Linux</code>系统中，习惯放置在 <code>/usr/local</code> 目录下</li>
<li><code>/proc：</code><br>　　此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有<code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code>等</li>
<li><code>/root：</code><br>　　系统管理员<code>root</code>的家目录，系统第一个启动的分区为/，所以最好将<code>/root</code>和/放置在一个分区下。<br><code>/sbin:/usr/sbin:/usr/local/sbin：</code><br>　　放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。</li>
<li><code>/tmp：</code><br>　　一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</li>
<li><code>/srv：</code><br>　　服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内</li>
<li><code>/usr：</code><br>　　应用程序存放目录， <code>/usr/bin</code> 存放应用程序， <code>/usr/share</code>存放共享数据， <code>/usr/lib</code> 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。 <code>/usr/local:</code>存放软件升级包。 <code>/usr/share/doc:</code> 系统说明文件存放目录。 <code>/usr/share/man:</code>程序说明文件存放目录，使用 man ls时会查询<code>/usr/share/man/man1/ls.1.gz</code>的内容建议单独分区，设置较大的磁盘空间</li>
<li><code>/var：</code><br>　　放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message：</code> 所有的登录文件存放目录， <code>/var/spool/mail：</code> 邮件存放的目录， <code>/var/run:</code> 程序或服务启动后，其<code>PID</code>存放在该目录下。建议单独分区，设置较大的磁盘空间</li>
</ul>
<h3 id="etc：-目录"><a href="#etc：-目录" class="headerlink" title="/etc： 目录"></a>/etc： 目录</h3><p>包含很多文件.许多网络配置文件也在/etc 中.</p>
<ul>
<li><code>/etc/rc or /etc/rc.d or /etc/rc*.d</code><br>　　启动、或改变运行级时运行的scripts或scripts的目录.</li>
<li><code>/etc/passwd</code><br>　　用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息.</li>
<li><code>/etc/fstab</code><br>　　启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表. Linux下，也包括用swapon -a启用的swap区的信息.</li>
<li><code>/etc/group</code><br>　　类似/etc/passwd ，但说明的不是用户而是组.</li>
<li><code>/etc/inittab</code><br>　　init 的配置文件.</li>
<li><code>/etc/issue</code><br>　　getty 在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息.内容由系统管理员确定.</li>
<li><code>/etc/motd</code><br>　　Message Of The Day，成功登录后自动输出.内容由系统管理员确定.经常用于通告信息，如计划关机时间的警告.</li>
<li><code>/etc/mtab</code><br>　　当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df 命令.</li>
<li><code>/etc/shadow</code><br>　　在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读.这使破译口令更困难.</li>
<li><code>/etc/login.defs</code><br>　　login 命令的配置文件.</li>
<li><code>/etc/printcap</code><br>　　类似/etc/termcap ，但针对打印机.语法不同.<br>/etc/profile , /etc/csh.login , /etc/csh.cshrc<br>　　登录或启动时Bourne或C shells执行的文件.这允许系统管理员为所有用户建立全局缺省环境.</li>
<li><code>/etc/securetty</code><br>　　确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权.</li>
<li><code>/etc/shells</code><br>　　列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录.</li>
<li><code>/etc/sysconfig</code><br>　　网络配置相关目录</li>
</ul>
<h3 id="usr：目录"><a href="#usr：目录" class="headerlink" title="/usr：目录"></a>/usr：目录</h3><p>/usr 文件系统经常很大，因为所有程序安装在这里. /usr 里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在/usr/local下.这样可能在升级新版系统或新distribution时无须重新安装全部程序.</p>
<ul>
<li><code>/usr/etc</code><br>　　  存放设置文件</li>
<li><code>/usr/games</code><br>　　  存放游戏和教学文件</li>
<li><code>/usr/include</code><br>　　存放C开发工具的头文件</li>
<li><code>/usr/share</code><br>　　存放结构独立的数据</li>
<li><code>/usr/bin</code><br>　　几乎所有用户命令.有些命令在/bin 或/usr/local/bin 中.</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://blog.csdn.net/qq_33858250/article/details/81839619" target="_blank" rel="noopener">CentOS7目录结构详细版</a></li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/posts/a8e83838.html/" title="http 请求对应的状态码" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "zAMiuBUEFGvAqQNumOfiIqc9-gzGzoHsz",
    appKey: "3KpMWljrncl7SfARIGQwPNxh",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2018 - 2019 <a target="_blank">daTou</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("zAMiuBUEFGvAqQNumOfiIqc9-gzGzoHsz", "3KpMWljrncl7SfARIGQwPNxh");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>