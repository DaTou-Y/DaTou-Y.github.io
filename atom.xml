<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://datou-y.github.io/"/>
  <updated>2019-06-30T01:23:10.927Z</updated>
  <id>https://datou-y.github.io/</id>
  
  <author>
    <name>daTou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux 常用命令的使用</title>
    <link href="https://datou-y.github.io/posts/6627048.html/"/>
    <id>https://datou-y.github.io/posts/6627048.html/</id>
    <published>2019-06-29T14:06:39.856Z</published>
    <updated>2019-06-30T01:23:10.927Z</updated>
    
    <content type="html"><![CDATA[<p>linux的发行的版本很多但是，命令行工具都是标准的<br><a id="more"></a></p><ul><li>mv<br>移动档案与目录，或更名</li><li>rm<br>移除档案或目录</li><li>cat<br>由第一行开始显示档案内容</li><li>tac<br>从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）</li><li>nl<br>显示的时候，顺道输出行号</li><li><p>more<br>一页一页的显示档案内容</p></li><li><p>shutdown -r now<br>重启</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/crazylqy/p/5818745.html" target="_blank" rel="noopener">linux常用基本命令</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux的发行的版本很多但是，命令行工具都是标准的&lt;br&gt;
    
    </summary>
    
      <category term="system" scheme="https://datou-y.github.io/categories/system/"/>
    
    
      <category term="linux" scheme="https://datou-y.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>centos 上安装docker</title>
    <link href="https://datou-y.github.io/posts/f9c16e64.html/"/>
    <id>https://datou-y.github.io/posts/f9c16e64.html/</id>
    <published>2019-06-29T13:46:53.069Z</published>
    <updated>2019-06-29T13:53:51.789Z</updated>
    
    <content type="html"><![CDATA[<p>Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。</p><p>社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。</p><p>社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。<br><a id="more"></a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">Centos7上安装docker</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker从1.13版本之后采用时间线的方式作为版本号，分为社区版CE和企业版EE。&lt;/p&gt;
&lt;p&gt;社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。&lt;/p&gt;
&lt;p&gt;社区版按照stable和edge两种方式发布，每个季度更新stable版本，如17.06，17.09；每个月份更新edge版本，如17.09，17.10。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://datou-y.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://datou-y.github.io/tags/docker/"/>
    
      <category term="centos" scheme="https://datou-y.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos系统yum的使用</title>
    <link href="https://datou-y.github.io/posts/732e476.html/"/>
    <id>https://datou-y.github.io/posts/732e476.html/</id>
    <published>2019-06-29T13:39:48.542Z</published>
    <updated>2019-06-29T13:43:54.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="yum是什么"><a href="#yum是什么" class="headerlink" title="yum是什么"></a>yum是什么</h2><p>yum = Yellow dog Updater, Modified<br>主要功能是更方便的添加/删除/更新RPM包.<br>它能自动解决包的倚赖性问题.<br>它能便于管理大量系统的更新问题</p><h2 id="yum特点"><a href="#yum特点" class="headerlink" title="yum特点"></a>yum特点</h2><p>可以同时配置多个资源库(Repository)<br>简洁的配置文件(/etc/yum.conf<br>自动解决增加或删除rpm包时遇到的倚赖性问题<br>使用方便<br>保持与RPM数据库的一致性<br><a id="more"></a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/yqj234/article/details/82990271" target="_blank" rel="noopener">CentOS yum的详细使用方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;yum是什么&quot;&gt;&lt;a href=&quot;#yum是什么&quot; class=&quot;headerlink&quot; title=&quot;yum是什么&quot;&gt;&lt;/a&gt;yum是什么&lt;/h2&gt;&lt;p&gt;yum = Yellow dog Updater, Modified&lt;br&gt;主要功能是更方便的添加/删除/更新RPM包.&lt;br&gt;它能自动解决包的倚赖性问题.&lt;br&gt;它能便于管理大量系统的更新问题&lt;/p&gt;
&lt;h2 id=&quot;yum特点&quot;&gt;&lt;a href=&quot;#yum特点&quot; class=&quot;headerlink&quot; title=&quot;yum特点&quot;&gt;&lt;/a&gt;yum特点&lt;/h2&gt;&lt;p&gt;可以同时配置多个资源库(Repository)&lt;br&gt;简洁的配置文件(/etc/yum.conf&lt;br&gt;自动解决增加或删除rpm包时遇到的倚赖性问题&lt;br&gt;使用方便&lt;br&gt;保持与RPM数据库的一致性&lt;br&gt;
    
    </summary>
    
      <category term="system" scheme="https://datou-y.github.io/categories/system/"/>
    
    
      <category term="centos" scheme="https://datou-y.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>mac Pro 虚拟机VMware Fusion安装centos7.6无法连接网络</title>
    <link href="https://datou-y.github.io/posts/ccff5e6d.html/"/>
    <id>https://datou-y.github.io/posts/ccff5e6d.html/</id>
    <published>2019-06-29T13:25:03.599Z</published>
    <updated>2019-06-29T13:36:48.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>超级用户进入<code>/etc/sysconfig/network-scripts</code>目录</li><li>修改 vi ifcfg-ens33文件<br><img src="https://ae01.alicdn.com/kf/HTB15y6udkxz61VjSZFr760eLFXa5.png" alt></li><li>重启虚拟机centos系统<a id="more"></a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.yihaomen.com/article/Architect/701.htm" target="_blank" rel="noopener">VMWare中安装Centos7, 并配置网络</a></li><li><a href="https://blog.csdn.net/cyl101816/article/details/82026678" target="_blank" rel="noopener">Linux——vi命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;超级用户进入&lt;code&gt;/etc/sysconfig/network-scripts&lt;/code&gt;目录&lt;/li&gt;
&lt;li&gt;修改 vi ifcfg-ens33文件&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB15y6udkxz61VjSZFr760eLFXa5.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;重启虚拟机centos系统
    
    </summary>
    
      <category term="问题" scheme="https://datou-y.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="centos" scheme="https://datou-y.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos目录结构</title>
    <link href="https://datou-y.github.io/posts/3997c9eb.html/"/>
    <id>https://datou-y.github.io/posts/3997c9eb.html/</id>
    <published>2019-06-29T03:45:45.204Z</published>
    <updated>2019-06-29T13:37:17.347Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1LZv6bLBj_uVjSZFpq6A0SXXaM.jpg" alt></p><h2 id="centos系统目录结构"><a href="#centos系统目录结构" class="headerlink" title="centos系统目录结构"></a>centos系统目录结构</h2><p><div class="tip"><br>CentOS的目录大体上可分为四类：管理类、用户类、应用程序类、信息类文件目录。<br></div><br><a id="more"></a></p><h3 id="管理类目录"><a href="#管理类目录" class="headerlink" title="管理类目录"></a>管理类目录</h3><ul><li><code>/boot</code><br>　　linux的内核及引导系统程序所需要的文件目录</li><li><code>/bin</code><br>　　存放标准 linux 的工具，在终端里输入ls，系统就系统将会到该目录查看是否存在该命令程序。</li><li><code>/sbin</code><br>　　大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令</li><li><code>/var</code><br>　　这个目录的内容是经常变动的，用来存储经常被修改的文件，如日志、数据文件、邮箱等</li><li><code>/etc</code><br>　　主要存放系统配置方面的文件</li><li><code>/dev</code><br>　　主要存放与设备有关的文件<br><code>/mnt</code><br>　　这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义</li></ul><h3 id="用户类目录"><a href="#用户类目录" class="headerlink" title="用户类目录"></a>用户类目录</h3><ul><li><code>/root</code><br>　　系统管理员目录</li><li><code>/home</code><br>　　主要存放个人数据</li></ul><h3 id="应用程序类目录："><a href="#应用程序类目录：" class="headerlink" title="应用程序类目录："></a>应用程序类目录：</h3><ul><li><code>/lib</code><br>　　该目录用来存放系统动态链接共享库，几乎所有的应用程序都会用到该目录下的共享库</li><li><code>/tmp</code><br>　　临时目录，有些linux会定期清理</li><li><code>/usr</code><br>　　存放一些不适合放在/bin 或 /etc 目录下的额外工具，如个人安装的程序或工具</li><li><code>/usr/local</code><br>　　主要存放那些手动安装的软件，</li><li><code>/usr/bin</code><br>　　用于存放程序</li><li><code>/usr/share</code><br>　　用于存放一些共享数据</li><li><code>/usr/lib</code><br>　　存放一些不能不能直接运行，但却是许多程序运行所必需的一些函数库文件</li><li><code>/opt</code><br>　　主要存放可选程序，直接删除程序不影响系统其设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面</li></ul><h3 id="信息类目录："><a href="#信息类目录：" class="headerlink" title="信息类目录："></a>信息类目录：</h3><ul><li><code>/lost+found</code><br>　　在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。但当突然停电、或者非正常关机后，有些文件就临时存放在这里。</li><li><code>/proc</code><br>　　操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里</li></ul><h3 id="其他重要目录："><a href="#其他重要目录：" class="headerlink" title="其他重要目录："></a>其他重要目录：</h3><ul><li><code>/etc/rc.d</code><br>　　放置开机和关机的脚本。</li><li><code>/etc/rc.d/init.d</code><br>　　放置启动脚本</li><li><code>/etc/xinetd.d</code><br>　　配置<code>xinetd.conf</code>可以配置启动其他额外服务。</li><li><code>/usr/include</code><br>　　一些<code>distribution</code>套件的头文件放置目录，安装程序时可能会用到。</li><li><code>/usr/lib*</code><br>　　套件的程序库</li><li><code>/usr/local</code><br>　　默认的软件安装目录。</li><li><code>/usr/share/doc</code><br>　　系统说明文件的放置目录</li><li><code>/usr/share/man</code><br>　　程序说明文件放置目录</li><li><code>/usr/src</code><br>　　内核源代码目录</li><li><p><code>/usr/X11R6</code><br>　　X的存放目录</p></li><li><p><code>/：</code><br>　　根目录，一般根目录下只存放目录，不要存放文件，<code>/etc、/bin、/dev、/lib、/sbin</code>应该和根目录放置在一个分区中</p></li><li><code>/bin:/usr/bin:</code><br>　　可执行二进制文件的目录，如常用的命令<code>ls、tar、mv、cat</code>等。</li><li><code>/boot：</code><br>　　放置linux系统启动时用到的一些文件。<code>/boot/vmlinuz</code>为<code>linux</code>的内核文件，以及<code>/boot/gurb。</code>建议单独分区，分区大小100M即可</li><li><code>/dev：</code><br>　　存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom /mnt。</code></li><li><code>/etc：</code><br>　　系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有<code>/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d</code>修改配置文件之前记得备份。注：<code>/etc/X11</code>存放与<code>x windows</code>有关的设置。</li><li><code>/home：</code><br>　　系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户<code>test</code>的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</li><li><code>/lib:/usr/lib:/usr/local/lib：</code><br>　　系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为<code>/lib/modules。</code></li><li><code>/lost+fount：</code><br>　　系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于<code>/disk</code> 中，此目录下就会自动产生目录<code>/disk/lost+found</code></li><li><code>/mnt:/media：</code><br>　　光盘默认挂载点，通常光盘挂载于<code>/mnt/cdrom</code>下，也不一定，可以选择任意位置进行挂载。</li><li><code>/opt：</code><br>　　给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 <code>Linux</code>系统中，习惯放置在 <code>/usr/local</code> 目录下</li><li><code>/proc：</code><br>　　此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有<code>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*</code>等</li><li><code>/root：</code><br>　　系统管理员<code>root</code>的家目录，系统第一个启动的分区为/，所以最好将<code>/root</code>和/放置在一个分区下。<br><code>/sbin:/usr/sbin:/usr/local/sbin：</code><br>　　放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。</li><li><code>/tmp：</code><br>　　一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</li><li><code>/srv：</code><br>　　服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内</li><li><code>/usr：</code><br>　　应用程序存放目录， <code>/usr/bin</code> 存放应用程序， <code>/usr/share</code>存放共享数据， <code>/usr/lib</code> 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。 <code>/usr/local:</code>存放软件升级包。 <code>/usr/share/doc:</code> 系统说明文件存放目录。 <code>/usr/share/man:</code>程序说明文件存放目录，使用 man ls时会查询<code>/usr/share/man/man1/ls.1.gz</code>的内容建议单独分区，设置较大的磁盘空间</li><li><code>/var：</code><br>　　放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log，/var/log/message：</code> 所有的登录文件存放目录， <code>/var/spool/mail：</code> 邮件存放的目录， <code>/var/run:</code> 程序或服务启动后，其<code>PID</code>存放在该目录下。建议单独分区，设置较大的磁盘空间</li></ul><h3 id="etc：-目录"><a href="#etc：-目录" class="headerlink" title="/etc： 目录"></a>/etc： 目录</h3><p>包含很多文件.许多网络配置文件也在/etc 中.</p><ul><li><code>/etc/rc or /etc/rc.d or /etc/rc*.d</code><br>　　启动、或改变运行级时运行的scripts或scripts的目录.</li><li><code>/etc/passwd</code><br>　　用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息.</li><li><code>/etc/fstab</code><br>　　启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表. Linux下，也包括用swapon -a启用的swap区的信息.</li><li><code>/etc/group</code><br>　　类似/etc/passwd ，但说明的不是用户而是组.</li><li><code>/etc/inittab</code><br>　　init 的配置文件.</li><li><code>/etc/issue</code><br>　　getty 在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息.内容由系统管理员确定.</li><li><code>/etc/motd</code><br>　　Message Of The Day，成功登录后自动输出.内容由系统管理员确定.经常用于通告信息，如计划关机时间的警告.</li><li><code>/etc/mtab</code><br>　　当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df 命令.</li><li><code>/etc/shadow</code><br>　　在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读.这使破译口令更困难.</li><li><code>/etc/login.defs</code><br>　　login 命令的配置文件.</li><li><code>/etc/printcap</code><br>　　类似/etc/termcap ，但针对打印机.语法不同.<br>/etc/profile , /etc/csh.login , /etc/csh.cshrc<br>　　登录或启动时Bourne或C shells执行的文件.这允许系统管理员为所有用户建立全局缺省环境.</li><li><code>/etc/securetty</code><br>　　确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权.</li><li><code>/etc/shells</code><br>　　列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录.</li><li><code>/etc/sysconfig</code><br>　　网络配置相关目录</li></ul><h3 id="usr：目录"><a href="#usr：目录" class="headerlink" title="/usr：目录"></a>/usr：目录</h3><p>/usr 文件系统经常很大，因为所有程序安装在这里. /usr 里的所有文件一般来自Linux distribution；本地安装的程序和其他东西在/usr/local下.这样可能在升级新版系统或新distribution时无须重新安装全部程序.</p><ul><li><code>/usr/etc</code><br>　　  存放设置文件</li><li><code>/usr/games</code><br>　　  存放游戏和教学文件</li><li><code>/usr/include</code><br>　　存放C开发工具的头文件</li><li><code>/usr/share</code><br>　　存放结构独立的数据</li><li><code>/usr/bin</code><br>　　几乎所有用户命令.有些命令在/bin 或/usr/local/bin 中.</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_33858250/article/details/81839619" target="_blank" rel="noopener">CentOS7目录结构详细版</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1LZv6bLBj_uVjSZFpq6A0SXXaM.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;centos系统目录结构&quot;&gt;&lt;a href=&quot;#centos系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;centos系统目录结构&quot;&gt;&lt;/a&gt;centos系统目录结构&lt;/h2&gt;&lt;p&gt;&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;CentOS的目录大体上可分为四类：管理类、用户类、应用程序类、信息类文件目录。&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
      <category term="system" scheme="https://datou-y.github.io/categories/system/"/>
    
    
      <category term="centos" scheme="https://datou-y.github.io/tags/centos/"/>
    
      <category term="system" scheme="https://datou-y.github.io/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>http 请求对应的状态码</title>
    <link href="https://datou-y.github.io/posts/a8e83838.html/"/>
    <id>https://datou-y.github.io/posts/a8e83838.html/</id>
    <published>2019-06-28T03:19:02.945Z</published>
    <updated>2019-06-28T03:30:49.949Z</updated>
    
    <content type="html"><![CDATA[<p>开发中良好的调试可以让你飞一般的写程序</p><h2 id="2-开头-（请求成功）表示成功处理了请求的状态代码。"><a href="#2-开头-（请求成功）表示成功处理了请求的状态代码。" class="headerlink" title="2**开头 （请求成功）表示成功处理了请求的状态代码。"></a>2**开头 （请求成功）表示成功处理了请求的状态代码。</h2><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。<a id="more"></a></li></ul><h2 id="3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a href="#3-开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。" class="headerlink" title="3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。"></a>3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h2><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul><h2 id="4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4-开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</h2><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li></ul><h2 id="5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5-开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h2><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/gitnull/p/9532129.html" target="_blank" rel="noopener">常见的HTTP状态码(HTTP Status Code)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中良好的调试可以让你飞一般的写程序&lt;/p&gt;
&lt;h2 id=&quot;2-开头-（请求成功）表示成功处理了请求的状态代码。&quot;&gt;&lt;a href=&quot;#2-开头-（请求成功）表示成功处理了请求的状态代码。&quot; class=&quot;headerlink&quot; title=&quot;2**开头 （请求成功）表示成功处理了请求的状态代码。&quot;&gt;&lt;/a&gt;2**开头 （请求成功）表示成功处理了请求的状态代码。&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。&lt;/li&gt;
&lt;li&gt;201 （已创建） 请求成功并且服务器创建了新的资源。&lt;/li&gt;
&lt;li&gt;202 （已接受） 服务器已接受请求，但尚未处理。&lt;/li&gt;
&lt;li&gt;203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。&lt;/li&gt;
&lt;li&gt;204 （无内容） 服务器成功处理了请求，但没有返回任何内容。&lt;/li&gt;
&lt;li&gt;205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。&lt;/li&gt;
&lt;li&gt;206 （部分内容） 服务器成功处理了部分 GET 请求。
    
    </summary>
    
      <category term="web综合" scheme="https://datou-y.github.io/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="http" scheme="https://datou-y.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>java读取配置文件信息</title>
    <link href="https://datou-y.github.io/posts/8988b28b.html/"/>
    <id>https://datou-y.github.io/posts/8988b28b.html/</id>
    <published>2019-06-26T02:51:23.083Z</published>
    <updated>2019-06-26T03:12:29.807Z</updated>
    
    <content type="html"><![CDATA[<p>java读取配置文件信息</p><ol><li>ClassName.class.getClassLoader().getResourceAsStream(““)读取<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = DbUtil.class.getClassLoader().getResourceAsStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">driverClass = properties.getProperty(<span class="string">"ojdbc.driver"</span>);</span><br></pre></td></tr></table></figure></li></ol><ul><li>表示读取类路径<code>classpath</code>下的<code>jdbc.properties</code>文件一般对应srcmu’l<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java读取配置文件信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ClassName.class.getClassLoader().getResourceAsStream(““)读取&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;InputStream in = DbUtil.class.getClassLoader().getResourceAsStream(&lt;span class=&quot;string&quot;&gt;&quot;jdbc.properties&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Properties properties = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;driverClass = properties.getProperty(&lt;span class=&quot;string&quot;&gt;&quot;ojdbc.driver&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;表示读取类路径&lt;code&gt;classpath&lt;/code&gt;下的&lt;code&gt;jdbc.properties&lt;/code&gt;文件一般对应srcmu’l
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="properties" scheme="https://datou-y.github.io/tags/properties/"/>
    
  </entry>
  
  <entry>
    <title>docker入门使用</title>
    <link href="https://datou-y.github.io/posts/860b62bb.html/"/>
    <id>https://datou-y.github.io/posts/860b62bb.html/</id>
    <published>2019-06-24T01:21:22.745Z</published>
    <updated>2019-06-26T02:50:08.609Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了</p><h2 id="docker-常用命名"><a href="#docker-常用命名" class="headerlink" title="docker 常用命名"></a>docker 常用命名</h2><h3 id="安装镜像软件"><a href="#安装镜像软件" class="headerlink" title="安装镜像软件"></a>安装镜像软件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure><h3 id="查看本地所有的镜像软件"><a href="#查看本地所有的镜像软件" class="headerlink" title="查看本地所有的镜像软件"></a>查看本地所有的镜像软件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY]</span><br><span class="line">-a，–all=<span class="keyword">false</span>，显示所有镜像</span><br><span class="line">-f，–filter=[]，显示时过滤条件</span><br><span class="line">–no-trunc=<span class="keyword">false</span>，指定不使用截断的形式显示数据</span><br><span class="line">-q，–quiet=<span class="keyword">false</span>，只显示镜像的唯一id</span><br></pre></td></tr></table></figure><h3 id="启动新容器"><a href="#启动新容器" class="headerlink" title="启动新容器"></a>启动新容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt;</span><br><span class="line"></span><br><span class="line"> -i：表示以“交互模式”运行容器</span><br><span class="line"> -t：表示容器启动后会进入其命令行</span><br><span class="line"> -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;</span><br><span class="line"> --hostname ：指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定gitlab.xxx.com</span><br><span class="line"> --publish：端口映射；容器内的<span class="number">443</span>,<span class="number">80</span>,<span class="number">22</span>端口分别映射到宿主机的<span class="number">444</span>,<span class="number">81</span>,<span class="number">23</span>端口</span><br><span class="line"> --volume ：挂载数据卷，映射到容器中去的容器外部存储空间</span><br><span class="line"></span><br><span class="line"> 启动交互式容器：docker run -t -i –name=自定义名称 IMAGE_NAME /bin/bash</span><br><span class="line"> -i –interactive=<span class="keyword">true</span> | <span class="keyword">false</span>，默认是<span class="keyword">false</span></span><br><span class="line"> -t –tty=<span class="keyword">true</span> | <span class="keyword">false</span>，默认是<span class="keyword">false</span></span><br><span class="line"> –name 给启动的容器自定义名称，方便后续的容器选择操作</span><br><span class="line"> -d (Detached)：表示容器将以后台模式运行，所有I/O数据只能通过网络资源或者共享卷组来进行交互。</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span>：-e 表示设置环境变量，此处设置了 mysql root 用户的初始密码为 <span class="number">123456</span>。</span><br><span class="line"></span><br><span class="line"> 例子</span><br><span class="line"> docker run -ti --name mycentos centos /bin/bash 表示以“交互模式”</span><br><span class="line"> 运行容器容器启动后会进入其命令行</span><br><span class="line"> docker exec -ti mycentos /bin/bash 在mycentos中打开/bin/bash命令行界面</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="重新启动停止的容器"><a href="#重新启动停止的容器" class="headerlink" title="重新启动停止的容器"></a>重新启动停止的容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际使用时，没必要每次都重新启动一个新的容器，我们可以重新启动之前创建的容器，现实情况也需要我们这样使用。</span><br><span class="line">docker start -i haha</span><br></pre></td></tr></table></figure><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps [-a] [-l]</span><br><span class="line">docker ps 列出正在运行的容器</span><br><span class="line">-a all 列出所有容器</span><br><span class="line">-l latest 列出最近的容器</span><br></pre></td></tr></table></figure><h3 id="查看指定容器"><a href="#查看指定容器" class="headerlink" title="查看指定容器"></a>查看指定容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect name | id</span><br><span class="line">name指代具体的容器名称，id则是容器的唯一id标识。inspect命令可以详细的展示出容器的具体信息</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在启动界面 按 exit,或者docker stop 对应容器 CONTAINER ID</span><br></pre></td></tr></table></figure><h3 id="删除停止的容器"><a href="#删除停止的容器" class="headerlink" title="删除停止的容器"></a>删除停止的容器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm name | id</span><br><span class="line">docker rm thirsty_kepler</span><br><span class="line">docker rm upbeat_albattani</span><br></pre></td></tr></table></figure><h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><p>交互式容器在运行完命令退出后即停止，而实际中我们常常需要能够长时间运行，即使退出也能后台运行的容器，而守护式容器具备这一功能。守护式容器具有：</p><ol><li>能够长期运行；</li><li>没有交互式会话；</li><li>适合于运行应用程序和服务。</li></ol><p>以守护形式运行容器<br>我们执行完需要的操作退出容器时，不要使用exit退出，可以利用Ctrl+P Ctrl+Q代替，以守护式形式推出容器。</p><p>附加到运行中的容器<br>退出正在运行的容器，想要再次进入，需要使用<code>attach命令：docker attach name | id</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach haha</span><br></pre></td></tr></table></figure></p><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>当守护式容器在后台运行时，我们可以利用docker的日志命令查看其输出：<code>docker logs [-f] [-t] [–tail] IMAGE_NAME</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f –follows=<span class="keyword">true</span> | <span class="keyword">false</span>，默认是<span class="keyword">false</span>，显示更新</span><br><span class="line">-t –timestamps=<span class="keyword">true</span> | <span class="keyword">false</span>，默认是<span class="keyword">false</span>，显示时间戳</span><br><span class="line">–tail=“all” | 行数，显示最新行数的日志</span><br></pre></td></tr></table></figure></p><h3 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h3><p>对运行的容器查看其进程：<code>docker top IMAGE_NAME</code></p><h3 id="强制停止"><a href="#强制停止" class="headerlink" title="强制停止"></a>强制停止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器名</span><br></pre></td></tr></table></figure><h3 id="容器的端口映射"><a href="#容器的端口映射" class="headerlink" title="容器的端口映射"></a>容器的端口映射</h3><p>命令：<code>run [-P] [-p]</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-P，–publish-all=<span class="keyword">true</span> | <span class="keyword">false</span>，大写的P表示为容器暴露的所有端口进行映射；</span><br><span class="line">-p，–publish=[]，小写的p表示为容器指定的端口进行映射，有四种形式：</span><br><span class="line"></span><br><span class="line">    containerPort：只指定容器的端口，宿主机端口随机映射；</span><br><span class="line">    hostPort:containerPort：同时指定容器与宿主机端口一一映射；</span><br><span class="line">    ip::containerPort：指定ip和容器的端口；</span><br><span class="line">    ip:hostPort:containerPort：指定ip、宿主机端口以及容器端口。</span><br><span class="line">例如：</span><br><span class="line">docker run -p <span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line">docker run -p <span class="number">8080</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line">docker run -p <span class="number">0.0</span>.0.0::<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line">docker run -p <span class="number">0.0</span>.0.0:<span class="number">8080</span>:<span class="number">80</span> -i -t ubuntu /bin/bash</span><br><span class="line"> --privileged=<span class="keyword">true</span>，以特权方式启动容器</span><br></pre></td></tr></table></figure></p><h2 id="Mac-docker-配置"><a href="#Mac-docker-配置" class="headerlink" title="Mac docker 配置"></a>Mac docker 配置</h2><ol><li><p>共享文件设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击 Preferences &gt;&gt; File Sharing</span><br></pre></td></tr></table></figure></li><li><p>配置国内镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击 Preferences &gt;&gt; Daemon &gt;&gt; Registry mirrors</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/weixin_38416579/article/details/80859265" target="_blank" rel="noopener">Mac上Docker使用例子</a></li><li><a href="https://blog.csdn.net/bskfnvjtlyzmv867/article/details/81044217" target="_blank" rel="noopener">Docker——入门实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了&lt;/p&gt;
&lt;h2 id=&quot;docker-常用命名&quot;&gt;&lt;a href=&quot;#docker-常用命名&quot; class=&quot;headerlink&quot; title=&quot;docker 常用命名&quot;&gt;&lt;/a&gt;docker 常用命名&lt;/h2&gt;&lt;h3 id=&quot;安装镜像软件&quot;&gt;&lt;a href=&quot;#安装镜像软件&quot; class=&quot;headerlink&quot; title=&quot;安装镜像软件&quot;&gt;&lt;/a&gt;安装镜像软件&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看本地所有的镜像软件&quot;&gt;&lt;a href=&quot;#查看本地所有的镜像软件&quot; class=&quot;headerlink&quot; title=&quot;查看本地所有的镜像软件&quot;&gt;&lt;/a&gt;查看本地所有的镜像软件&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker images [OPTIONS] [REPOSITORY]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a，–all=&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;，显示所有镜像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-f，–filter=[]，显示时过滤条件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;–no-trunc=&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;，指定不使用截断的形式显示数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-q，–quiet=&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;，只显示镜像的唯一id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;启动新容器&quot;&gt;&lt;a href=&quot;#启动新容器&quot; class=&quot;headerlink&quot; title=&quot;启动新容器&quot;&gt;&lt;/a&gt;启动新容器&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run &amp;lt;相关参数&amp;gt; &amp;lt;镜像 ID&amp;gt; &amp;lt;初始命令&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -i：表示以“交互模式”运行容器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -t：表示容器启动后会进入其命令行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -v：表示需要将本地哪个目录挂载到容器中，格式：-v &amp;lt;宿主机目录&amp;gt;:&amp;lt;容器目录&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; --hostname ：指定容器中绑定的域名，会在创建镜像仓库的时候使用到，这里绑定gitlab.xxx.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; --publish：端口映射；容器内的&lt;span class=&quot;number&quot;&gt;443&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;端口分别映射到宿主机的&lt;span class=&quot;number&quot;&gt;444&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;81&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;端口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; --volume ：挂载数据卷，映射到容器中去的容器外部存储空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 启动交互式容器：docker run -t -i –name=自定义名称 IMAGE_NAME /bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -i –interactive=&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; | &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;，默认是&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -t –tty=&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt; | &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;，默认是&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; –name 给启动的容器自定义名称，方便后续的容器选择操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -d (Detached)：表示容器将以后台模式运行，所有I/O数据只能通过网络资源或者共享卷组来进行交互。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -e MYSQL_ROOT_PASSWORD=&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;：-e 表示设置环境变量，此处设置了 mysql root 用户的初始密码为 &lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 例子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; docker run -ti --name mycentos centos /bin/bash 表示以“交互模式”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 运行容器容器启动后会进入其命令行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; docker exec -ti mycentos /bin/bash 在mycentos中打开/bin/bash命令行界面&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://datou-y.github.io/categories/docker/"/>
    
    
      <category term="docker" scheme="https://datou-y.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>IDEA工具开发使用@Autowired注解报错解决方案 </title>
    <link href="https://datou-y.github.io/posts/794ce61d.html/"/>
    <id>https://datou-y.github.io/posts/794ce61d.html/</id>
    <published>2019-06-16T01:55:51.289Z</published>
    <updated>2019-06-16T02:07:13.060Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>IDEA</code>工具进行开发的时候,需要<code>@Autowired</code>自动注解<code>bean</code>时会报红线,但是项目依然能够运行<br>点击<code>File--》Project Structure...--》Facets</code>删除右边对应的<code>spring</code>模块<br>对应的<code>IDEA</code>版本仅限于如下版本<br><img src="https://ae01.alicdn.com/kf/HTB1CSx7c21H3KVjSZFH762KppXau.png" alt><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;IDEA&lt;/code&gt;工具进行开发的时候,需要&lt;code&gt;@Autowired&lt;/code&gt;自动注解&lt;code&gt;bean&lt;/code&gt;时会报红线,但是项目依然能够运行&lt;br&gt;点击&lt;code&gt;File--》Project Structure...--》Facets&lt;/code&gt;删除右边对应的&lt;code&gt;spring&lt;/code&gt;模块&lt;br&gt;对应的&lt;code&gt;IDEA&lt;/code&gt;版本仅限于如下版本&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1CSx7c21H3KVjSZFH762KppXau.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="问题" scheme="https://datou-y.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="problem" scheme="https://datou-y.github.io/tags/problem/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.x(四):整合Mybatis的四种方式</title>
    <link href="https://datou-y.github.io/posts/7f83a289.html/"/>
    <id>https://datou-y.github.io/posts/7f83a289.html/</id>
    <published>2019-06-15T13:16:19.128Z</published>
    <updated>2019-06-16T08:01:16.254Z</updated>
    
    <content type="html"><![CDATA[<p>目前的大环境下，使用<code>Mybatis</code>作为持久层框架还是占了绝大多数的，下面我们来说一下使用<code>Mybatis</code>整合<code>Spring Boot</code>的几种姿势。</p><h2 id="零配置注解开发"><a href="#零配置注解开发" class="headerlink" title="零配置注解开发"></a>零配置注解开发</h2><ol><li>引入依赖</li></ol><ul><li>我们需要在<code>pom</code>文件中添加依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ol start="2"><li><code>application.properties</code> 添加相关配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_boot_demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>Spring Boot</code> 会自动加载 <code>spring.datasource.*</code> 相关配置，数据源就会自动注入到 <code>sqlSessionFactory</code> 中，<code>sqlSessionFactory</code> 会自动注入到 Mapper 中，对了，你一切都不用管了，直接拿起来使用就行了。</li></ul><ol start="3"><li>在启动类中添加对 <code>mapper</code> 包扫描<code>@MapperScan</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.demo.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>在启动类指定<code>@MapperScan，</code>这样做就可以不用去挨个的在<code>Mapper</code>接口中添加<code>@Mapper</code>注解。这里的值就是你的<code>Mapper</code>接口所在的包的路径。不然每个 <code>mapper</code> 加个注解也挺麻烦的</li></ul><ol start="4"><li>编写<code>Mapper</code>接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.enumerate.EnumerateUserSex;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.model.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from users"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>, column = <span class="string">"user_sex"</span>, javaType = EnumerateUserSex.class),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from users where id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>, column = <span class="string">"user_sex"</span>, javaType = EnumerateUserSex.class),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into users(userName,passWord,user_sex,nick_name) values(#&#123;userName&#125;,#&#123;passWord&#125;,#&#123;userSex&#125;,#&#123;nickName&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"UPDATE users SET userName=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"DELETE FROM users WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>为了更接近生产我特地将 <code>user_sex、nick_name</code> 两个属性在数据库加了下划线和实体类属性名不一致，另外 <code>user_sex</code> 使用了枚举</p></li><li><p><code>@Select</code> 是查询类的注解，所有的查询均使用这个</p></li><li><p><code>@Result</code> 修饰返回的结果集，关联实体类属性和数据库字段一一对应其中对应的参数分别有<code>property，</code>对应实体属性，<code>column</code>对应数据库字段，<code>javaType</code>指定对应<code>java</code>类型。如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。</p></li><li><p><code>@Insert</code> 插入数据库使用，直接传入实体类会自动解析属性到对应的值</p></li><li><p><code>@Update</code> 负责修改，也可以直接传入对象</p></li><li><p><code>@delete</code> 负责删除</p></li></ul><ol start="5"><li>测试程序编写<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.model.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUsers"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.getAll();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUser/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        User user = userMapper.getOne(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/add"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/delete/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="极简-xml-版本"><a href="#极简-xml-版本" class="headerlink" title="极简 xml 版本"></a>极简 xml 版本</h2><p>极简 <code>xml</code> 版本保持映射文件的老传统，接口层只需要定义空方法，系统会自动根据方法名在映射文件中找对应的 <code>Sql</code></p><ol><li>编写配置文件<br><code>pom</code> 文件第一步与姿势一的重复，只是<code>application.properties</code>新增以下配置</li></ol><ul><li>我们需要在配置文件中添加<code>mybatis-config.xml</code>的路径以及用于<code>Mapper*.xml</code>的文件的路径：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location=classpath:mybatis/mybatis-config.xml</span><br><span class="line">mybatis.mapper-locations=classpath:mybatis/mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写Mapper接口以及配置文件：</li></ol><p><code>Mapper</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mybatis-config.xml</code> 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Integer"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Long"</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"HashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.HashMap"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedHashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedHashMap"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ArrayList"</span> <span class="attr">type</span>=<span class="string">"java.util.ArrayList"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedList"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedList"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>UserMapper.xml：</code>的映射文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.neo.mapper.UserMapper"</span> &gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"BaseResultMap"</span> type=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">        &lt;id column=<span class="string">"id"</span> property=<span class="string">"id"</span> jdbcType=<span class="string">"BIGINT"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"userName"</span> property=<span class="string">"userName"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"passWord"</span> property=<span class="string">"passWord"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"user_sex"</span> property=<span class="string">"userSex"</span> javaType=<span class="string">"com.neo.enums.UserSexEnum"</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">"nick_name"</span> property=<span class="string">"nickName"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;sql id=<span class="string">"Base_Column_List"</span> &gt;</span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"getAll"</span> resultMap=<span class="string">"BaseResultMap"</span>  &gt;</span><br><span class="line">       SELECT </span><br><span class="line">       &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;</span><br><span class="line">   FROM users</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"getOne"</span> parameterType=<span class="string">"java.lang.Long"</span> resultMap=<span class="string">"BaseResultMap"</span> &gt;</span><br><span class="line">        SELECT </span><br><span class="line">       &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;</span><br><span class="line">   FROM users</span><br><span class="line">   WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">       INSERT INTO </span><br><span class="line">       users</span><br><span class="line">       (userName,passWord,user_sex) </span><br><span class="line">       VALUES</span><br><span class="line">       (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;update id=<span class="string">"update"</span> parameterType=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">       UPDATE </span><br><span class="line">       users </span><br><span class="line">       SET </span><br><span class="line">       &lt;if test="userName != null"&gt;userName = #&#123;userName&#125;,&lt;/if&gt;</span><br><span class="line">       &lt;if test="passWord != null"&gt;passWord = #&#123;passWord&#125;,&lt;/if&gt;</span><br><span class="line">       nick_name = #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">       id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;delete id=<span class="string">"delete"</span> parameterType=<span class="string">"java.lang.Long"</span> &gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">        users </span><br><span class="line">       WHERE </span><br><span class="line">        id =#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><ul><li>其实就是把上个版本中 <code>Mapper</code>的 <code>Sql</code> 搬到了这里的 <code>xml</code>中了</li><li>这里需要注意<code>UserMapper.xml</code>中的<code>namespace</code>需要与接口的路径一致，否则会出现错误</li></ul><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>使用<code>SqlSession</code>的姿势和可以与上面两种方式进行结合，emmm。。。可以这么理解，<code>SQL</code>就在那里，只不过分为了两个不同的方法去调用。其余的代码我们就不再多讲，直接来看是如何调用的：</p><p><img src="https://ae01.alicdn.com/kf/HTB1qavQafBj_uVjSZFp7630SXXaf.png" alt></p><ul><li>这里不再基于<code>Mapper</code>代理方式调用而是我们自己指定对应的Mapper接口实现类手动调用对应<code>Mapper.xml</code>中对应方法.</li><li>可以看到，参数写的是要调用的<code>方法的路径</code>（这里是与<code>namespace</code>相对应）。</li></ul><h2 id="基于SqlSession的升级"><a href="#基于SqlSession的升级" class="headerlink" title="基于SqlSession的升级"></a>基于SqlSession的升级</h2><p>这里，我们基于<code>SqlSession</code>进行了一次升级，首先我们写了一个<code>BaseDao，</code>作为一个公用的接口。接口的实现是通过<code>sqlSessionTemplate。</code><br>然后我们将<code>*Mapper.xml</code>的<code>namespace</code>改为<code>*Mapper。</code>现在，我们可以直接将所有的<code>Mapper</code>接口删除，直接通过<code>dao</code>进行调用~</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul><li><p>每个模式各有特点，<code>注解版</code>适合简单快速的模式，其实像现在流行的这种微服务模式，一个微服务就会对应一个自已的数据库，多表连接查询的需求会大大的降低，会越来越适合这种模式。</p></li><li><p><code>xml</code>老传统模式比适合大型项目，可以灵活的动态生成 <code>Sql</code>，方便调整 <code>Sql ，</code>也有痛痛快快，洋洋洒洒的写 Sql 的感觉。</p></li><li><p>其他两种模式基于<code>SqlSession</code>属于低层一点，初步学习者可以练手，可以了解mybatis如何进行映射的和对应方法调用过程。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html" target="_blank" rel="noopener">Spring Boot(六)：如何优雅的使用 Mybatis</a><br>-<a href="https://www.cnblogs.com/viyoung/p/10167856.html" target="_blank" rel="noopener">Spring Boot 2.x（四）：整合Mybatis的四种方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前的大环境下，使用&lt;code&gt;Mybatis&lt;/code&gt;作为持久层框架还是占了绝大多数的，下面我们来说一下使用&lt;code&gt;Mybatis&lt;/code&gt;整合&lt;code&gt;Spring Boot&lt;/code&gt;的几种姿势。&lt;/p&gt;
&lt;h2 id=&quot;零配置注解开发&quot;&gt;&lt;a href=&quot;#零配置注解开发&quot; class=&quot;headerlink&quot; title=&quot;零配置注解开发&quot;&gt;&lt;/a&gt;零配置注解开发&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;引入依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;我们需要在&lt;code&gt;pom&lt;/code&gt;文件中添加依赖&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门快速搭建web项目</title>
    <link href="https://datou-y.github.io/posts/914fc93.html/"/>
    <id>https://datou-y.github.io/posts/914fc93.html/</id>
    <published>2019-06-15T01:21:26.064Z</published>
    <updated>2019-06-15T13:14:01.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h2><p><code>Spring Boot</code> 是由 <code>Pivotal</code> 团队提供的全新框架，其设计目的是用来简化新 <code>Spring</code> 应用的初始搭建以及开发过程。该框架使用了<code>特定的方式</code>来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 <code>Spring Boot</code> 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 <code>Maven</code> 整合了所有的 <code>Jar</code> 包，<code>Spring Boot</code> 整合了所有的框架。</p><h2 id="使用-Spring-Boot-有什么好处"><a href="#使用-Spring-Boot-有什么好处" class="headerlink" title="使用 Spring Boot 有什么好处"></a>使用 Spring Boot 有什么好处</h2><ul><li>配置 <code>web.xml</code>，加载 <code>Spring</code> 和 <code>Spring mvc</code></li><li>配置数据库连接、配置 <code>Spring</code> 事务</li><li>配置加载配置文件的读取，开启注解</li><li>配置日志文件</li><li>…</li><li>配置完成之后部署 <code>Tomcat</code> 调试</li></ul><p>现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!</p><p>但是如果使用 <code>Spring Boot</code> 呢？<br>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！</p><p>使用 <code>Spring Boot</code> 到底有多爽，用下面这幅图来表达<br><img src="https://ae01.alicdn.com/kf/HTB1DT75cRCw3KVjSZFlq6AJkFXaO.jpg" alt></p><a id="more"></a><h2 id="官网在线搭建"><a href="#官网在线搭建" class="headerlink" title="官网在线搭建"></a>官网在线搭建</h2><ol><li><p><a href="http://start.spring.io/" target="_blank" rel="noopener">访问官网 https://start.spring.io/</a></p></li><li><p>选择构建工具 <code>Maven Project</code>、语言<code>Java</code>、<code>Spring Boot</code>版本 <code>Project Metadata</code> 工程基本信息</p></li></ol><p><img src="https://ae01.alicdn.com/kf/HTB1AtQ1cLWG3KVjSZFg762TspXa2.png" alt></p><ol start="3"><li><p>点击 <code>Generate Project</code>下载项目压缩包</p></li><li><p>解压后，使用 <code>Idea</code> 导入项目，<code>File -&gt; New -&gt; Model from Existing Source.. -&gt;</code>选择解压后的文件夹 -&gt;<code>OK，</code>选择 <code>Maven 一路 Next，OK done!</code></p></li></ol><h2 id="通过Intellij-IDEA搭建"><a href="#通过Intellij-IDEA搭建" class="headerlink" title="通过Intellij IDEA搭建"></a>通过Intellij IDEA搭建</h2><ol><li>选择 <code>File -&gt; New —&gt; Project…</code> 弹出新建项目的框</li><li>选择 <code>Spring Initializr，Next</code> 也会出现上述类似的配置界面，Idea 帮我们做了集成</li><li>填写相关内容后，点击 <code>Next</code> 选择依赖的包再点击 <code>Next</code>，最后确定信息无误点击 <code>Finish</code></li><li>如果使用的是 <code>Eclipse，</code> <code>Import -&gt; Existing Maven Projects -&gt; Next -&gt;</code>选择解压后的文件夹 -&gt; <code>Finsh，OK done!</code></li></ol><h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2><p><img src="https://ae01.alicdn.com/kf/HTB1FEo7cR1D3KVjSZFy762uFpXad.png" alt></p><p>如上图所示，Spring Boot 的基础结构共三个文件:</p><ul><li><code>src/main/java</code> 程序开发以及主程序入口</li><li><code>src/main/resources</code> 配置文件</li><li><code>src/test/java</code> 测试程序</li></ul><p>另外， <code>Spring Boot</code> 建议的目录结果如下：<br><code>root package</code> 结构：<code>com.example.myproject</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- model</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure></p><ol><li><code>Application.java</code> 建议放到根目录下面,主要用于做一些框架配置</li><li><code>model</code> 目录主要用于实体与数据访问层（<code>Repository</code>）</li><li><code>service</code> 层主要是业务类代码</li><li><code>controller</code> 负责页面访问控制</li></ol><p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改<br>最后，启动 Application main 方法，至此一个 Java 项目搭建好了！</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><code>pom.xml</code>中添加支持<code>web</code>的模块：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p><code>pom.xml</code> 文件中默认有两个模块:<br><code>spring-boot-starter</code> ：核心模块，包括自动配置支持、日志和 <code>YAML</code><br><code>spring-boot-starter-test</code> ：测试模块，包括 <code>JUnit、Hamcrest、Mockito</code><br><code>spring-boot-starter-web</code> 自动依赖了 <code>spring-boot-starter</code>加了<code>web</code>模块后可以去掉<code>spring-boot-starter</code>模块</p><ol start="2"><li>编写 Controller 内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@RestController</code> 的意思就是 <code>Controller</code> 里面的方法都以 <code>json</code> 格式输出，不用再写什么 <code>jackjson</code> 配置的了！</p><ol start="3"><li>启动主程序，打开浏览器访问 <code>http://localhost:8080/hello</code>，就可以看到效果了，有木有很简单！</li></ol><p><div class="tip"><a href="https://github.com/daTou-Y/spring-boot-examples/tree/master/spring-boot-helloWorld" target="_blank" rel="noopener">GitHub示例代码</a><div></div></div></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_27317475/article/details/81119098" target="_blank" rel="noopener">SpringBoot入门，快速搭建简单Web应用环境</a></li><li><a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html" target="_blank" rel="noopener">Spring Boot(一)：入门篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Spring-Boot&quot;&gt;&lt;a href=&quot;#什么是Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring Boot&quot;&gt;&lt;/a&gt;什么是Spring Boot&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 是由 &lt;code&gt;Pivotal&lt;/code&gt; 团队提供的全新框架，其设计目的是用来简化新 &lt;code&gt;Spring&lt;/code&gt; 应用的初始搭建以及开发过程。该框架使用了&lt;code&gt;特定的方式&lt;/code&gt;来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 &lt;code&gt;Spring Boot&lt;/code&gt; 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 &lt;code&gt;Maven&lt;/code&gt; 整合了所有的 &lt;code&gt;Jar&lt;/code&gt; 包，&lt;code&gt;Spring Boot&lt;/code&gt; 整合了所有的框架。&lt;/p&gt;
&lt;h2 id=&quot;使用-Spring-Boot-有什么好处&quot;&gt;&lt;a href=&quot;#使用-Spring-Boot-有什么好处&quot; class=&quot;headerlink&quot; title=&quot;使用 Spring Boot 有什么好处&quot;&gt;&lt;/a&gt;使用 Spring Boot 有什么好处&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置 &lt;code&gt;web.xml&lt;/code&gt;，加载 &lt;code&gt;Spring&lt;/code&gt; 和 &lt;code&gt;Spring mvc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置数据库连接、配置 &lt;code&gt;Spring&lt;/code&gt; 事务&lt;/li&gt;
&lt;li&gt;配置加载配置文件的读取，开启注解&lt;/li&gt;
&lt;li&gt;配置日志文件&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;配置完成之后部署 &lt;code&gt;Tomcat&lt;/code&gt; 调试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!&lt;/p&gt;
&lt;p&gt;但是如果使用 &lt;code&gt;Spring Boot&lt;/code&gt; 呢？&lt;br&gt;很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Spring Boot&lt;/code&gt; 到底有多爽，用下面这幅图来表达&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1DT75cRCw3KVjSZFlq6AJkFXaO.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>java中数据类型分类</title>
    <link href="https://datou-y.github.io/posts/2b16cdcb.html/"/>
    <id>https://datou-y.github.io/posts/2b16cdcb.html/</id>
    <published>2019-06-13T13:04:29.649Z</published>
    <updated>2019-06-13T13:17:55.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Na0AcRGE3KVjSZFh763kaFXaM.png" alt><br><a id="more"></a></p><h2 id="区别表"><a href="#区别表" class="headerlink" title="区别表"></a>区别表</h2><p><img src="https://ae01.alicdn.com/kf/HTB1UMFxcL1H3KVjSZFB762SMXXal.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Na0AcRGE3KVjSZFh763kaFXaM.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql查询结果去除重复数据</title>
    <link href="https://datou-y.github.io/posts/e1a86da4.html/"/>
    <id>https://datou-y.github.io/posts/e1a86da4.html/</id>
    <published>2019-06-12T13:57:50.756Z</published>
    <updated>2019-06-13T09:52:43.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> st.stu_name <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.stu_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删选出重复数据</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> A <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;distinct去重&quot;&gt;&lt;a href=&quot;#distinct去重&quot; class=&quot;headerlink&quot; title=&quot;distinct去重&quot;&gt;&lt;/a&gt;distinct去重&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;distinct&lt;/span&gt; st.stu_name &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student st&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; st.stu_name &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;group-by&quot;&gt;&lt;a href=&quot;#group-by&quot; class=&quot;headerlink&quot; title=&quot;group by&quot;&gt;&lt;/a&gt;group by&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 删选出重复数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;having&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*)&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql查询字段为null的处理</title>
    <link href="https://datou-y.github.io/posts/8a034c1e.html/"/>
    <id>https://datou-y.github.io/posts/8a034c1e.html/</id>
    <published>2019-06-12T10:43:41.101Z</published>
    <updated>2019-06-12T14:15:11.116Z</updated>
    
    <content type="html"><![CDATA[<ol><li>通过<code>is (not) null</code>进行<code>where</code>条件判断处理</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> A <span class="keyword">where</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 <code>case when</code>进行逻辑语句上的判断<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">      <span class="keyword">when</span> a <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span></span><br><span class="line">      <span class="string">''</span></span><br><span class="line">      <span class="keyword">when</span> a=<span class="string">"a"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="string">"b"</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="string">"idbs"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    ) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li>通过<code>IFNULL</code>函数进行判断<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>(a,<span class="string">"b"</span>) <span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>ifnull(a,&quot;b&quot;)</code>第一个参数是你要查询字段，第二个是字段为<code>null</code>是的值</li></ul><ol start="4"><li><code>null</code>值概念</li></ol><ul><li>空值是不占用空间的。</li><li><code>mysql</code>中的<code>NULL</code>其实是占用空间的,打个比方来说，你有一个杯子，空值代表杯子是真空的，<code>NULL</code>代表杯子中装满了空气，虽然杯子看起来都是空的，但是区别是很大的</li><li><code>NOT NULL</code> 的字段是不能插入<code>“NULL”</code>的，只能插入<code>“空值”</code></li></ul><ol start="5"><li>总结</li></ol><ul><li>在进行<code>count()</code>统计某列的记录数的时候，如果采用的<code>NULL</code>值，系统会自动忽略掉，但是空值是会进行统计到其中的。</li><li>判断<code>NULL</code> 用<code>IS NULL</code> 或者 <code>IS NOT NULL</code>, SQL语句函数中可以使用<code>ifnull()</code>函数来进行处理，判断<code>空字符</code>用<code>=&#39;&#39;</code>或者 <code>&lt;&gt;&#39;&#39;</code>来进行处理</li><li>对于<code>MySQL</code>特殊的注意事项，对于<code>timestamp</code>数据类型，如果往这个数据类型插入的列插入<code>NULL</code>值，则出现的值是<code>当前系统时间</code>。插入<code>空值</code>，则会出现 <code>0000-00-00 00:00:00</code><br>对于<code>空值</code>的判断到底是使用<code>is null</code> 还是<code>=&#39;&#39;</code> 要根据实际业务来进行区分。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/WNsshssm/article/details/79558452" target="_blank" rel="noopener">mysql查询字段为null时，返回空字符串</a></li><li><a href="https://blog.csdn.net/huanghanqian/article/details/85381552" target="_blank" rel="noopener">MySQL判断字段是否为null</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;is (not) null&lt;/code&gt;进行&lt;code&gt;where&lt;/code&gt;条件判断处理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过 &lt;code&gt;case when&lt;/code&gt;进行逻辑语句上的判断&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; a=&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;idbs&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>java全能最新自己面试企业真题总结</title>
    <link href="https://datou-y.github.io/posts/4112469.html/"/>
    <id>https://datou-y.github.io/posts/4112469.html/</id>
    <published>2019-06-12T09:44:46.521Z</published>
    <updated>2019-06-12T10:20:52.384Z</updated>
    
    <content type="html"><![CDATA[<p>这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。<br><img src="https://ae01.alicdn.com/kf/HTB1Kq2ccA5E3KVjSZFCq6zuzXXad.jpg" alt><br><a id="more"></a></p><div class="tip"><br>所有题目都在博客文章中有涉及<br></div><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ol><li><code>List</code>，<code>Set</code>，<code>Map</code>的区别</li><li><code>ArrayList</code>,<code>LinkList</code>,<code>Vector</code>区别</li><li><code>HashMap</code>,<code>HashTable</code>的区别</li><li><code>List</code>排序</li><li><code>List</code>去重</li><li><code>List</code>进行遍历修改操作是否会报错</li><li><code>List</code>数据的获取</li><li>数组排序</li><li><code>String</code>,<code>StringBuild</code>,<code>StringBuffer</code>区别</li><li><code>jdk1.8</code>新特性</li><li><code>Exception</code> 和<code>Error</code>区别</li><li>线程同步，与线程通信</li><li>java基本数据类型</li><li>生产指定的随机数</li><li>表单重复提交</li><li>单点登录</li><li><code>split(&quot;|&quot;)</code>和<code>split(&quot;//|&quot;)</code>区别</li><li><code>final</code>,<code>finaly</code>,<code>finalize</code>区别</li><li><code>overload</code>和<code>override</code>区别<code>overrided</code>返回值可以改变吗</li><li>如何实现<code>HashMap</code>同步或者是<code>ArrayList</code>同步</li><li><code>抽象类</code>，和<code>接口</code>的区别</li><li><code>==</code>和<code>equal</code>区别</li></ol><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol><li><code>mysql</code>数据去重</li><li>给你题目手写<code>mysql</code>语句</li><li>mysql<code>日期函数</code></li><li>mysql优化</li><li>mysql中<code>union</code>和<code>union all</code>区别</li><li>mysql中<code>in</code> 和 <code>exists</code>区别</li><li>mysql<code>索引</code></li><li>事物特性</li><li>判断什么情况下索引会失效</li><li>使用函数表达式会影响效率吗，会破坏索引吗</li><li>如何获取自增主键</li><li>如何获取重复的数据</li><li>如何对数据库<code>null</code>值处理</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ol><li>项目中什么时候用到<code>redis</code></li><li><code>redis</code>原理</li><li>项目中用到<code>redis</code>那些类型</li></ol><h2 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h2><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><ol><li>项目中有没有遇到数据比较多的时候，如何处理的</li><li>项目中高并发解决</li></ol><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ol><li>介绍自己项目经验，和做过的项目</li><li>会就简历上有的项目进行技术点提问</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Kq2ccA5E3KVjSZFCq6zuzXXad.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="面试" scheme="https://datou-y.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析MySQL中exists与in的使用和区别</title>
    <link href="https://datou-y.github.io/posts/df7b0a0e.html/"/>
    <id>https://datou-y.github.io/posts/df7b0a0e.html/</id>
    <published>2019-06-11T12:46:01.117Z</published>
    <updated>2019-06-11T14:20:49.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是exists"><a href="#什么是exists" class="headerlink" title="什么是exists"></a>什么是exists</h2><p>exists表示存在，它常常和子查询配合使用，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">      <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> score sc <span class="keyword">where</span> sc.stu_id= st.stu_id);</span><br></pre></td></tr></table></figure><ul><li><code>exists</code>用于检查<code>子查询</code>是否至少会返回一行数据,如果返回空集<code>exists</code>返回值就是<code>false</code>，否则就是<code>true</code>,该子查询实际不返还任何数据。</li><li><code>exists</code>对外表用<code>loop</code>逐条查询，每次查询都会查看<code>exists</code>的条件语句</li><li>当子查询返回为真时，则外层查询语句将进行查询</li><li>当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。<a id="more"></a><h2 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h2></li><li>与<code>exists</code>条件相反，就是当<code>exists</code>结果集有反会值是时候条件为<code>false</code>否则为<code>true</code></li></ul><h2 id="in-查询"><a href="#in-查询" class="headerlink" title="in 查询"></a>in 查询</h2><ul><li><p>in查询相当于多个or条件的叠加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id=<span class="number">1</span> <span class="keyword">or</span> st.stu_id=<span class="number">2</span> <span class="keyword">or</span> st.stu_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>not in</code>与<code>in</code>相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id!=<span class="number">1</span> <span class="keyword">and</span> st.stu_id!=<span class="number">2</span> <span class="keyword">and</span> st.stu_id!=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="in-子查询"><a href="#in-子查询" class="headerlink" title="in 子查询"></a>in 子查询</h2><ul><li><code>in</code>查询的子条件返回结果必须只有一个字段</li><li><code>in()</code>语句只会执行一次，会将符合子查询条件的记录全都查出来，假设结果集为B，共有m条记录并且缓存起来，然后在将子查询条件的结果集分解成m个，再进行m次查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><ul><li>以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将<code>A</code>表的记录加入结果集中,直到遍历完A表的所有记录</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/ye411685846/article/details/61196162" target="_blank" rel="noopener">浅析MySQL中exists与in的使用</a></li><li><a href="https://blog.csdn.net/cool_wayen/article/details/79614806" target="_blank" rel="noopener">mysql中exit和in的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是exists&quot;&gt;&lt;a href=&quot;#什么是exists&quot; class=&quot;headerlink&quot; title=&quot;什么是exists&quot;&gt;&lt;/a&gt;什么是exists&lt;/h2&gt;&lt;p&gt;exists表示存在，它常常和子查询配合使用，&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student st &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; score sc &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; sc.stu_id= st.stu_id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;用于检查&lt;code&gt;子查询&lt;/code&gt;是否至少会返回一行数据,如果返回空集&lt;code&gt;exists&lt;/code&gt;返回值就是&lt;code&gt;false&lt;/code&gt;，否则就是&lt;code&gt;true&lt;/code&gt;,该子查询实际不返还任何数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;对外表用&lt;code&gt;loop&lt;/code&gt;逐条查询，每次查询都会查看&lt;code&gt;exists&lt;/code&gt;的条件语句&lt;/li&gt;
&lt;li&gt;当子查询返回为真时，则外层查询语句将进行查询&lt;/li&gt;
&lt;li&gt;当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="exists" scheme="https://datou-y.github.io/tags/exists/"/>
    
      <category term="in" scheme="https://datou-y.github.io/tags/in/"/>
    
  </entry>
  
  <entry>
    <title>mysql union 和union all使用</title>
    <link href="https://datou-y.github.io/posts/7bb7ade4.html/"/>
    <id>https://datou-y.github.io/posts/7bb7ade4.html/</id>
    <published>2019-06-11T11:58:04.162Z</published>
    <updated>2019-06-11T12:45:21.743Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库中，<code>UNION</code>和<code>UNION ALL</code>关键字都是将两个结果集合并为一个，<code>UNION</code>用的比较多<code>union all</code>是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 </p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>[SQL 语句 1]<br>    UNION<br>[SQL 语句 2]</p><p>[SQL 语句 1]<br>   UNION ALL<br>[SQL 语句 2]<br><a id="more"></a></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>对重复结果的处理：<code>UNION</code>在进行表链接后会筛选掉重复的记录，<code>Union All</code>不会去除重复<br>记录</li><li>对排序的处理：<code>Union</code>将会按照字段的顺序进行排序；<code>UNION ALL</code>只是简单的将两个结果合并后就返回</li><li>从效率上说，<code>UNION ALL</code> 要比<code>UNION</code>快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用<code>UNION ALL</code>。</li></ul><div class="tip"><br>如果您想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/youpai/p/9473231.html" target="_blank" rel="noopener">mysql中union与union all的区别</a></li><li><a href="https://www.cnblogs.com/hanyouchun/p/3688070.html" target="_blank" rel="noopener">MySQL中UNION和UNION ALL的使用</a></li><li><a href="https://www.liangzl.com/get-article-detail-37503.html" target="_blank" rel="noopener">mysql union 和union all使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据库中，&lt;code&gt;UNION&lt;/code&gt;和&lt;code&gt;UNION ALL&lt;/code&gt;关键字都是将两个结果集合并为一个，&lt;code&gt;UNION&lt;/code&gt;用的比较多&lt;code&gt;union all&lt;/code&gt;是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 &lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;[SQL 语句 1]&lt;br&gt;    UNION&lt;br&gt;[SQL 语句 2]&lt;/p&gt;
&lt;p&gt;[SQL 语句 1]&lt;br&gt;   UNION ALL&lt;br&gt;[SQL 语句 2]&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="union" scheme="https://datou-y.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>mysql中聚合函数日期函数使用详细和实例</title>
    <link href="https://datou-y.github.io/posts/74138ad2.html/"/>
    <id>https://datou-y.github.io/posts/74138ad2.html/</id>
    <published>2019-06-08T02:14:41.114Z</published>
    <updated>2019-06-11T12:11:10.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p><code>mysql</code> 数据库中 <code>count()</code> 函数是统计查询结果中的行数。列如下面的<code>empy</code>表</p><p><img src="https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://ae01.alicdn.com/kf/HTB1902abW5s3KVjSZFN763D3FXaO.png" alt></p><div class="tip"><br>注意的是，count 会忽略掉 NULL 的结果， 所以 count(字段名) 这样使用的话，如果字段中包含为null的结果，将导致查询结果不准确，列如：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1.sq4b25G3KVjSZPx762I3XXaT.png" alt></p><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p><code>mysql</code> 中 <code>sum()</code> 函数用于计算某一字段中所有行的数值之和（ <code>sum 求和时会对 null 进行过滤，不计算</code>）,如果对无法计算的列进行<code>sum()</code>sum 函数的返回值为 <code>0</code>,如果没有符合条件的行，<code>sum()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为0</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为32</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><p><code>mysql</code> 中 <code>max()</code> 函数用于计算某一字段中所有行的最大值,如果对无法比较的列进行<code>max()</code>max 函数的返回值为 <code>xxx</code>,如果没有符合条件的行，<code>max()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为xxx</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为4</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><p><code>mysql</code>中 <code>min()</code>函数用于计算某一字段中所有行的最小值</p><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><ul><li>返回指定字段的数据的平均值</li><li><code>avg()</code> 通过对表中行数计数并计算指定字段的数据总和，求得该字段的平均值。</li></ul><h2 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h2><ul><li>获得当前日期+时间（<code>date + time</code>）函数：<code>now()</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(), <span class="keyword">sleep</span>(<span class="number">3</span>), <span class="keyword">now</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="sysdate"><a href="#sysdate" class="headerlink" title="sysdate()"></a>sysdate()</h2><ul><li><code>sysdate()</code> 日期时间函数跟 <code>now()</code>类似，不同之处在于：<code>now()</code> 在执行开始时值就得到了<code>sysdate()</code>在函数执行时动态得到值</li><li><code>sysdate()</code> 日期时间函数，一般情况下很少用到。</li></ul><h2 id="current-timestamp"><a href="#current-timestamp" class="headerlink" title="current_timestamp()"></a>current_timestamp()</h2><ul><li>获得当前时间戳函数<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span>, <span class="keyword">current_timestamp</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="date-format-date-format"><a href="#date-format-date-format" class="headerlink" title="date_format(date,format)"></a>date_format(date,format)</h2><ul><li>日期/时间转换为字符串<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">date_format</span>(<span class="string">'2008-08-08 22:23:01'</span>, <span class="string">'%Y%m%d%H%i%s'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="str-to-date-str-format"><a href="#str-to-date-str-format" class="headerlink" title="str_to_date(str,format)"></a>str_to_date(str,format)</h2><ul><li>可以把一些杂乱无章的字符串转换为日期格式也可以转换为时间<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/2008'</span>, <span class="string">'%m/%d/%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/08'</span> , <span class="string">'%m/%d/%y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008'</span>, <span class="string">'%m.%d.%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08:09:30'</span>, <span class="string">'%h:%i:%s'</span>); <span class="comment">-- 08:09:30</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008 08:09:30'</span>, <span class="string">'%m.%d.%Y %h:%i:%s'</span>); <span class="comment">--</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/progor/p/8832663.html" target="_blank" rel="noopener">mysql之常用函数</a></li><li><a href="https://www.cnblogs.com/ggjucheng/p/3352280.html" target="_blank" rel="noopener"> MySQL 获得当前日期时间 函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;count&quot;&gt;&lt;a href=&quot;#count&quot; class=&quot;headerlink&quot; title=&quot;count&quot;&gt;&lt;/a&gt;count&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt; 数据库中 &lt;code&gt;count()&lt;/code&gt; 函数是统计查询结果中的行数。列如下面的&lt;code&gt;empy&lt;/code&gt;表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; empy;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="聚合函数" scheme="https://datou-y.github.io/tags/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>java中随机数使用</title>
    <link href="https://datou-y.github.io/posts/7b083b8f.html/"/>
    <id>https://datou-y.github.io/posts/7b083b8f.html/</id>
    <published>2019-06-07T09:32:12.122Z</published>
    <updated>2019-06-07T10:31:35.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数创建"><a href="#随机数创建" class="headerlink" title="随机数创建"></a>随机数创建</h2><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line">System.out.println(timeMillis);</span><br></pre></td></tr></table></figure><ul><li><code>long currentTimeMillis()</code> 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( timeMillis % <span class="number">1000</span> );</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要除以<code>100</code>获取<code>[0-1000]</code>就除以<code>1000</code>类推即可</li></ul><a id="more"></a><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><ul><li><code>double Math.random()</code>来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的<code>double</code>值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line"><span class="keyword">int</span> i=(<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要乘以<code>100</code>获取<code>[0-1000]</code>就乘以<code>1000</code>类推即可</li></ul><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//指定值构造方法</span></span><br><span class="line">Random rs=<span class="keyword">new</span> Random(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li><code>int r.nextInt(100)</code>获取[0, 100)之间的<code>int</code>整数Random支持的随机值类型包括：boolean, byte, int, long, float, double等</li></ul><h2 id="Random常用方法"><a href="#Random常用方法" class="headerlink" title="Random常用方法"></a>Random常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java 的随机数测试程序。共3种获取随机数的方法：</span></span><br><span class="line"><span class="comment"> *   (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。</span></span><br><span class="line"><span class="comment"> *   (02)、通过Math.random()返回一个0到1之间的double值。</span></span><br><span class="line"><span class="comment"> *   (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过System的currentTimeMillis()返回随机数</span></span><br><span class="line">        testSystemTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Math的random()返回随机数</span></span><br><span class="line">        testMathRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建“种子为1000”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 1st Random(1000)"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 2nd Random(1000)"</span>);</span><br><span class="line">        <span class="comment">// 新建“默认种子”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 1st Random()"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 2nd Random()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-01：测试System的currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSystemTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 通过l获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( l % <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- System.currentTimeMillis() ----\n l=%s i=%s\n"</span>, l, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-02：测试Math的random()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMathRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> d = Math.random();</span><br><span class="line">        <span class="comment">// 通过d获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- Math.random() ----\n d=%s i=%s\n"</span>, d, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-03：测试Random的API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAPIs</span><span class="params">(Random random, String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_LEN = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机的boolean值</span></span><br><span class="line">        <span class="keyword">boolean</span> b = random.nextBoolean();</span><br><span class="line">        <span class="comment">// 获取随机的数组buf[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_LEN];</span><br><span class="line">        random.nextBytes(buf);</span><br><span class="line">        <span class="comment">// 获取随机的Double值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">double</span> d = random.nextDouble();</span><br><span class="line">        <span class="comment">// 获取随机的float值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">float</span> f = random.nextFloat();</span><br><span class="line">        <span class="comment">// 获取随机的int值</span></span><br><span class="line">        <span class="keyword">int</span> i1 = random.nextInt();</span><br><span class="line">        <span class="comment">// 获取随机的[0,100)之间的int值</span></span><br><span class="line">        <span class="keyword">int</span> i2 = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 获取随机的高斯分布的double值</span></span><br><span class="line">        <span class="keyword">double</span> g = random.nextGaussian();</span><br><span class="line">        <span class="comment">// 获取随机的long值</span></span><br><span class="line">        <span class="keyword">long</span> l = random.nextLong();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- %s ----\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=["</span>,</span><br><span class="line">                title, b, d, f, i1, i2, g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> bt:buf) </span><br><span class="line">            System.out.printf(<span class="string">"%s, "</span>, bt);</span><br><span class="line">        System.out.println(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/skywang12345/p/3341423.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3341423.html</a></li><li><a href="https://www.cnblogs.com/blogxjc/p/9687297.html" target="_blank" rel="noopener">java的三种随机数生成方式</a></li><li><a href="https://www.cnblogs.com/dyx2018/p/9189700.html" target="_blank" rel="noopener">Java 生成随机数</a></li><li><a href="https://www.cnblogs.com/cx-code/p/10005915.html" target="_blank" rel="noopener">java随机生成6位随机数 5位随机数 4位随机数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随机数创建&quot;&gt;&lt;a href=&quot;#随机数创建&quot; class=&quot;headerlink&quot; title=&quot;随机数创建&quot;&gt;&lt;/a&gt;随机数创建&lt;/h2&gt;&lt;h3 id=&quot;currentTimeMillis&quot;&gt;&lt;a href=&quot;#currentTimeMillis&quot; class=&quot;headerlink&quot; title=&quot;currentTimeMillis()&quot;&gt;&lt;/a&gt;currentTimeMillis()&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(timeMillis);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;long currentTimeMillis()&lt;/code&gt; 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)( timeMillis % &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;若要获取&lt;code&gt;int&lt;/code&gt;类型的整数，只需要将上面的结果转成&lt;code&gt;int&lt;/code&gt;类型即可。比如，&lt;code&gt;获取[0, 100)&lt;/code&gt;之间的&lt;code&gt;int&lt;/code&gt;整数要除以&lt;code&gt;100&lt;/code&gt;获取&lt;code&gt;[0-1000]&lt;/code&gt;就除以&lt;code&gt;1000&lt;/code&gt;类推即可&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="random" scheme="https://datou-y.github.io/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>java中进程和线程</title>
    <link href="https://datou-y.github.io/posts/c206fba0.html/"/>
    <id>https://datou-y.github.io/posts/c206fba0.html/</id>
    <published>2019-06-06T13:53:01.653Z</published>
    <updated>2019-06-07T11:47:19.386Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg" alt><br><a id="more"></a></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><blockquote><p><code>run()</code>方法是执行的线程体，<code>start()</code>用于启动线程</p></blockquote><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><ul><li>继承<code>Thread</code>类的类就是一个线程类，通过创建当前类的实例，来创建多个线程</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span>   <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><ul><li>由于<code>Runnable</code>接口没有定义<code>start</code>方法，而一定的规定要求，必须通过<code>Thread.start</code><br>方法来启动继承；</li><li><code>Thread</code>类中有 <code>【Thread（Runnable target）】</code>构造方法，可以接收<code>Runnable接口</code><br>的参数</li><li>于是我们可以实例化<code>Threda</code>类，将<code>Runnable</code>对象交给<code>Thread</code>类处理并调用其<code>start()</code>方法启动多线程</li></ul><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul><li><code>Runnable</code>接口实现的多线程不能返回操作结果；所以提供了一个新的多线程接口——<code>Callable接口【java.util.concurrent 包】</code></li><li><code>call()</code>方法在 执行主要功能后，可以返回结果，而返回结果的类型有<code>Calable</code>接口泛型来决定。</li><li><code>Callable接口</code>的<code>call()</code>是线程执行体，代替原来<code>run()</code>方法可以有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* Thread类中并没有接收Callabel对象的构造方法，所以无法通过start()来启动多线程</span></span><br><span class="line"><span class="comment">* 但是Java提供java.util.concurrent。FutureTask&lt;V&gt; 类 ， </span></span><br><span class="line"><span class="comment">* 在FutureTask类的定义结构如下：</span></span><br><span class="line"><span class="comment">* public class FutureTask&lt;V&gt; extends Object implements Future&lt;V&gt; , Runnable</span></span><br><span class="line"><span class="comment">* 类中有如下的构造方法：</span></span><br><span class="line"><span class="comment">* public FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line"><span class="comment">* FutureTask类接收Callable接口对象。目的就是：取得call()方法的返回结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OKOK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread); <span class="comment">// 目的是为了接收call返回值</span></span><br><span class="line">FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread1);</span><br><span class="line"><span class="comment">// FutureTask是Runnable接口子类，所以可以使用Thread类的构造来接收task对象</span></span><br><span class="line"><span class="keyword">new</span> Thread(task1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line"><span class="comment">// 多线程执行完毕后，依靠FutureTask的父接口 Future中的get()方法完成。</span></span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task.get());</span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task1.get());</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="tip"><br>使用Runnable接口与Thread类相比之下，解决了Thrad类单继承局限的问题<br></div><ul><li>数据共享的不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><p>两个程序例子，都是实现三个线程的启动；不同的地方在于，<code>Thread</code>的三个线程使用的是三个不同的实例对象如<code>代码块一</code>，而<code>Runnable</code>的三个线程均是通过<code>实例化Thread</code>类调用<code>Start()</code>方法对<code>同一实例对象</code>进行三个线程的操作如<code>代码块二</code>。<code>Runnable</code>更好的实现了同一数据共享（当然Thread也可以，只是没有Runnable简单）</p><p>  两者的区别</p><p>　　Thread类是Runnable接口的一个子类，使用Runnable接口实现多线程可以避免单继承的局限性</p><p>　　Runnable接口实现的多线程可以比Thrad类实现的多线程更加清楚的描述</p><h2 id="多线程的常用操作方法"><a href="#多线程的常用操作方法" class="headerlink" title="多线程的常用操作方法"></a>多线程的常用操作方法</h2><h3 id="线程的命名与获得"><a href="#线程的命名与获得" class="headerlink" title="线程的命名与获得"></a>线程的命名与获得</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName()</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = C"</span>).start();</span><br><span class="line">thread.setName(<span class="string">"线程A"</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Thread.currentThread().getName()</code> 获取当前线程的名称，如果自己没有设置名称默认的名称为<code>Thread-0</code>,<code>Thread-1</code>依次类推</li><li><code>new Thread(thread,&quot;线程A&quot;).start()</code> 设置线程名称适用于实现接口方式的线程创建</li><li><code>thread.setName(&quot;线程A&quot;)</code> 设置线程的名称，适用于继承Thread类的线程创建</li></ul><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sleep(long millis)</code>  线程睡眠 <code>millis</code> 毫秒</li><li><code>sleep(long millis, int nanos)</code>  线程睡眠 <code>millis</code> 毫秒 + <code>nanos</code> 纳秒</li><li>因为<code>sleep()</code>是静态方法，所以最好的调用方法就是 <code>Thread.sleep()</code></li><li>线程的<code>sleep</code>方法应该写在线程的run()方法里，就能让对应的线程睡眠,<code>sleep</code>调用无关调用的线程对象，在那里调用那个线程就睡眠</li><li><code>sleep()</code>方法导致了程序暂停执行指定的时间，让出<code>cpu</code>给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>在调用<code>sleep()</code>方法的过程中，线程不会释放对象锁资源</li></ul><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>优先级越高，越有可能先执行；Thread类中设置了两个方法：</p><blockquote><p>改变线程优先级：    public final void setPriority(int newPriority) ;<br>返回线程优先级：    public final void getPriority() ;</p></blockquote><p><div class="tip"><br>java中线程优先级效果不是特别明显所以不使用一般</div></p><div><h2 id="线程的同步与死锁"><a href="#线程的同步与死锁" class="headerlink" title="线程的同步与死锁"></a>线程的同步与死锁</h2><p>同步指的是<code>多个线程访问同一资源</code>时的问题；即多个线程对象操作同一个对象资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1OPJgb21G3KVjSZFk761K4XXaL.png" alt><br>此时，上例没有出现任何问题！<br>但在代码<code>run()</code>的for中加入延迟<code>【Thread.sleep();】</code>就会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://ae01.alicdn.com/kf/HTB1h1JpbYus3KVjSZKb760qkFXa8.png" alt></p><ul><li>可以明显的发现，结果中出现了相同值（意外值）；这就是“不同步”的状况【异步操作】。<br>上例代码的想法是：从同一个资源取得当前的剩余的点数，但是由于<code>延迟</code>的存在，后续的线程不会等待之前的线程，会直接的进入，导致剩余值没有得到及时的刷新,而出现问题</li></ul><blockquote><p>同步的操作<br>所谓同步就是指<code>多个线程操作同一时间只能有一个线程进入同一个空间运行</code>，其他线程要等待此线程完成之后才可以继续执行。而之前的不同步【或称为异步操作】，则是多个线程可以同一时间进入同一个空间运行。</p></blockquote><ul><li><code>java</code>中实现线程得同步则使用：synchronized 关键字。使用方法：1、同步代码块；2、<code>[线程]同步方法；</code></li></ul><p><div class="tip"><br>Java 四种代码块：<br>    普通代码块、构造块、静态块、<code>同步块</code></div></p><div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例代码实现得则是<code>“同步块”</code>，利用<code>synchronized</code>关键字使得会出现异常行代码被关键字锁住，每一次执行只可以进入一个对象，<code>实现同步</code>需要接受一个<code>this</code>参数表示当前线程对象<br> 所有（多个）线程，只有当里面得线程结束了，自己才可以进入同步块【一次只可以进入一个对象】<br>但是有人翻译同步代码块比较<code>“粗糙”</code>不美观,所以还有另外得<code>【同步方法】</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>上例代码则是放弃了<code>同步块</code>，使用<code>同步方法</code>实现“同步”同步方法得定义结构依旧是使用synchronized关键字在run()方法中，使用<code>this</code>方法调用同步方法。</p></li><li><p>异步操作得速度高于同步操作，而同步操作时得数据安全性高于异步操作时得数据安全性；】</p></li><li><p><code>死锁：</code>所谓的同步就是一个线程对象等待另外一个线程对象执行完毕后的操作形式；线程同步过多，就有可能造成死锁。也就是多个线程条件互斥进入等待造成死锁</p></li><li>死锁是程序开发中，由于某种逻辑上的错误所造成的问题；</li></ul><p>同步产生的问题：<br>多个线程访问同一空间资源是一定要处理好同步，可以使用同步代码块或同步方法解决；<br>但是过多的同步，有可能造成“死锁”</p><ul><li>最简单的同步或异步操作，就是通过 <code>synchronized</code> 关键字实现。</li><li><code>死锁是一种不定、不可预的状态</code></li></ul><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><p><code>java</code>中的<code>ThreadLocal</code>类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个<code>ThreadLocal</code>变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的<code>ThreadLocal</code>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; tick=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tick.get()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                tick.set(tick.get()-<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + tick.get());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ThreadLocal&lt;Integer&gt; tick=new ThreadLocal&lt;Integer&gt;</code> 创建ThreadLocal变量</li><li><code>initialValue</code> 设定初始值</li><li><code>get()</code>访问ThreadLocal变量</li><li><code>set()</code>设置对应值</li><li><code>ThreadLocal</code> 线程局部变量，每个线程单独维护一份自己的<code>ThreadLocal</code>变量相当于对每个线程都有一个独立的<code>ThreadLocal</code>副本</li></ul><h2 id="join-sleep-wait-区别"><a href="#join-sleep-wait-区别" class="headerlink" title="join ,sleep,wait,区别"></a>join ,sleep,wait,区别</h2><ul><li><code>sleep</code>是<code>Thread</code>类的静态方法一般写在<code>run</code>方法里面表示休眠当前线程于调用线程无关，会让出cpu资源，不会释放对象锁，会抛出异常</li><li><code>join</code>方法联合线程，当一个线程调用该方法后，会强制执行该线程（此时原来执行的线程处于阻塞状态），直到执行结束再执行原来的线程，这样把两个线程联合在了一一起。</li><li><code>wait</code> 方法会让出cpu释放对象锁，需要配和<code>synchronized</code>使用接收锁对象</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/wangyuyang1016/p/10952161.html" target="_blank" rel="noopener">Java 线程与多线程</a></li><li><a href="http://yayihouse.com/yayishuwu/chapter/1750" target="_blank" rel="noopener">java线程两种睡眠方法比较</a></li><li><a href="https://blog.csdn.net/p312011150/article/details/81741505" target="_blank" rel="noopener">Java多线程 -sleep 用法详解</a></li><li><a href="http://ifeve.com/java-threadlocal%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Java ThreadLocal的使用</a></li><li><a href="https://blog.csdn.net/qq_38293564/article/details/80459827" target="_blank" rel="noopener">Java并发编程之ThreadLocal详解</a></li><li><a href="https://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener">JAVA多线程之线程间的通信方式</a></li><li><a href="http://www.importnew.com/26850.html" target="_blank" rel="noopener">Java 里如何实现线程间通信</a></li></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://datou-y.github.io/tags/Thread/"/>
    
  </entry>
  
</feed>
