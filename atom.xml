<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://datou-y.github.io/"/>
  <updated>2019-06-11T14:20:49.425Z</updated>
  <id>https://datou-y.github.io/</id>
  
  <author>
    <name>daTou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析MySQL中exists与in的使用和区别</title>
    <link href="https://datou-y.github.io/posts/df7b0a0e.html/"/>
    <id>https://datou-y.github.io/posts/df7b0a0e.html/</id>
    <published>2019-06-11T12:46:01.117Z</published>
    <updated>2019-06-11T14:20:49.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是exists"><a href="#什么是exists" class="headerlink" title="什么是exists"></a>什么是exists</h2><p>exists表示存在，它常常和子查询配合使用，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">      <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> score sc <span class="keyword">where</span> sc.stu_id= st.stu_id);</span><br></pre></td></tr></table></figure><ul><li><code>exists</code>用于检查<code>子查询</code>是否至少会返回一行数据,如果返回空集<code>exists</code>返回值就是<code>false</code>，否则就是<code>true</code>,该子查询实际不返还任何数据。</li><li><code>exists</code>对外表用<code>loop</code>逐条查询，每次查询都会查看<code>exists</code>的条件语句</li><li>当子查询返回为真时，则外层查询语句将进行查询</li><li>当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。<a id="more"></a><h2 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h2></li><li>与<code>exists</code>条件相反，就是当<code>exists</code>结果集有反会值是时候条件为<code>false</code>否则为<code>true</code></li></ul><h2 id="in-查询"><a href="#in-查询" class="headerlink" title="in 查询"></a>in 查询</h2><ul><li><p>in查询相当于多个or条件的叠加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id=<span class="number">1</span> <span class="keyword">or</span> st.stu_id=<span class="number">2</span> <span class="keyword">or</span> st.stu_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>not in</code>与<code>in</code>相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id!=<span class="number">1</span> <span class="keyword">and</span> st.stu_id!=<span class="number">2</span> <span class="keyword">and</span> st.stu_id!=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="in-子查询"><a href="#in-子查询" class="headerlink" title="in 子查询"></a>in 子查询</h2><ul><li><code>in</code>查询的子条件返回结果必须只有一个字段</li><li><code>in()</code>语句只会执行一次，会将符合子查询条件的记录全都查出来，假设结果集为B，共有m条记录并且缓存起来，然后在将子查询条件的结果集分解成m个，再进行m次查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><ul><li>以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将<code>A</code>表的记录加入结果集中,直到遍历完A表的所有记录</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/ye411685846/article/details/61196162" target="_blank" rel="noopener">浅析MySQL中exists与in的使用</a></li><li><a href="https://blog.csdn.net/cool_wayen/article/details/79614806" target="_blank" rel="noopener">mysql中exit和in的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是exists&quot;&gt;&lt;a href=&quot;#什么是exists&quot; class=&quot;headerlink&quot; title=&quot;什么是exists&quot;&gt;&lt;/a&gt;什么是exists&lt;/h2&gt;&lt;p&gt;exists表示存在，它常常和子查询配合使用，&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student st &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; score sc &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; sc.stu_id= st.stu_id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;用于检查&lt;code&gt;子查询&lt;/code&gt;是否至少会返回一行数据,如果返回空集&lt;code&gt;exists&lt;/code&gt;返回值就是&lt;code&gt;false&lt;/code&gt;，否则就是&lt;code&gt;true&lt;/code&gt;,该子查询实际不返还任何数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;对外表用&lt;code&gt;loop&lt;/code&gt;逐条查询，每次查询都会查看&lt;code&gt;exists&lt;/code&gt;的条件语句&lt;/li&gt;
&lt;li&gt;当子查询返回为真时，则外层查询语句将进行查询&lt;/li&gt;
&lt;li&gt;当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="exists" scheme="https://datou-y.github.io/tags/exists/"/>
    
      <category term="in" scheme="https://datou-y.github.io/tags/in/"/>
    
  </entry>
  
  <entry>
    <title>mysql union 和union all使用</title>
    <link href="https://datou-y.github.io/posts/7bb7ade4.html/"/>
    <id>https://datou-y.github.io/posts/7bb7ade4.html/</id>
    <published>2019-06-11T11:58:04.162Z</published>
    <updated>2019-06-11T12:45:21.743Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库中，<code>UNION</code>和<code>UNION ALL</code>关键字都是将两个结果集合并为一个，<code>UNION</code>用的比较多<code>union all</code>是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 </p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>[SQL 语句 1]<br>    UNION<br>[SQL 语句 2]</p><p>[SQL 语句 1]<br>   UNION ALL<br>[SQL 语句 2]<br><a id="more"></a></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>对重复结果的处理：<code>UNION</code>在进行表链接后会筛选掉重复的记录，<code>Union All</code>不会去除重复<br>记录</li><li>对排序的处理：<code>Union</code>将会按照字段的顺序进行排序；<code>UNION ALL</code>只是简单的将两个结果合并后就返回</li><li>从效率上说，<code>UNION ALL</code> 要比<code>UNION</code>快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用<code>UNION ALL</code>。</li></ul><div class="tip"><br>如果您想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/youpai/p/9473231.html" target="_blank" rel="noopener">mysql中union与union all的区别</a></li><li><a href="https://www.cnblogs.com/hanyouchun/p/3688070.html" target="_blank" rel="noopener">MySQL中UNION和UNION ALL的使用</a></li><li><a href="https://www.liangzl.com/get-article-detail-37503.html" target="_blank" rel="noopener">mysql union 和union all使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据库中，&lt;code&gt;UNION&lt;/code&gt;和&lt;code&gt;UNION ALL&lt;/code&gt;关键字都是将两个结果集合并为一个，&lt;code&gt;UNION&lt;/code&gt;用的比较多&lt;code&gt;union all&lt;/code&gt;是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 &lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;[SQL 语句 1]&lt;br&gt;    UNION&lt;br&gt;[SQL 语句 2]&lt;/p&gt;
&lt;p&gt;[SQL 语句 1]&lt;br&gt;   UNION ALL&lt;br&gt;[SQL 语句 2]&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="union" scheme="https://datou-y.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>mysql中聚合函数日期函数使用详细和实例</title>
    <link href="https://datou-y.github.io/posts/74138ad2.html/"/>
    <id>https://datou-y.github.io/posts/74138ad2.html/</id>
    <published>2019-06-08T02:14:41.114Z</published>
    <updated>2019-06-11T12:11:10.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p><code>mysql</code> 数据库中 <code>count()</code> 函数是统计查询结果中的行数。列如下面的<code>empy</code>表</p><p><img src="https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://ae01.alicdn.com/kf/HTB1902abW5s3KVjSZFN763D3FXaO.png" alt></p><div class="tip"><br>注意的是，count 会忽略掉 NULL 的结果， 所以 count(字段名) 这样使用的话，如果字段中包含为null的结果，将导致查询结果不准确，列如：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1.sq4b25G3KVjSZPx762I3XXaT.png" alt></p><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p><code>mysql</code> 中 <code>sum()</code> 函数用于计算某一字段中所有行的数值之和（ <code>sum 求和时会对 null 进行过滤，不计算</code>）,如果对无法计算的列进行<code>sum()</code>sum 函数的返回值为 <code>0</code>,如果没有符合条件的行，<code>sum()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为0</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为32</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><p><code>mysql</code> 中 <code>max()</code> 函数用于计算某一字段中所有行的最大值,如果对无法比较的列进行<code>max()</code>max 函数的返回值为 <code>xxx</code>,如果没有符合条件的行，<code>max()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为xxx</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为4</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><p><code>mysql</code>中 <code>min()</code>函数用于计算某一字段中所有行的最小值</p><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><ul><li>返回指定字段的数据的平均值</li><li><code>avg()</code> 通过对表中行数计数并计算指定字段的数据总和，求得该字段的平均值。</li></ul><h2 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h2><ul><li>获得当前日期+时间（<code>date + time</code>）函数：<code>now()</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(), <span class="keyword">sleep</span>(<span class="number">3</span>), <span class="keyword">now</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="sysdate"><a href="#sysdate" class="headerlink" title="sysdate()"></a>sysdate()</h2><ul><li><code>sysdate()</code> 日期时间函数跟 <code>now()</code>类似，不同之处在于：<code>now()</code> 在执行开始时值就得到了<code>sysdate()</code>在函数执行时动态得到值</li><li><code>sysdate()</code> 日期时间函数，一般情况下很少用到。</li></ul><h2 id="current-timestamp"><a href="#current-timestamp" class="headerlink" title="current_timestamp()"></a>current_timestamp()</h2><ul><li>获得当前时间戳函数<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span>, <span class="keyword">current_timestamp</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="date-format-date-format"><a href="#date-format-date-format" class="headerlink" title="date_format(date,format)"></a>date_format(date,format)</h2><ul><li>日期/时间转换为字符串<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">date_format</span>(<span class="string">'2008-08-08 22:23:01'</span>, <span class="string">'%Y%m%d%H%i%s'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="str-to-date-str-format"><a href="#str-to-date-str-format" class="headerlink" title="str_to_date(str,format)"></a>str_to_date(str,format)</h2><ul><li>可以把一些杂乱无章的字符串转换为日期格式也可以转换为时间<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/2008'</span>, <span class="string">'%m/%d/%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/08'</span> , <span class="string">'%m/%d/%y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008'</span>, <span class="string">'%m.%d.%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08:09:30'</span>, <span class="string">'%h:%i:%s'</span>); <span class="comment">-- 08:09:30</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008 08:09:30'</span>, <span class="string">'%m.%d.%Y %h:%i:%s'</span>); <span class="comment">--</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/progor/p/8832663.html" target="_blank" rel="noopener">mysql之常用函数</a></li><li><a href="https://www.cnblogs.com/ggjucheng/p/3352280.html" target="_blank" rel="noopener"> MySQL 获得当前日期时间 函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;count&quot;&gt;&lt;a href=&quot;#count&quot; class=&quot;headerlink&quot; title=&quot;count&quot;&gt;&lt;/a&gt;count&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt; 数据库中 &lt;code&gt;count()&lt;/code&gt; 函数是统计查询结果中的行数。列如下面的&lt;code&gt;empy&lt;/code&gt;表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; empy;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="聚合函数" scheme="https://datou-y.github.io/tags/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>java中随机数使用</title>
    <link href="https://datou-y.github.io/posts/7b083b8f.html/"/>
    <id>https://datou-y.github.io/posts/7b083b8f.html/</id>
    <published>2019-06-07T09:32:12.122Z</published>
    <updated>2019-06-07T10:31:35.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数创建"><a href="#随机数创建" class="headerlink" title="随机数创建"></a>随机数创建</h2><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line">System.out.println(timeMillis);</span><br></pre></td></tr></table></figure><ul><li><code>long currentTimeMillis()</code> 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( timeMillis % <span class="number">1000</span> );</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要除以<code>100</code>获取<code>[0-1000]</code>就除以<code>1000</code>类推即可</li></ul><a id="more"></a><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><ul><li><code>double Math.random()</code>来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的<code>double</code>值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line"><span class="keyword">int</span> i=(<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要乘以<code>100</code>获取<code>[0-1000]</code>就乘以<code>1000</code>类推即可</li></ul><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//指定值构造方法</span></span><br><span class="line">Random rs=<span class="keyword">new</span> Random(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li><code>int r.nextInt(100)</code>获取[0, 100)之间的<code>int</code>整数Random支持的随机值类型包括：boolean, byte, int, long, float, double等</li></ul><h2 id="Random常用方法"><a href="#Random常用方法" class="headerlink" title="Random常用方法"></a>Random常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java 的随机数测试程序。共3种获取随机数的方法：</span></span><br><span class="line"><span class="comment"> *   (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。</span></span><br><span class="line"><span class="comment"> *   (02)、通过Math.random()返回一个0到1之间的double值。</span></span><br><span class="line"><span class="comment"> *   (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过System的currentTimeMillis()返回随机数</span></span><br><span class="line">        testSystemTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Math的random()返回随机数</span></span><br><span class="line">        testMathRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建“种子为1000”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 1st Random(1000)"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 2nd Random(1000)"</span>);</span><br><span class="line">        <span class="comment">// 新建“默认种子”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 1st Random()"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 2nd Random()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-01：测试System的currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSystemTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 通过l获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( l % <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- System.currentTimeMillis() ----\n l=%s i=%s\n"</span>, l, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-02：测试Math的random()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMathRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> d = Math.random();</span><br><span class="line">        <span class="comment">// 通过d获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- Math.random() ----\n d=%s i=%s\n"</span>, d, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-03：测试Random的API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAPIs</span><span class="params">(Random random, String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_LEN = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机的boolean值</span></span><br><span class="line">        <span class="keyword">boolean</span> b = random.nextBoolean();</span><br><span class="line">        <span class="comment">// 获取随机的数组buf[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_LEN];</span><br><span class="line">        random.nextBytes(buf);</span><br><span class="line">        <span class="comment">// 获取随机的Double值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">double</span> d = random.nextDouble();</span><br><span class="line">        <span class="comment">// 获取随机的float值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">float</span> f = random.nextFloat();</span><br><span class="line">        <span class="comment">// 获取随机的int值</span></span><br><span class="line">        <span class="keyword">int</span> i1 = random.nextInt();</span><br><span class="line">        <span class="comment">// 获取随机的[0,100)之间的int值</span></span><br><span class="line">        <span class="keyword">int</span> i2 = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 获取随机的高斯分布的double值</span></span><br><span class="line">        <span class="keyword">double</span> g = random.nextGaussian();</span><br><span class="line">        <span class="comment">// 获取随机的long值</span></span><br><span class="line">        <span class="keyword">long</span> l = random.nextLong();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- %s ----\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=["</span>,</span><br><span class="line">                title, b, d, f, i1, i2, g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> bt:buf) </span><br><span class="line">            System.out.printf(<span class="string">"%s, "</span>, bt);</span><br><span class="line">        System.out.println(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/skywang12345/p/3341423.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3341423.html</a></li><li><a href="https://www.cnblogs.com/blogxjc/p/9687297.html" target="_blank" rel="noopener">java的三种随机数生成方式</a></li><li><a href="https://www.cnblogs.com/dyx2018/p/9189700.html" target="_blank" rel="noopener">Java 生成随机数</a></li><li><a href="https://www.cnblogs.com/cx-code/p/10005915.html" target="_blank" rel="noopener">java随机生成6位随机数 5位随机数 4位随机数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随机数创建&quot;&gt;&lt;a href=&quot;#随机数创建&quot; class=&quot;headerlink&quot; title=&quot;随机数创建&quot;&gt;&lt;/a&gt;随机数创建&lt;/h2&gt;&lt;h3 id=&quot;currentTimeMillis&quot;&gt;&lt;a href=&quot;#currentTimeMillis&quot; class=&quot;headerlink&quot; title=&quot;currentTimeMillis()&quot;&gt;&lt;/a&gt;currentTimeMillis()&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(timeMillis);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;long currentTimeMillis()&lt;/code&gt; 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)( timeMillis % &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;若要获取&lt;code&gt;int&lt;/code&gt;类型的整数，只需要将上面的结果转成&lt;code&gt;int&lt;/code&gt;类型即可。比如，&lt;code&gt;获取[0, 100)&lt;/code&gt;之间的&lt;code&gt;int&lt;/code&gt;整数要除以&lt;code&gt;100&lt;/code&gt;获取&lt;code&gt;[0-1000]&lt;/code&gt;就除以&lt;code&gt;1000&lt;/code&gt;类推即可&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="random" scheme="https://datou-y.github.io/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>java中进程和线程</title>
    <link href="https://datou-y.github.io/posts/c206fba0.html/"/>
    <id>https://datou-y.github.io/posts/c206fba0.html/</id>
    <published>2019-06-06T13:53:01.653Z</published>
    <updated>2019-06-07T11:47:19.386Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg" alt><br><a id="more"></a></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><blockquote><p><code>run()</code>方法是执行的线程体，<code>start()</code>用于启动线程</p></blockquote><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><ul><li>继承<code>Thread</code>类的类就是一个线程类，通过创建当前类的实例，来创建多个线程</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span>   <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><ul><li>由于<code>Runnable</code>接口没有定义<code>start</code>方法，而一定的规定要求，必须通过<code>Thread.start</code><br>方法来启动继承；</li><li><code>Thread</code>类中有 <code>【Thread（Runnable target）】</code>构造方法，可以接收<code>Runnable接口</code><br>的参数</li><li>于是我们可以实例化<code>Threda</code>类，将<code>Runnable</code>对象交给<code>Thread</code>类处理并调用其<code>start()</code>方法启动多线程</li></ul><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul><li><code>Runnable</code>接口实现的多线程不能返回操作结果；所以提供了一个新的多线程接口——<code>Callable接口【java.util.concurrent 包】</code></li><li><code>call()</code>方法在 执行主要功能后，可以返回结果，而返回结果的类型有<code>Calable</code>接口泛型来决定。</li><li><code>Callable接口</code>的<code>call()</code>是线程执行体，代替原来<code>run()</code>方法可以有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* Thread类中并没有接收Callabel对象的构造方法，所以无法通过start()来启动多线程</span></span><br><span class="line"><span class="comment">* 但是Java提供java.util.concurrent。FutureTask&lt;V&gt; 类 ， </span></span><br><span class="line"><span class="comment">* 在FutureTask类的定义结构如下：</span></span><br><span class="line"><span class="comment">* public class FutureTask&lt;V&gt; extends Object implements Future&lt;V&gt; , Runnable</span></span><br><span class="line"><span class="comment">* 类中有如下的构造方法：</span></span><br><span class="line"><span class="comment">* public FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line"><span class="comment">* FutureTask类接收Callable接口对象。目的就是：取得call()方法的返回结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OKOK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread); <span class="comment">// 目的是为了接收call返回值</span></span><br><span class="line">FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread1);</span><br><span class="line"><span class="comment">// FutureTask是Runnable接口子类，所以可以使用Thread类的构造来接收task对象</span></span><br><span class="line"><span class="keyword">new</span> Thread(task1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line"><span class="comment">// 多线程执行完毕后，依靠FutureTask的父接口 Future中的get()方法完成。</span></span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task.get());</span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task1.get());</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="tip"><br>使用Runnable接口与Thread类相比之下，解决了Thrad类单继承局限的问题<br></div><ul><li>数据共享的不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><p>两个程序例子，都是实现三个线程的启动；不同的地方在于，<code>Thread</code>的三个线程使用的是三个不同的实例对象如<code>代码块一</code>，而<code>Runnable</code>的三个线程均是通过<code>实例化Thread</code>类调用<code>Start()</code>方法对<code>同一实例对象</code>进行三个线程的操作如<code>代码块二</code>。<code>Runnable</code>更好的实现了同一数据共享（当然Thread也可以，只是没有Runnable简单）</p><p>  两者的区别</p><p>　　Thread类是Runnable接口的一个子类，使用Runnable接口实现多线程可以避免单继承的局限性</p><p>　　Runnable接口实现的多线程可以比Thrad类实现的多线程更加清楚的描述</p><h2 id="多线程的常用操作方法"><a href="#多线程的常用操作方法" class="headerlink" title="多线程的常用操作方法"></a>多线程的常用操作方法</h2><h3 id="线程的命名与获得"><a href="#线程的命名与获得" class="headerlink" title="线程的命名与获得"></a>线程的命名与获得</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName()</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = C"</span>).start();</span><br><span class="line">thread.setName(<span class="string">"线程A"</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Thread.currentThread().getName()</code> 获取当前线程的名称，如果自己没有设置名称默认的名称为<code>Thread-0</code>,<code>Thread-1</code>依次类推</li><li><code>new Thread(thread,&quot;线程A&quot;).start()</code> 设置线程名称适用于实现接口方式的线程创建</li><li><code>thread.setName(&quot;线程A&quot;)</code> 设置线程的名称，适用于继承Thread类的线程创建</li></ul><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sleep(long millis)</code>  线程睡眠 <code>millis</code> 毫秒</li><li><code>sleep(long millis, int nanos)</code>  线程睡眠 <code>millis</code> 毫秒 + <code>nanos</code> 纳秒</li><li>因为<code>sleep()</code>是静态方法，所以最好的调用方法就是 <code>Thread.sleep()</code></li><li>线程的<code>sleep</code>方法应该写在线程的run()方法里，就能让对应的线程睡眠,<code>sleep</code>调用无关调用的线程对象，在那里调用那个线程就睡眠</li><li><code>sleep()</code>方法导致了程序暂停执行指定的时间，让出<code>cpu</code>给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>在调用<code>sleep()</code>方法的过程中，线程不会释放对象锁资源</li></ul><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>优先级越高，越有可能先执行；Thread类中设置了两个方法：</p><blockquote><p>改变线程优先级：    public final void setPriority(int newPriority) ;<br>返回线程优先级：    public final void getPriority() ;</p></blockquote><p><div class="tip"><br>java中线程优先级效果不是特别明显所以不使用一般</div></p><div><h2 id="线程的同步与死锁"><a href="#线程的同步与死锁" class="headerlink" title="线程的同步与死锁"></a>线程的同步与死锁</h2><p>同步指的是<code>多个线程访问同一资源</code>时的问题；即多个线程对象操作同一个对象资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1OPJgb21G3KVjSZFk761K4XXaL.png" alt><br>此时，上例没有出现任何问题！<br>但在代码<code>run()</code>的for中加入延迟<code>【Thread.sleep();】</code>就会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://ae01.alicdn.com/kf/HTB1h1JpbYus3KVjSZKb760qkFXa8.png" alt></p><ul><li>可以明显的发现，结果中出现了相同值（意外值）；这就是“不同步”的状况【异步操作】。<br>上例代码的想法是：从同一个资源取得当前的剩余的点数，但是由于<code>延迟</code>的存在，后续的线程不会等待之前的线程，会直接的进入，导致剩余值没有得到及时的刷新,而出现问题</li></ul><blockquote><p>同步的操作<br>所谓同步就是指<code>多个线程操作同一时间只能有一个线程进入同一个空间运行</code>，其他线程要等待此线程完成之后才可以继续执行。而之前的不同步【或称为异步操作】，则是多个线程可以同一时间进入同一个空间运行。</p></blockquote><ul><li><code>java</code>中实现线程得同步则使用：synchronized 关键字。使用方法：1、同步代码块；2、<code>[线程]同步方法；</code></li></ul><p><div class="tip"><br>Java 四种代码块：<br>    普通代码块、构造块、静态块、<code>同步块</code></div></p><div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例代码实现得则是<code>“同步块”</code>，利用<code>synchronized</code>关键字使得会出现异常行代码被关键字锁住，每一次执行只可以进入一个对象，<code>实现同步</code>需要接受一个<code>this</code>参数表示当前线程对象<br> 所有（多个）线程，只有当里面得线程结束了，自己才可以进入同步块【一次只可以进入一个对象】<br>但是有人翻译同步代码块比较<code>“粗糙”</code>不美观,所以还有另外得<code>【同步方法】</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>上例代码则是放弃了<code>同步块</code>，使用<code>同步方法</code>实现“同步”同步方法得定义结构依旧是使用synchronized关键字在run()方法中，使用<code>this</code>方法调用同步方法。</p></li><li><p>异步操作得速度高于同步操作，而同步操作时得数据安全性高于异步操作时得数据安全性；】</p></li><li><p><code>死锁：</code>所谓的同步就是一个线程对象等待另外一个线程对象执行完毕后的操作形式；线程同步过多，就有可能造成死锁。也就是多个线程条件互斥进入等待造成死锁</p></li><li>死锁是程序开发中，由于某种逻辑上的错误所造成的问题；</li></ul><p>同步产生的问题：<br>多个线程访问同一空间资源是一定要处理好同步，可以使用同步代码块或同步方法解决；<br>但是过多的同步，有可能造成“死锁”</p><ul><li>最简单的同步或异步操作，就是通过 <code>synchronized</code> 关键字实现。</li><li><code>死锁是一种不定、不可预的状态</code></li></ul><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><p><code>java</code>中的<code>ThreadLocal</code>类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个<code>ThreadLocal</code>变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的<code>ThreadLocal</code>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; tick=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tick.get()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                tick.set(tick.get()-<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + tick.get());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ThreadLocal&lt;Integer&gt; tick=new ThreadLocal&lt;Integer&gt;</code> 创建ThreadLocal变量</li><li><code>initialValue</code> 设定初始值</li><li><code>get()</code>访问ThreadLocal变量</li><li><code>set()</code>设置对应值</li><li><code>ThreadLocal</code> 线程局部变量，每个线程单独维护一份自己的<code>ThreadLocal</code>变量相当于对每个线程都有一个独立的<code>ThreadLocal</code>副本</li></ul><h2 id="join-sleep-wait-区别"><a href="#join-sleep-wait-区别" class="headerlink" title="join ,sleep,wait,区别"></a>join ,sleep,wait,区别</h2><ul><li><code>sleep</code>是<code>Thread</code>类的静态方法一般写在<code>run</code>方法里面表示休眠当前线程于调用线程无关，会让出cpu资源，不会释放对象锁，会抛出异常</li><li><code>join</code>方法联合线程，当一个线程调用该方法后，会强制执行该线程（此时原来执行的线程处于阻塞状态），直到执行结束再执行原来的线程，这样把两个线程联合在了一一起。</li><li><code>wait</code> 方法会让出cpu释放对象锁，需要配和<code>synchronized</code>使用接收锁对象</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/wangyuyang1016/p/10952161.html" target="_blank" rel="noopener">Java 线程与多线程</a></li><li><a href="http://yayihouse.com/yayishuwu/chapter/1750" target="_blank" rel="noopener">java线程两种睡眠方法比较</a></li><li><a href="https://blog.csdn.net/p312011150/article/details/81741505" target="_blank" rel="noopener">Java多线程 -sleep 用法详解</a></li><li><a href="http://ifeve.com/java-threadlocal%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Java ThreadLocal的使用</a></li><li><a href="https://blog.csdn.net/qq_38293564/article/details/80459827" target="_blank" rel="noopener">Java并发编程之ThreadLocal详解</a></li><li><a href="https://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener">JAVA多线程之线程间的通信方式</a></li><li><a href="http://www.importnew.com/26850.html" target="_blank" rel="noopener">Java 里如何实现线程间通信</a></li></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://datou-y.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>java中StringBuffer和StringBuilder和String</title>
    <link href="https://datou-y.github.io/posts/2a5743c8.html/"/>
    <id>https://datou-y.github.io/posts/2a5743c8.html/</id>
    <published>2019-06-06T09:59:13.017Z</published>
    <updated>2019-06-06T13:28:32.004Z</updated>
    
    <content type="html"><![CDATA[<p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h2 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"I AM DOG"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(a);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"I AM DOG"</span>);</span><br><span class="line">System.out.println(a + b + c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>&#125;;</span><br><span class="line">String str1 = <span class="keyword">new</span> String(c1);</span><br><span class="line">System.out.println(str1);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.length()</span><br></pre></td></tr></table></figure><ul><li><code>length()</code>是方法区别与数组的<code>length</code>属性还有集合的<code>size()</code>方法</li><li>字符串的长度是指其所包含的字符的个数,一个字符算一个长度，一个空格算一个长度</li></ul><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"I am"</span>;</span><br><span class="line">String b = <span class="string">" Tom"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">14</span>;</span><br><span class="line">System.out.println(a + b + <span class="string">" "</span> + <span class="string">"我的年龄是"</span> + age);</span><br><span class="line"></span><br><span class="line">String result = <span class="string">"The result 2 + 2 is "</span> + <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">System.out.println(result);</span><br><span class="line">String a=<span class="string">"fafafa"</span>;</span><br><span class="line">String c=result.concat(a);</span><br></pre></td></tr></table></figure><ul><li><code>&quot; + &quot;</code>可以连接两个字符串，产生一个新<code>String</code>对象，也可以使用一连串的字符串<code>+</code>进行运算</li><li>字符串在使用<code>+</code>号进行连接的时候，会默认把int类型自动的转换为String类型再进行连接，这种转换思想具有普适性，其他数据类型也是如此</li><li><p>正如上面所说的，<code>String</code>类型和任何类型的相加都会变为<code>String</code>类型的结果，上面程序的运行过程会先执行<code>&quot;The result 2 + 2 is&quot;</code> 加2，得到的结果再加2 ，就会变成<code>The result 2 + 2 is 22</code></p></li><li><p><code>concat()</code>方法用于字符串连接效果和<code>+</code>是一样的</p></li></ul><h3 id="获取某个位置字符"><a href="#获取某个位置字符" class="headerlink" title="获取某个位置字符"></a>获取某个位置字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.charAt(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><ul><li><code>charAt()</code>获取字符串某个位置上的字符</li></ul><h3 id="获取字符的位置"><a href="#获取字符的位置" class="headerlink" title="获取字符的位置"></a>获取字符的位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.indexOf(<span class="string">"2"</span>));</span><br><span class="line">System.out.println(result.lastIndexOf(<span class="string">"2"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>indexOf()</code>获取字符对应位置的索引位置</li><li><code>lastIndexOf()</code>获取字符对应位置的最后索引位置</li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line"><span class="keyword">if</span>(result.contains(<span class="string">"he result"</span>))&#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">result.isEmpty()</span><br><span class="line">System.out.println(result.startsWith(<span class="string">"r"</span>));</span><br><span class="line">System.out.println(result.endsWith(<span class="string">" "</span>));</span><br><span class="line">System.out.println(result.equals(<span class="string">"t"</span>));</span><br><span class="line">System.out.println(result.equalsIgnoreCase(<span class="string">"T"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>boolean contains()</code>判断字符串中是否包含某一个子串</li><li><code>boolean isEmpty()</code>原理就是判断长度是否为0</li><li><code>boolean startsWith()</code>字符串是否以指定内容开头</li><li><code>boolean endsWith()</code> 字符串是否以指定内容结尾</li><li><code>boolean equals(str)</code>判断字符内容是否相同</li><li><code>boolean.equalsIgnorecase()</code>判断内容是否相同，并忽略大小写。</li></ul><h3 id="去掉字符串空格"><a href="#去掉字符串空格" class="headerlink" title="去掉字符串空格"></a>去掉字符串空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;   </span><br><span class="line">System.out.println(result.trim());</span><br></pre></td></tr></table></figure><ul><li><code>String trim()</code>将字符串两端的多个空格去除</li></ul><h3 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.toUpperCase());</span><br><span class="line">System.out.println(result.toLowerCase());</span><br></pre></td></tr></table></figure><ul><li><code>String toUpperCsae()</code> 大转小 </li><li><code>String toLowerCsae()</code> 小转大</li></ul><h3 id="截取替换"><a href="#截取替换" class="headerlink" title="截取替换"></a>截取替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.substring(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">System.out.println(result.replace(<span class="string">"r"</span>,<span class="string">"h"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>String subString()</code>获取字符串中子串</li><li><code>String replace()</code> 将字符串指定字符替换。</li></ul><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"222"</span>;</span><br><span class="line"><span class="keyword">int</span> c = Integer.valueOf(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">String b = String.valueOf(a);</span><br><span class="line"></span><br><span class="line">String d = <span class="string">"True"</span>;</span><br><span class="line">Boolean e = Boolean.valueOf(d);</span><br><span class="line"></span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure><ul><li><code>valueOf()</code> 字符串转换，转换什么类型就调用什么类型的<code>valueOf()</code>方法</li></ul><h2 id="StringBuffer常用操作"><a href="#StringBuffer常用操作" class="headerlink" title="StringBuffer常用操作"></a>StringBuffer常用操作</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">StringBuffer ssb=<span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure><ul><li>要初始化内容可以直接在<code>创建</code>时候初始化</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.append(<span class="string">"true"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>append()</code>追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后<code>StringBuffer</code>对象的内容也发生改变</li><li>使用该方法进行字符串的连接，将比<code>String</code>更加节约内容应用于数据库<code>SQL</code>语句的连接</li></ul><h3 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>reverse()</code>作用是将StringBuffer对象中的内容反转，然后形成新的字符串</li></ul><h3 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">"true"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li>作用是在<code>StringBuffer</code>对象中插入内容索引不包含最后一个，然后形成新的字符串</li></ul><h3 id="deleteCharAt方法"><a href="#deleteCharAt方法" class="headerlink" title="deleteCharAt方法"></a>deleteCharAt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.delete(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">sb.deleteCharAt(<span class="number">1</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li>作用是删除指定位置的字符，然后将剩余的内容形成新的字符串</li></ul><h3 id="setCharAt方法"><a href="#setCharAt方法" class="headerlink" title="setCharAt方法"></a>setCharAt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">'A'</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>setCharAt(int index, char ch)</code>作用是修改对象中索引值为index位置的字符为新的字符ch</li></ul><h2 id="St1ringBuilder和String类型转换"><a href="#St1ringBuilder和String类型转换" class="headerlink" title="St1ringBuilder和String类型转换"></a>St1ringBuilder和String类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>toString()</code>方法进行转换为<code>String</code></li><li>需要注意的是，<code>StringBuffer</code>和<code>String</code>属于不同的类型，也不能直接进行强制类型转换</li></ul><h2 id="String，StringBuilder，StringBuffer三者的区别"><a href="#String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="String，StringBuilder，StringBuffer三者的区别"></a>String，StringBuilder，StringBuffer三者的区别</h2><div class="tip"><br>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。<br></div><ul><li>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：<code>StringBuilder &gt; StringBuffer &gt; String</code></li><li><code>String最慢的原因</code>String为字符串<code>常量</code>，而StringBuilder和StringBuffer均为字符串<code>变量</code>即<code>String对象</code>一旦创建之后该对象是<code>不可更改</code>的，但后两者的对象是变量，是<code>可以更改的</code></li><li>Java中对<code>String</code>对象进行的操作实际上是一个不断<code>创建新的对象</code>并且将旧的对象回收的一个过程，所以执行速度<code>很慢</code></li><li><code>StringBuilder和StringBuffer的对象是变量</code>，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比<code>String</code>快很多</li></ul><blockquote><p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</p></blockquote><ul><li><code>String：</code>适用于少量的字符串操作的情况</li><li><code>StringBuilder：</code>适用于单线程下在字符缓冲区进行大量操作的情况</li><li><code>StringBuffer：</code>适用多线程下在字符缓冲区进行大量操作的情况</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="java中String-s-new-String-“abc”-创建了几个对象"><a href="#java中String-s-new-String-“abc”-创建了几个对象" class="headerlink" title="java中String s = new String(“abc”)创建了几个对象"></a>java中String s = new String(“abc”)创建了几个对象</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/hey-man/p/6833242.html" target="_blank" rel="noopener">Java中String的用法</a></li><li><a href="https://www.cnblogs.com/cxuanBlog/p/10927557.html" target="_blank" rel="noopener">String 字符串基本使用</a></li><li><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">Java中的String，StringBuilder，StringBuffer三者的区别</a></li><li><a href="https://www.cnblogs.com/liu-chao-feng/p/5636063.html" target="_blank" rel="noopener">StringBuffer的用法</a></li><li><a href="https://www.jb51.net/article/128551.htm" target="_blank" rel="noopener">java之StringBuffer常见使用方法解析</a></li><li><a href="https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html" target="_blank" rel="noopener">String s=new String(“abc”)创建了几个对象?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。&lt;br&gt;和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。&lt;br&gt;StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。&lt;br&gt;由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。&lt;/p&gt;
&lt;h2 id=&quot;字符串的创建&quot;&gt;&lt;a href=&quot;#字符串的创建&quot; class=&quot;headerlink&quot; title=&quot;字符串的创建&quot;&gt;&lt;/a&gt;字符串的创建&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String a = &lt;span class=&quot;string&quot;&gt;&quot;I AM DOG&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String c = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;I AM DOG&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a + b + c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c1[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;4&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;5&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String str1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(c1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(str1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="字符串" scheme="https://datou-y.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>java中数组用法和实例详解</title>
    <link href="https://datou-y.github.io/posts/4d11ca6.html/"/>
    <id>https://datou-y.github.io/posts/4d11ca6.html/</id>
    <published>2019-06-06T08:25:00.935Z</published>
    <updated>2019-06-06T10:21:36.315Z</updated>
    
    <content type="html"><![CDATA[<p>数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] a=&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">String[] names = <span class="keyword">new</span> String[] &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型</li><li>创建并分配空间在 Java中可以使用<code>new</code>关键字来给数组分配空间<a id="more"></a></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>]=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(b[<span class="number">0</span>]);</span><br><span class="line">System.out.println(b.length);</span><br></pre></td></tr></table></figure><ul><li><code>length</code>属性获取数组长度</li><li><code>b[0]</code> 直接通过下标获取数组对应位置元素</li></ul><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">Arrays.sort(b);</span><br><span class="line">Arrays.sort(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer s : b) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Arrays.sort()</code>方法进行数组排序，字符串就按26个字符位置排序，数组就按大小排序</li></ul><h2 id="数组转换集合"><a href="#数组转换集合" class="headerlink" title="数组转换集合"></a>数组转换集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="keyword">for</span> (String s : ls) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a); </span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行反转</span></span><br><span class="line">Collections.reverse(ls);</span><br><span class="line"><span class="keyword">for</span>(String s:ls)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组获取最大值和最小值"><a href="#数组获取最大值和最小值" class="headerlink" title="数组获取最大值和最小值"></a>数组获取最大值和最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行比较</span></span><br><span class="line">System.out.println(Collections.max(ls));</span><br><span class="line">System.out.println(Collections.min(ls));</span><br></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b = &#123;<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>&#125;;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(a));</span><br><span class="line"><span class="comment">//在调用集合的合并方法</span></span><br><span class="line"></span><br><span class="line">ls.addAll(Arrays.asList(b));</span><br><span class="line">Object[] o = ls.toArray();</span><br><span class="line">System.out.println(Arrays.toString(o));</span><br><span class="line"><span class="keyword">for</span> (Object s : o) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip"><br>注意这里遇到一个坑<br></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s=Arrays.asList(a);</span><br><span class="line">s.add(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure><ul><li>这样接收的<code>List</code>集合和我们<code>new</code>创建的有区别所以<code>add</code>等方法是又区别的</li><li>参考<a href="https://www.2cto.com/kf/201806/751606.html" target="_blank" rel="noopener">ArrayList报错：UnsupportedOperationException的解决办法</a></li></ul><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/bahcelor/p/6593514.html" target="_blank" rel="noopener">Java关于数组操作函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String[] a=&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String[] b=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String[] names = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型&lt;/li&gt;
&lt;li&gt;创建并分配空间在 Java中可以使用&lt;code&gt;new&lt;/code&gt;关键字来给数组分配空间
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Array" scheme="https://datou-y.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList、LinkedList、Vector的区别和实现原理</title>
    <link href="https://datou-y.github.io/posts/57b1f1b.html/"/>
    <id>https://datou-y.github.io/posts/57b1f1b.html/</id>
    <published>2019-06-06T07:37:14.550Z</published>
    <updated>2019-06-06T08:14:20.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="https://ae01.alicdn.com/kf/HTB1yVDlbUGF3KVjSZFvq6z_nXXaR.jpg" alt><br><a id="more"></a></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>查询，和随机访问效率快，修改比较慢</li><li>数据结构基于<code>数组</code>实现按照顺序将元素存储（从下表为0开始），删除元素时，删除操作完成后，需要使部分元素移位，默认的初始容量为10</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部</li><li>查询慢，修改比较慢</li><li><code>LinkedList</code>是基于双向链表实现的（含有头结点）</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li><code>Vector</code>属于线程安全级别的大部分的方法都包含关键字<code>synchronized</code></li><li><code>Vector</code>的效率没有ArraykList和LinkedList高</li><li>基于数组实现的</li><li><code>Vector</code>提供<code>indexOf(obj, start)</code>接口，<code>ArrayList</code>没有。</li></ul><h2 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h2><blockquote><p>ArrayList不具有有线程安全性，在单线程的环境中，LinkedList也是线程不安全的，如果在并发环境下使用它们，可以用Collections类中的静态方法synchronizedList(）对ArrayList和LinkedList进行调用即可。<br>Vector实现线程安全的，即它大部分的方法都包含关键字synchronized,但是Vector的效率没有ArraykList和LinkedList高</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/kuangsonghan/article/details/79861170" target="_blank" rel="noopener">ArrayList、LinkedList、Vector的区别和实现原理</a></li><li><a href="https://blog.csdn.net/u012814441/article/details/80671604" target="_blank" rel="noopener">源码浅析ArrayList、LinkedList和Vector的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承关系&quot;&gt;&lt;a href=&quot;#继承关系&quot; class=&quot;headerlink&quot; title=&quot;继承关系&quot;&gt;&lt;/a&gt;继承关系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1yVDlbUGF3KVjSZFvq6z_nXXaR.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="List" scheme="https://datou-y.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和Hashtable的区别和实现原理</title>
    <link href="https://datou-y.github.io/posts/425444d1.html/"/>
    <id>https://datou-y.github.io/posts/425444d1.html/</id>
    <published>2019-06-06T06:00:25.209Z</published>
    <updated>2019-06-06T08:20:55.268Z</updated>
    
    <content type="html"><![CDATA[<p>Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分<br>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。<br><a id="more"></a></p><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul><li><code>HashMap</code>和<code>Hashtable</code>都实现了<code>Map</code>接口</li><li><code>HashMap</code>是线程不安全的不允许键值重复,允许空键和空值;由于非线程安全,<code>HashMap</code> 的效率要较 <code>HashTable</code> 的效率高一些.</li><li><code>HashTable</code> 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值</li><li><code>HashTable</code> 是 <code>synchronized</code> 同步的,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步</li><li><code>HashMap</code>的迭代器(<code>Iterator</code>)是<code>fail-fast</code>迭代器，而<code>Hashtable</code>的<code>enumerator</code>迭代器不是<code>fail-fast</code>的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出<code>ConcurrentModificationException</code>，但迭代器本身的<code>remove()</code>方法移除元素则不会抛出<code>ConcurrentModificationException</code>异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>底层数据结构基于数组+链表实现</li></ul><h2 id="HashMap同步"><a href="#HashMap同步" class="headerlink" title="HashMap同步"></a>HashMap同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m=Collections.synchronizedMap(map)</span><br></pre></td></tr></table></figure><ul><li><code>Collections</code>类不是集合，这个类里面提供了<code>synchronizedMap</code>方法</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/itcx1213/p/10963751.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></li><li><a href="https://www.cnblogs.com/lchzls/p/6714335.html" target="_blank" rel="noopener">JAVA中HashMap和Hashtable区别</a></li><li><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">HashMap和Hashtable原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分&lt;br&gt;HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Map" scheme="https://datou-y.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>java中map字典用法和详细实例</title>
    <link href="https://datou-y.github.io/posts/f2f0bf25.html/"/>
    <id>https://datou-y.github.io/posts/f2f0bf25.html/</id>
    <published>2019-06-05T10:52:00.847Z</published>
    <updated>2019-06-06T07:42:48.288Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap字典用于存放键值对，<code>&lt;key,value&gt;</code>，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！<br><img src="https://ae01.alicdn.com/kf/HTB1cDhBbUGF3KVjSZFo762mpFXaS.png" alt><br><a id="more"></a></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://ae01.alicdn.com/kf/HTB1TzFBbMmH3KVjSZKz7622OXXas.png" alt></p><h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = Hashtable&lt;String, Integer&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>HashMap</code>底层是哈希表数据结构，线程是不同步的也就是线程不安全的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法</li><li><p><code>TreeMap</code>TreeMap可以对集合中的键进行排序</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>put()</code>方法在没有hashCode和equals方式   添加重复的键值（值不同）,会覆盖掉前面key值相同的值</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="string">"tom"</span>);</span><br><span class="line">map.clear();  </span><br><span class="line">map.remove(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code>方法清空集合对象  </li><li><code>remove()</code>方法指定key，返回删除的键值对映射的值如果key不存在删除失败，返回null<br>如果同时指定了key，和value删除成功返回true，否则返回false</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size()</span><br><span class="line">map.get(<span class="string">"toms"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>方法获取容器大小,从1开始计算，集合索引从0开始计算</li><li><code>get()</code>方法指定key，获取对应键值，如果key不存在返回null</li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map.isEmpty()</span><br><span class="line">map.containsKey(<span class="string">"toms"</span>)</span><br><span class="line">map.containsValue(<span class="number">11</span>)</span><br><span class="line">Set&lt;String&gt; key = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String s:key)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; S=map.values();</span><br><span class="line"><span class="keyword">for</span>(Integer s:S)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; es=map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry e:es)&#123;</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>boolean isEmpty()</code>方法判断集合是否为空   长度为0返回true否则false </li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的key </li><li><code>boolean containsValue(Object value)</code>判断集合中是否包含指定的value</li><li><code>Set keySet()</code>方法获取所有的key返回一个<code>Set</code>集合</li><li><code>Collection values()</code>方法获取所有的值返回一个<code>Collection</code>集合</li><li><code>entrySet()</code> 方法获取map所有实体<code>Set</code>集合包含键和值</li></ul><h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure><p>通过<code>keySet()</code> 获取key  通过key 找到value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Map.Entry(String,Integer)</code> 获取，然后使用<code>entry.getKey()</code>获取到键，通过<code>entry.getValue()</code>获取到值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry e:map.entrySet())&#123;</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只遍历键或者值，通过增强for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer a:map.values())&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Iterator</code>迭代器来遍历通过<code>getKey</code>获取所有键<code>getValue</code>获取所有值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it= map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; next=it.next();</span><br><span class="line">    String key=next.getKey();</span><br><span class="line">    Integer v=next.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key"</span>+key+<span class="string">"value"</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map合并"><a href="#Map合并" class="headerlink" title="Map合并"></a>Map合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map1.put(<span class="string">"t"</span>, <span class="number">21</span>);</span><br><span class="line">map1.put(<span class="string">"g"</span>, <span class="number">2</span>);</span><br><span class="line">map.putAll(map1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>putAll()</code>方法可以接收另一个<code>Map</code>让两个集合合并为一个<br><div class="tip"><br><code>Set</code>的元素不可重复，<code>Map</code>的键不可重复<br><code>Set</code>元素重复元素不能存入add方法返回<code>false</code><br><code>Map</code>的重复健将覆盖旧键，将旧值返回。</div></li></ul><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><p>增加<code>for</code>循环进行遍历新增,删除操作会触发<code>fail-fast</code>机制，修改也就是覆盖不会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    map.put(<span class="string">"jack"</span>,<span class="number">222</span>);</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        map.remove(<span class="string">"jack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用迭代器迭<code>Iterator</code>迭代时候迭代器删除不会触发<code>fail-fast</code>机制只有新增会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; s=it.next();</span><br><span class="line">    String key=s.getKey();</span><br><span class="line">    Integer value=s.getValue();</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"tom"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882#12-set" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/douyu2580860/p/8358768.html" target="_blank" rel="noopener">java基础集合简介Map（三）下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap字典用于存放键值对，&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1cDhBbUGF3KVjSZFo762mpFXaS.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Map" scheme="https://datou-y.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>java中List集合用法和实例详解</title>
    <link href="https://datou-y.github.io/posts/50eb6371.html/"/>
    <id>https://datou-y.github.io/posts/50eb6371.html/</id>
    <published>2019-06-04T13:33:38.510Z</published>
    <updated>2019-06-06T07:42:33.669Z</updated>
    
    <content type="html"><![CDATA[<p>集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作</p><div class="tip"><br>下面是java中集合框架主要结构图<br></div><p><img src="https://ae01.alicdn.com/kf/HTB1aUHPbBiE3KVjSZFM762QhVXaJ.png" alt><br><a id="more"></a></p><h1 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li><code>List</code>继承自<code>Collection</code>接口，是有序集合,即先放入的元素排在前面允许相同元素和<code>null</code>,实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li><li><code>ArrayList</code>非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多</li><li><code>LinkedList</code> 非同步，允许相同元素和null，遍历效率低插入和删除效率高</li><li><code>Vector</code> 同步，允许相同元素和null，效率低</li></ul><h1 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h1><div class="tip"><br>集合的索引，也就是下标是从0开始，长度是从1开始<br></div><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls.add(<span class="string">"a"</span>); </span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="number">2</span>,<span class="string">"c"</span>);</span><br><span class="line">ls.set(<span class="number">0</span>,<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>add()</code>方法添加元素到集合中，也可以指定添加元素到集合指定位置，如果当前位置已经有了其他元素，后面的元素就依次往后移动，如果添加的位置索引不存在就会抛异常</p></li><li><p><code>set()</code>方法替换掉原来位置的元素，如果索引不存在抛异常</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.remove(<span class="string">"a"</span>);</span><br><span class="line">ls.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><code>remove()</code>方法删除元素，可以根据元素删除如果当前元素不存在，或者已经删除就返回false，如果存在删除成功返回true。</li><li>也可以根据索引，也就是下标来删除，如果下标不存在就抛异常，返回删除后的元素信息</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>get()</code>方法获取元素，根据下标获取元素，如果下标不存在抛异常</li></ul><h3 id="清空元素"><a href="#清空元素" class="headerlink" title="清空元素"></a>清空元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.clear()</span><br></pre></td></tr></table></figure><h3 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.size()</span><br><span class="line">System.out.println(ls.size());</span><br></pre></td></tr></table></figure><ul><li><code>size()</code> 获取元素个数，从1开始计算</li></ul><h3 id="集合是否为空"><a href="#集合是否为空" class="headerlink" title="集合是否为空"></a>集合是否为空</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f = ls.isEmpty();</span><br><span class="line"><span class="keyword">if</span> (f) &#123;</span><br><span class="line">    System.out.println(<span class="string">"full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合包含某个元素"><a href="#集合包含某个元素" class="headerlink" title="集合包含某个元素"></a>集合包含某个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f=ls.contains(<span class="string">"g"</span>);</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure><ul><li><code>contains()</code>方法，判断集合包含某个元素，如果存在返回true，否则返回false</li></ul><h3 id="获取元素对应的索引"><a href="#获取元素对应的索引" class="headerlink" title="获取元素对应的索引"></a>获取元素对应的索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a= ls.indexOf(<span class="string">"e"</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="keyword">int</span> b=ls.lastIndexOf(<span class="string">"a"</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><ul><li><code>indexOf()</code>方法判断元素对应的索引位置，如果当前元素存在返回对应索引，不存在返回-1</li><li><code>lastIndexOf()</code>方法和<code>indexOf()</code>一样，唯一不同就是当集合中有多个重复元素时候，会返回最后一个元素的下标，也就是索引。</li></ul><h2 id="集合转换为数组"><a href="#集合转换为数组" class="headerlink" title="集合转换为数组"></a>集合转换为数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"d"</span>);</span><br><span class="line">ls.add(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Object[] a=ls.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ls.size();i++)&#123;</span><br><span class="line">    System.out.println(ls.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=personList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        String p=iterator.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><ul><li>单线程环境 集合被创建后,在遍历它的过程中修改了结构,会抛异常</li><li>多线程环境 当一个线程在遍历这个集合,而另一个线程对这个集合的结构进行了修改会抛异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=<span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">Person person=<span class="keyword">new</span> Person();</span><br><span class="line">person.setAge(<span class="number">23</span>);</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">personList.add(person);</span><br><span class="line">Person person1=<span class="keyword">new</span> Person();</span><br><span class="line">person1.setAge(<span class="number">22</span>);</span><br><span class="line">person1.setName(<span class="string">"jack"</span>);</span><br><span class="line">personList.add(person1);</span><br><span class="line">Iterator&lt;Person&gt; iterator=personList.iterator();</span><br></pre></td></tr></table></figure><p>普通for循环遍历时候修改元素不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;personList.size();i++)&#123;</span><br><span class="line">    Person p=personList.get(i);</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加for循环遍历时候修改元素会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>迭代器遍历，使用迭代器删除不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Person p=iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        <span class="comment">//这里要使用Iterator的remove方法移除当前对象，</span></span><br><span class="line">        <span class="comment">// 如果使用List的remove方法，则同样会出现ConcurrentModificationException</span></span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="集合和数组区别"><a href="#集合和数组区别" class="headerlink" title="集合和数组区别"></a>集合和数组区别</h2><ul><li>数组长度是固定的，集合长度是可变的</li><li>数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li><li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求</li></ul><h2 id="集合案例"><a href="#集合案例" class="headerlink" title="集合案例"></a>集合案例</h2><h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!list1.contains(list.get(i)))&#123;</span><br><span class="line">        list1.add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list1)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环list中的所有元素然后删除重复<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = list.size() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">            list.remove(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过HashSet踢除重复元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h=<span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">h.addAll(list);</span><br><span class="line">list.clear();</span><br><span class="line">list.addAll(h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新版本的 JDK 可以支持 Stream 流操作，因此集合去重可以简单的使用下述语句来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="集合合并"><a href="#集合合并" class="headerlink" title="集合合并"></a>集合合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">"c"</span>);</span><br><span class="line">list1.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.addAll(list1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/B_evan/article/details/80611522" target="_blank" rel="noopener">Java集合（一）什么是集合</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82354205#2-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">Java基础List详解</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/cainiao-Shun666/p/7911142.html" target="_blank" rel="noopener">Java中List集合去除重复数据的方法</a></li><li><a href="https://www.cnblogs.com/Luouy/p/6482733.html" target="_blank" rel="noopener">JAVA List合并集合</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;下面是java中集合框架主要结构图&lt;br&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1aUHPbBiE3KVjSZFM762QhVXaJ.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="List" scheme="https://datou-y.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>mysql复杂的sql语句查询案例之GROUP BY系列</title>
    <link href="https://datou-y.github.io/posts/1077e6d7.html/"/>
    <id>https://datou-y.github.io/posts/1077e6d7.html/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-06-09T09:46:17.784Z</updated>
    
    <content type="html"><![CDATA[<p>sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，</p><div class="tip"><br>    group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用<code>where</code> 再用<code>group by</code> 或者先用group by 再用<code>having</code><br></div><ul><li><code>GROUP BY X</code>意思是将所有具有相同X字段值的记录放到一个分组里</li><li><code>GROUP BY X, Y</code>意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从<code>左到右</code>，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 </li><li><code>group by</code> 一般和聚合函数一起使用才有意义,比如 count sum avg等</li></ul><a id="more"></a><h2 id="常用的聚合函数"><a href="#常用的聚合函数" class="headerlink" title="常用的聚合函数"></a>常用的聚合函数</h2><ul><li>count() 计数</li><li>sum() 求和</li><li>avg() 平均数</li><li>max() 最大值</li><li>min() 最小值</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure><ul><li><p><code>group by</code>字句也和<code>where</code>条件语句结合在一起使用。当结合在一起时，<code>where</code>在前，<code>group by</code> 在后。即先对<code>select xx from xx</code>的记录集合用<code>where</code>进行筛选，然后再使用<code>group by</code> 对筛选后的结果进行分组。 </p></li><li><p>使用<code>having</code>字句对分组后的结果进行筛选，语法和<code>where</code>差不多:<code>having</code> 条件表达式<br><div class="tip"><br>1<code>having</code>只能用在<code>group by</code>之后，对分组后的结果进行筛选(即使用<code>having</code>的前提条件是<br>分组)<br>2<code>where</code>肯定在<code>group by</code> 之前，即也在<code>having</code>之前。<br>3.<code>where</code>后的条件表达式里不允许使用聚合函数，而<code>having</code>可以。</div></p><div></div></li><li><p>当一个查询语句同时出现了<code>where,group by,having,order by</code>的时候，执行顺序和编写顺序是： </p></li></ul><ol><li><p>执行<code>where xx</code>对全表数据做筛选，返回第1个结果集。 </p></li><li><p>针对第1个结果集使用<code>group by</code>分组，返回第2个结果集。 </p></li><li><p>针对第2个结果集中的每<code>1</code>组数据执行<code>select xx</code>，有几组就执行几次，返回第3个结果集。 </p></li><li><p>针对第3个结集执行<code>having xx</code>进行筛选，返回第4个结果集。 </p></li><li><p>针对第4个结果集<code>排序</code>。</p></li></ol><h2 id="sql分析"><a href="#sql分析" class="headerlink" title="sql分析"></a>sql分析</h2><blockquote><p>按由高到低的顺序显示个人平均分在70分以上的学生姓名和平均分，为了尽可能地提高平均分，在计算平均分前不包括分数在60分以下的成绩，并且也不计算Tom的成绩</p></blockquote><ul><li>拿到一个比较复杂的需求<code>sql</code>语句不要<code>慌</code>我们要一步步的进行需求<code>拆分</code></li></ul><p><code>分析：</code></p><ol><li><p>要求显示<code>学生姓名</code>和<code>平均分</code>因此确定第1步<code>select s_name,avg(score) from student</code> </p></li><li><p>计算平均分前<code>不</code>包括分数在<code>60分以下</code>的成绩，并且也不计算Tom的成绩因此确定第2步 <code>where score&gt;=60 and s_name!=’Tom’</code></p></li><li><p>显示<code>个人平均分</code>相同名字的学生（同一个学生）考了多门科目 因此按姓名分组确定第3步 <code>group by s_name</code></p></li><li><p>显示个人<code>平均分在70分以上</code>因此确定第4步 <code>having avg(s_score)&gt;=70</code></p></li><li><p>按由高到低的顺序 因此确定第5步 <code>order by avg(s_score) desc</code></p></li></ol><h2 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h2><h3 id="学生信息"><a href="#学生信息" class="headerlink" title="学生信息"></a>学生信息</h3><p>班级表<br><img src="https://ae01.alicdn.com/kf/HTB1_FB2aMKG3KVjSZFL761MvXXab.png" alt><br>学生表<br><img src="https://ae01.alicdn.com/kf/HTB1uqh3aLWG3KVjSZPc762kbXXa0.png" alt><br>成绩表<br><img src="https://ae01.alicdn.com/kf/HTB1HAB4aROD3KVjSZFF763n9pXaZ.png" alt></p><ul><li><p>插入班级信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span> (class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"A"</span>,<span class="string">"一班"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span> (class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"B"</span>,<span class="string">"二班"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span>(class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"C"</span>,<span class="string">"三班"</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"A"</span>,<span class="string">"Tom"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">"B"</span>,<span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"C"</span>,<span class="string">"Luck"</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入科目信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">8</span>,<span class="string">"数学"</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">"英语"</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">"语文"</span>,<span class="number">70</span>);</span><br></pre></td></tr></table></figure></li></ul><div class="tip"><br> 插入语句没有<code>from</code>表是<code>into</code>表<br></div><ul><li>查询每个学生总成绩</li><li><code>分析</code></li><li>总成绩 <code>sum(score.score)</code></li><li><p>每个学生 一个学生考了多个科目按照学生姓名分组 <code>group by student.stu_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> st.stu_name <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id=sc.stu_id) stu_name,<span class="keyword">sum</span>(sc.score)</span><br><span class="line"><span class="keyword">from</span> student st,score sc</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> st.stu_id;</span><br></pre></td></tr></table></figure></li><li><p>查询语文成绩大于90的学生</p></li><li><code>分析</code></li><li><p>语文成绩大于90 <code>where sc.score&gt;90 and sc.course=&quot;语文&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_name,sc.score</span><br><span class="line"><span class="keyword">from</span> student st,score sc</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> sc.score&gt;<span class="number">90</span> <span class="keyword">and</span> sc.course=<span class="string">"语文"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询A班所有学生信息</p></li><li><code>分析</code></li><li><p>A班 <code>where cl.class_id=&quot;A&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_id,st.stu_name <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.class_id=<span class="string">"A"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询B班学生人数</p></li><li><code>分析</code></li><li>B班 <code>where cl.class_id=B</code></li><li><p>总人数 <code>count(*)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.class_id=<span class="string">"B"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询A班语文成绩最高的学生</p></li><li><code>分析</code></li><li>A班 <code>st.class_id=A</code></li><li><p>语文成绩最高 <code>where sc.score=max(sc.score) and sc.coures=&quot;语文&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_id,st.stu_name <span class="keyword">from</span> student st, score sc,(<span class="keyword">select</span> <span class="keyword">max</span>(sc.score) max_su <span class="keyword">from</span> score sc,<span class="keyword">class</span> cl,student st</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id <span class="keyword">and</span> sc.course=<span class="string">"语文"</span> <span class="keyword">and</span> st.class_id=<span class="string">"A"</span>) t</span><br><span class="line"><span class="keyword">where</span> sc.course=<span class="string">"语文"</span> <span class="keyword">and</span> sc.stu_id=st.stu_id <span class="keyword">and</span> st.class_id=<span class="string">"A"</span> <span class="keyword">and</span> sc.score=max_su;</span><br></pre></td></tr></table></figure></li><li><p>查询各班级语文成绩最高的学生信息</p></li><li><code>分析</code></li><li>各班级 <code>group by cl.class_id</code></li><li><p>语文成绩最高 <code>max(sc.score) and sc.score=语文</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st1.stu_name ,cl1.class_name,sc1.score</span><br><span class="line"><span class="keyword">from</span> student st1,<span class="keyword">class</span> cl1,score sc1,(<span class="keyword">select</span> <span class="keyword">max</span>(sc.score) max_su <span class="keyword">from</span> score sc,<span class="keyword">class</span> cl,student st</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cl.class_id) t</span><br><span class="line"><span class="keyword">where</span> st1.stu_id=sc1.stu_id <span class="keyword">and</span> st1.class_id=cl1.class_id <span class="keyword">and</span> sc1.course=<span class="string">"语文"</span></span><br><span class="line"><span class="keyword">and</span> sc1.score=max_su</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sc1.score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询各个班级成绩最高的学生信息</p></li><li><code>分析</code></li><li>各班级 <code>group by cl.class_id</code></li><li>成绩最高 <code>max(sc.score)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_name,cl.class_name,sc.course,sc.score</span><br><span class="line"><span class="keyword">from</span> student st,score sc,<span class="keyword">class</span> cl,</span><br><span class="line">     (<span class="keyword">select</span> <span class="keyword">max</span>(sc1.score) max_score <span class="keyword">from</span> student st1,score sc1,<span class="keyword">class</span> cl1</span><br><span class="line">       <span class="keyword">where</span> st1.stu_id=sc1.stu_id <span class="keyword">and</span> st1.class_id=cl1.class_id</span><br><span class="line">       <span class="keyword">group</span> <span class="keyword">by</span> cl1.class_id) t</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id <span class="keyword">and</span> sc.score=max_score;</span><br></pre></td></tr></table></figure></li></ul><h3 id="部门信息"><a href="#部门信息" class="headerlink" title="部门信息"></a>部门信息</h3><p>员工表 <code>empy</code></p><p><img src="https://ae01.alicdn.com/kf/HTB1ZZvPb2WG3KVjSZFg762TspXam.png" alt></p><p>部门表 <code>dept</code><br><img src="https://ae01.alicdn.com/kf/HTB1zB6Vb8Gw3KVjSZFw762Q2FXaY.png" alt></p><ul><li>查询每个部门工资最高的员工</li><li><code>分析</code></li><li>每个部门 <code>group by ep.dept_id</code></li><li><p>工资最高 <code>max(ep.salary)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empy.name,salary,dept.name <span class="keyword">from</span> empy,dept,</span><br><span class="line">(<span class="keyword">select</span> dept_id,<span class="keyword">max</span>(ep.salary) maxsal <span class="keyword">from</span> empy ep <span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id) t</span><br><span class="line"><span class="keyword">where</span> empy.dept_id=t.dept_id <span class="keyword">and</span> empy.salary=maxsal <span class="keyword">and</span> empy.dept_id=dept.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门的人员信息</p></li><li><code>分析</code></li><li><p>每个部门 <code>group by ep.dept_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ep.name <span class="keyword">name</span>,ep.salary salary,dp.name department <span class="keyword">from</span> empy ep ,dept dp</span><br><span class="line"><span class="keyword">where</span> ep.dept_id=dp.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门的平均工资</p></li><li><code>分析：</code></li><li>平均工资 <code>avg(ep.salary)</code></li><li><p>每个部门 <code>group by dept_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(ep.salary) avg_salary, dp.name <span class="keyword">from</span> empy ep,dept dp</span><br><span class="line"><span class="keyword">where</span> dp.id=ep.dept_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id;</span><br></pre></td></tr></table></figure></li><li><p>查询销售部Tom的个人信息</p></li><li><code>分析</code></li><li><p><code>where ep.name=&quot;Tom&quot; and dp.name=&quot;销售部&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> empy ep,dept dp</span><br><span class="line"><span class="keyword">where</span>  ep.name=<span class="string">"Tom"</span> <span class="keyword">and</span> dp.name=<span class="string">"销售"</span> <span class="keyword">and</span> ep.dept_id=dp.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门前三名员工信息</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_id, <span class="keyword">name</span>, salary</span><br><span class="line"><span class="keyword">from</span> empy e1</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> empy e2</span><br><span class="line">    <span class="keyword">where</span> e2.dept_id=e1.dept_id <span class="keyword">and</span> e2.salary&gt;=e1.salary</span><br><span class="line">   ) &lt;=<span class="number">3</span> <span class="comment">/*这里的数值表示你想取前几名*/</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_id, salary <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>查询每个部门工资最高的前两名员工并且按照工资降序</li><li><code>分析</code></li><li>每个部门 <code>group by ep.dept_id</code></li><li>工资最高 <code>max(ep.salary)</code></li><li>前两名员工 <code>count(*)&lt;=2</code></li><li><p>工资降序 <code>order by ep.salary desc</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ep.name,ep.salary,dp.name <span class="keyword">from</span> empy ep,dept dp,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">max</span>(empy.salary) max_salary,empy.dept_id <span class="keyword">from</span> empy <span class="keyword">group</span> <span class="keyword">by</span> empy.dept_id) t</span><br><span class="line"><span class="keyword">where</span> ep.dept_id=dp.id <span class="keyword">and</span> ep.dept_id=t.dept_id <span class="keyword">and</span> ep.salary=max_salary  <span class="keyword">and</span></span><br><span class="line">      (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> empy e2 <span class="keyword">where</span> e2.dept_id=ep.dept_id <span class="keyword">and</span> e2.salary=ep.salary)&lt;=<span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> max_salary <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门每月发放的工资总和</p></li><li><code>分析</code></li><li>每个部门 <code>group by dp.dept_id</code></li><li>工资总和 <code>sum(ep.salary)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> dp.name <span class="keyword">from</span> dept dp <span class="keyword">where</span> dp.id=ep.dept_id) dept, <span class="keyword">sum</span>(ep.salary)  sum_salary <span class="keyword">from</span> empy ep</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.jianshu.com/p/8b135d373df1" target="_blank" rel="noopener">SQL中GROUP BY用法示例</a></li><li><a href="https://blog.csdn.net/zhu940923/article/details/81084080" target="_blank" rel="noopener">查询每班分数最高的学生</a></li><li><a href="https://blog.csdn.net/xx_star1204/article/details/72884983" target="_blank" rel="noopener">mysql group by 对多个字段进行分组</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;    group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用&lt;code&gt;where&lt;/code&gt; 再用&lt;code&gt;group by&lt;/code&gt; 或者先用group by 再用&lt;code&gt;having&lt;/code&gt;&lt;br&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GROUP BY X&lt;/code&gt;意思是将所有具有相同X字段值的记录放到一个分组里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP BY X, Y&lt;/code&gt;意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从&lt;code&gt;左到右&lt;/code&gt;，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;group by&lt;/code&gt; 一般和聚合函数一起使用才有意义,比如 count sum avg等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://datou-y.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>防止表单重复提交的多种策略手段</title>
    <link href="https://datou-y.github.io/posts/9fe2dfd3.html/"/>
    <id>https://datou-y.github.io/posts/9fe2dfd3.html/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-05-29T04:36:21.097Z</updated>
    
    <content type="html"><![CDATA[<p>在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><ul><li>场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交</li><li>场景二：表单提交后用户点击【刷新】按钮导致表单重复提交</li><li>场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交</li><li>场景四：使用浏览器历史记录重复提交表单。<a id="more"></a></li></ul><h2 id="问题方案"><a href="#问题方案" class="headerlink" title="问题方案"></a>问题方案</h2><h3 id="利用JavaScript防止表单重复提交"><a href="#利用JavaScript防止表单重复提交" class="headerlink" title="利用JavaScript防止表单重复提交"></a>利用JavaScript防止表单重复提交</h3><ol><li><p>表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮</p></li><li><p>用JavaScript控制Form表单只能提交一次阻止submit提交事件第二次提交</p></li><li><p>另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。</p></li></ol><div class="tip"><br>    使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题<br></div><h3 id="利用Session防止表单重复提交"><a href="#利用Session防止表单重复提交" class="headerlink" title="利用Session防止表单重复提交"></a>利用Session防止表单重复提交</h3><blockquote><p>对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到<code>session</code>了。</p></blockquote><p>在服务器端，生成一个唯一的标识符，将它存入session，并且返回给前端，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p><h3 id="通过重定向实现"><a href="#通过重定向实现" class="headerlink" title="通过重定向实现"></a>通过重定向实现</h3><p>当用户提交表单，服务器端处理后立即转向其他的页面</p><h3 id="使用Cookie处理"><a href="#使用Cookie处理" class="headerlink" title="使用Cookie处理"></a>使用Cookie处理</h3><p>使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单，</p><h3 id="在数据库里添加约束"><a href="#在数据库里添加约束" class="headerlink" title="在数据库里添加约束"></a>在数据库里添加约束</h3><p>在数据库里添加唯一约束或创建唯一索引，防止出现重复数据</p><h3 id="对表单提交数据进行检验"><a href="#对表单提交数据进行检验" class="headerlink" title="对表单提交数据进行检验"></a>对表单提交数据进行检验</h3><p>检查表单的数据是否重复或者是否符合提交要求</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/myon/p/6636934.html" target="_blank" rel="noopener">防止表单重复提交的八种简单有效的策略</a></li><li><a href="https://www.cnblogs.com/xdp-gacl/p/3859416.html" target="_blank" rel="noopener">表单重复提交的常见应用场景</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。&lt;/p&gt;
&lt;h2 id=&quot;问题再现&quot;&gt;&lt;a href=&quot;#问题再现&quot; class=&quot;headerlink&quot; title=&quot;问题再现&quot;&gt;&lt;/a&gt;问题再现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交&lt;/li&gt;
&lt;li&gt;场景二：表单提交后用户点击【刷新】按钮导致表单重复提交&lt;/li&gt;
&lt;li&gt;场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交&lt;/li&gt;
&lt;li&gt;场景四：使用浏览器历史记录重复提交表单。
    
    </summary>
    
      <category term="web综合" scheme="https://datou-y.github.io/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="form" scheme="https://datou-y.github.io/tags/form/"/>
    
  </entry>
  
  <entry>
    <title>jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？</title>
    <link href="https://datou-y.github.io/posts/c7fb8024.html/"/>
    <id>https://datou-y.github.io/posts/c7fb8024.html/</id>
    <published>2018-06-29T03:19:21.000Z</published>
    <updated>2019-05-28T23:33:21.915Z</updated>
    
    <content type="html"><![CDATA[<p>要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：<code>jpg</code>、<code>gif</code>、<code>png</code>和<code>svg</code>。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？<code>logo</code>应该是选择 <code>svg</code> 还是 <code>png</code> ？而截图是选 <code>jpg</code> 还是 <code>png</code> 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。</p><p>在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。</p><a id="more"></a><h2 id="先来看几个概念"><a href="#先来看几个概念" class="headerlink" title="先来看几个概念"></a>先来看几个概念</h2><ul><li>有损(<code>Lossless</code>)和无损(<code>Lossy</code>)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。</li><li>索引色(<code>Indexed color</code>)和直接色(<code>Direct color</code>)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。</li><li>光栅格式(<code>raster</code>)和矢量格式(<code>vector</code>)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 <code>Photoshop</code> 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。</li></ul><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p><code>JEPG</code>由联合图像专家小组（<code>Joint Photographic Experts Group</code>）于1992年创建，并以创建者命名。<code>JPEG</code>是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。</p><p>因为 <code>JPEG</code> 压缩在亮度和色彩上面的优越性，所以 <code>JPEG</code> 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。</p><p><code>JPEG</code> 的压缩可以用 <code>Photoshop</code> 里存储为 <code>web</code> 格式的时候可以直接选择压缩品质，一般用于 <code>web</code> 的 <code>JPG</code> 图片选择 <code>50%-60%</code> 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 <code>TinyJPG</code>。</p><p>下面这个图，我用的是 <code>50%</code>的品质压缩出来的 <code>JPG</code>，很明显质量要比 <code>GIF</code> 的要好很多，而且文件尺寸也小不少。</p><p><img src="../../../../images/201706/webgra_01.png" alt="webgra_01"></p><blockquote><p><code>JPEG</code> 和 <code>JPG</code> 的区别：<code>JPEG</code> 更多的指的是 <code>.jpg</code> 图像格式的一种压缩算法，而 <code>JPG</code> 就是一种图像存储的格式。</p></blockquote><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>可移植网络图形（<code>Portable Network Graphics</code>）也是一种自1995年以来就一直存在的光栅图像格式。它与 <code>JPEG</code> 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。</p><h3 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h3><p><code>PNG</code>其实可以细分为好几个格式的，有<code>PNG 8</code>、<code>PNG 24</code>和<code>PNG 32</code>。那么怎么区分一个 <code>PNG</code> 图片是什么格式的呢？</p><p><img src="../../../../images/201706/webgra_02.png" alt="png_24"></p><p>打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 <code>PNG 24</code> 格式的图片。同样，<code>PNG 8</code> 和 <code>PNG 32</code> 的位深度分别是8和32。</p><blockquote><p>位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 <code>PNG 8</code> 最多只能存储256种颜色。<code>PNG 24</code> 和 <code>PNG 32</code>又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；<code>PNG 32</code>中剩余的8位存储的是<code>Alpha</code> 通道的透明色。</p></blockquote><p>然后如何生成这些不同格式的图片呢？<br>自然是用专业的图像处理软件啦，比如可以用 <code>Photoshop</code> 或者 <code>Fireworks</code>。这里以 <code>Photoshop</code> 为例子，文件-&gt;存储为 <code>Web</code> 所用格式， 可以看到下拉这里只有 <code>PNG-8</code> 和 <code>PNG-24</code>，而没有 <code>PNG-32</code> 呢？是因为 <code>Photoshop</code>不支持这个格式嘛？并不是。</p><p><img src="../../../../images/201706/webgra_04.png" alt="png_generate"></p><p>在 <code>Photoshop</code> 里导出 <code>PNG-32</code> 格式的图片是通过选择 <code>PNG-24</code>格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 <code>PNG-24</code> 格式。由此看来 <code>PNG-24</code> 是不支持透明的，<code>PNG-32</code> 是支持透明的。</p><h3 id="PNG透明度"><a href="#PNG透明度" class="headerlink" title="PNG透明度"></a>PNG透明度</h3><p>从 <code>Fireworks 8</code>的优化面板里可以看到 <code>PNG</code> 格式存在三种透明格式：不透明、索引透明和 <code>Alpha</code>透明。</p><p><img src="../../../../images/201706/webgra_05.png" alt="png_transparency"></p><ul><li><p><code>PNG 8</code>透明度</p><p>  从上面那个图里可以看出 <code>PNG 8</code> 是支持这三种不透明格式的。但是 <code>Photoshop</code> 只支持导出不透明和索引透明格式。在<code>Photoshop</code> 中如果选择 <code>PNG 8</code>，且勾选了透明度，那么导出的图片就是 <code>PNG 8</code> 索引透明，否则就是 <code>PNG 8</code> 不透明。</p><p>  <img src="../../../../images/201706/webgra_06.png" alt="png_8_index"></p><p>  用 <code>Photoshop</code> 和 <code>Fireworks 8</code> 导出 <code>PNG 8</code> 的各种格式如下所示：</p><p>  <img src="../../../../images/201706/webgra_03.png" alt="png_8_transparency"></p><p>  根据以上图片我们可以得出结论：</p><ul><li><code>Photoshop</code> 导出的 <code>PNG 8</code> 图片都带有锯齿。</li><li><p><code>PNG 8</code> 索引透明都带有锯齿，且 <code>Fireworks 8</code> 导出的 <code>PNG 8</code>索引透明的锯齿是白色的。</p><p>再来看看这些格式在不同浏览器下的表现情况：</p><p><img src="../../../../images/201706/webgra_07.png" alt="png_8_Compatibility"></p><p>根据以上图片我们可以得出结论：</p></li><li><p><code>PNG 8</code> 索引透明和 <code>Alpha</code> 透明都兼容<code>IE 6</code>；但美中不足的是，<code>PNG 8Alpha</code>透明在 <code>IE 6</code>下会产生锯齿。</p></li><li>其他格式的图片在各个浏览器下的表现一致。</li><li><code>Fireworks 8</code>导出的 <code>PNG 8</code>索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。</li></ul></li><li><p><code>PNG 24</code> 和 <code>PNG 32</code></p><p>  <code>PNG 24</code> 是不透明的；<code>PNG 32</code> 是支持透明的，且是 <code>Alpha</code> 透明。来看下它们在不同浏览器下的表现：</p><p>  <img src="../../../../images/201706/webgra_08.png" alt="png_2432_Compatibility"></p><p>  <code>PNG 32</code> 图片的透明区域在 <code>IE 6</code> 下将不再透明，而是颜色值为 <code>f0f0f0</code> 的灰色填充，在更高级版本的 <code>IE</code> 下是正常的。<code>PNG 32</code> 图片不会有锯齿。</p></li></ul><h3 id="PNG压缩"><a href="#PNG压缩" class="headerlink" title="PNG压缩"></a>PNG压缩</h3><p>本文前面提到了 <code>JPEG</code> 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 <code>PNG</code> 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 <a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a>，这个工具可以压缩 <code>JPEG</code> 和 <code>PNG</code> 格式。</p><p><img src="../../../../images/201706/webgra_09.png" alt="png_jpeg"></p><p>从上图这个图中，我们可以从不同角度得出一些结论：</p><ul><li><code>PNG 8</code> 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以<code>PNG 8</code>不适合用于存储颜色复杂的图像。相反，由于其相对于 <code>PNG 24</code> 或者 <code>PNG 32</code> 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。</li><li>对比100%质量的 <code>JPG</code>、55%质量的 <code>JPG</code>、<code>PNG 24</code> 和 <code>PNG 32</code>，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 <code>JPG</code> 占用存储最小；压缩后，<code>PNG 24</code> 和 <code>PNG 32</code> 一样，会比55%质量的 <code>JPG</code> 小一些，但是由于 <code>PNG 32</code> 支持透明，所以对于颜色丰富的图像建议用 <code>PNG 32</code> 格式导出，然后用压缩工具压缩一下即可。</li><li>对比压缩前后的 <code>PNG 24</code> 和 <code>PNG 32</code> 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 <code>web</code> 上的 <code>PNG 24</code> 或 <code>PNG 32</code> 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>图形交换格式（<code>Graphics Interchange Format</code>）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 <code>IE 6</code> 下也支持得很好，唯一美中不足的是除了 <code>Fireworks 8</code> 导出的 <code>GIF</code> 不透明格式外，所有的其他 <code>GIF</code> 格式的图片都存在锯齿。</p><p><img src="../../../../images/201706/webgra_10.png" alt="gif"></p><p>但是 <code>GIF</code> 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画：</p><p><img src="../../../../images/201706/traffic-light.gif" alt="gif_ani"></p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>可伸缩矢量图形（<code>Scalable Vector Graphics</code>），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 <code>SVG</code> 相对于光栅格式的图像具有以下优势：</p><ul><li>任意伸缩图像，而不会破坏图像的清晰度和细节。</li><li>完全支持 <code>DOM</code>，以及 <code>JavaScript</code> 能够很好的访问到它。</li><li>总体来讲，<code>SVG</code>的文件会比 <code>GIF</code> 或 <code>JPG</code> 的会小很多。</li></ul><p>就像其它矢量格式，<code>SVG</code> 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 <code>Retina</code> 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片：</p><p><img src="../../../../images/201706/webgra_11.png" alt="svg"></p><h2 id="SVG用途"><a href="#SVG用途" class="headerlink" title="SVG用途"></a>SVG用途</h2><p><code>SVG</code> 在线条艺术，<code>LOGO</code>，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，<code>SVG</code> 和 <code>PNG</code> 都能很好地达到同一个目的。对于线条艺术，<code>SVG</code> 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 <code>SVG</code> 真正出色的地方是数据可视化。由于可以使用<code>JavaScript</code> 来操纵和创建矢量动画，诸如 <code>D3</code> 之类的库提供了无限的可能性。<code>LOGO</code>, 图标和数据可视化是 <code>SVG</code> 使用的优秀范例。</p><p><img src="../../../../images/201706/webgra_12.png" alt="svg_use"></p><h2 id="SVG压缩"><a href="#SVG压缩" class="headerlink" title="SVG压缩"></a>SVG压缩</h2><p>比较好的 <code>SVG</code> 方法应该是通过清除 <code>SVG</code> 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 <code>Adobe Illustrator</code> 编辑 <code>SVG</code>，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。</p><p><img src="../../../../images/201706/webgra_13.png" alt="svg_compress"> </p><p>清理不必要的节点是缩减 <code>SVG</code> 尺寸的一种途径。<br>元素标签是包含在 <code>SVG</code> 文件内的所有内容，包括开始和结束标签。<br>矢量编辑软件，如 <code>Adobe Illustrator</code> 和 <code>Sketch</code> 可能会到处含有非必要元素和属性的 <code>SVG</code> 。<br><code>SVG</code> 压缩器可用于删除这种多余的信息。<code>Compresso</code> 和 <code>SVGOMG</code> 等在线工具可以完成此工作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://web.jobbole.com/91599/" target="_blank" rel="noopener">在网页上使用JPG、PNG和SVG：新手指南</a></li><li><a href="http://www.cnblogs.com/PeunZhang/archive/2013/05/30/3050394.html" target="_blank" rel="noopener">PNG使用技巧</a></li><li><a href="https://stackoverflow.com/questions/2336522/png-vs-gif-vs-jpeg-vs-svg-when-best-to-use" target="_blank" rel="noopener">PNG vs. GIF vs. JPEG vs. SVG - When best to use?</a></li><li><a href="https://www.sitepoint.com/gif-png-jpg-which-one-to-use/" target="_blank" rel="noopener">JPG vs PNG vs GIF vs SVG – What is the Difference?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：&lt;code&gt;jpg&lt;/code&gt;、&lt;code&gt;gif&lt;/code&gt;、&lt;code&gt;png&lt;/code&gt;和&lt;code&gt;svg&lt;/code&gt;。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？&lt;code&gt;logo&lt;/code&gt;应该是选择 &lt;code&gt;svg&lt;/code&gt; 还是 &lt;code&gt;png&lt;/code&gt; ？而截图是选 &lt;code&gt;jpg&lt;/code&gt; 还是 &lt;code&gt;png&lt;/code&gt; 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。&lt;/p&gt;
&lt;p&gt;在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。&lt;/p&gt;
    
    </summary>
    
      <category term="web综合" scheme="https://datou-y.github.io/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="svg" scheme="https://datou-y.github.io/tags/svg/"/>
    
      <category term="图像" scheme="https://datou-y.github.io/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>chrome开发者工具实用小技巧</title>
    <link href="https://datou-y.github.io/posts/d7262aae.html/"/>
    <id>https://datou-y.github.io/posts/d7262aae.html/</id>
    <published>2018-06-15T10:20:21.000Z</published>
    <updated>2019-05-28T01:54:06.744Z</updated>
    
    <content type="html"><![CDATA[<p><code>chrome</code> 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 <code>chrome</code> 开发者工具都有哪些很常用或实用的功能。<br>写这篇文章的时候，chrome的版本如下：</p><p><img src="../../../../images/201703/chrome_01.png" alt="chrome版本"></p><a id="more"></a><h2 id="Elements面板篇"><a href="#Elements面板篇" class="headerlink" title="Elements面板篇"></a>Elements面板篇</h2><ul><li><p>在 <code>Elements</code> 面板中，使用 <code>Ctrl + F</code> 打开搜索输入框，可以输入常规字符串或选择器来选择 <code>HTML</code> 元素。</p><p>  <img src="../../../../images/201703/chrome_02.png" alt="ctrl+f"></p></li><li><p>在元素前面的小黑三角上用 <code>Alt +</code> 鼠标左键即可展开收起当前元素下的所有子元素。</p><p>  <img src="../../../../images/201703/chrome_03.png" alt="alt+left"></p></li><li><p>css数值使用快捷键调整：</p><ul><li><code>Up / Down</code>：增加减少1</li><li><code>Ctrl + Up / Ctrl + Down</code>：增加减少100</li><li><code>Shift + Up / Shift + Down</code>：增加减少10</li><li><code>Alt + Up / Alt + Down</code>： 增加减少0.1</li><li><p><code>Up / Down</code> 等同于鼠标滚轮</p><p><img src="../../../../images/201703/chrome_04.png" alt="css-number-value"></p></li></ul></li><li><p>查看事件监听器。选中一个元素，然后点击 <code>Event Listeners</code> 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 <code>handler</code>，右键单击选择 <code>Show function definition</code> 即可在 <code>Source</code> 面板中打开且定位到当前事件的处理函数的所在位置。</p><p>  <img src="../../../../images/201703/chrome_05.png" alt="event-listeners"></p></li><li><p>点击颜色方格会打开 <code>chrome</code> 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( <code>toggle color picker</code> )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，<code>Color Palettes</code> 里分3小块，分别是：<code>Material Design</code>，一组符合 <code>Material Design</code> 规范的颜色；<code>Page Colors</code>，一组从页面的 <code>CSS</code> 自动生成的颜色；<code>Custom</code>，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 <code>chrome</code> 的 <code>DevTools</code> 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。</p><p>  <img src="../../../../images/201703/chrome_06.png" alt="color-palette"></p></li><li><p>可视化 <code>Shadow DOM</code>。在 <code>dom</code> 元素列表中，都是我们写的看得见的元素。其实在构建 <code>dom</code> 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 <code>Settings</code> -&gt; <code>Preferences</code> -&gt; <code>Elements</code> 下的 <code>Show user agent shadow DOM</code> 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。</p><p>  <img src="../../../../images/201703/chrome_07.png" alt="shadow-dom"></p></li><li><p>给元素添加状态。元素有4种用户行为状态：:<code>active</code>、<code>:hover</code>、<code>:focus</code>、<code>:visited</code>。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 <code>Styles</code>面板中进行设置。</p><p>  <img src="../../../../images/201703/chrome_08.png" alt="ele-state"></p></li><li><p>使用 <code>Tab</code> 键可以在 <code>CSS</code> 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 <code>Shift + Tab</code>。但是再使用快捷键切换选定之前需要先让光标在 <code>Styles</code> 面板，处于输入状态即可。</p></li></ul><h2 id="Console面板篇"><a href="#Console面板篇" class="headerlink" title="Console面板篇"></a>Console面板篇</h2><ul><li><p>使用 <code>$0-$4</code> 选择元素。<code>$0</code> 返回最后一次选择的元素，<code>$1</code> 返回仅在最后一次之前选择的元素，以此类推。<code>$(selector)</code> 返回带有指定 <code>CSS</code> 选择器的第一个DOM元素的引用。<code>$$(selector)</code> 返回 <code>CSS</code> 选择所有匹配的元素数组。</p><p>  <img src="../../../../images/201703/chrome_09.png" alt="$_selector"></p>  <div class="tip"><br>      如果页面使用了类 <code>Jquery</code> 库，则 <code>$(selector)</code> 功能将被覆盖， <code>$</code> 将与该库的实现对应。<br>  </div></li><li><p>一些实用的方法:</p><ul><li><code>console.log()</code>、<code>console.info()</code>、<code>console.warn()</code>、<code>console.error()</code>打印不同的状态信息</li><li><p>使用CSS设置控制台输出样式，利用CSS格式说明符%c。</p><p>  <img src="../../../../images/201703/chrome_17.png" alt="css-format"></p></li><li><p><code>copy(object)</code>，将指定对象的字符串表示复制到剪贴板。</p></li><li><p><code>getEventListeners(object)</code>，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 <code>Event Listeners</code> 面板那边 <code>show function definition</code> 那样的功能。</p><p>  <img src="../../../../images/201703/chrome_13.png" alt="ctrl+p"></p></li><li><p><code>inspect(elem)</code>， 跳转到 <code>Elements</code> 面板的指定元素节点</p></li></ul></li><li><p><code>console.time(str)</code> 和 <code>console.timeEnd(str)</code> 返回这中间间隔的时间。下图的 <code>4.24e+3ms</code> 是数字的科学计数法表示，表示的实际值是：<code>4.24*10*10*10ms</code>，即4.24秒。</p><p>  <img src="../../../../images/201703/chrome_12.png" alt="console.time"></p></li></ul><h2 id="Sources面板篇"><a href="#Sources面板篇" class="headerlink" title="Sources面板篇"></a>Sources面板篇</h2><ul><li><p><code>Ctrl + Shift + F</code>，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 <code>className</code> 或者 <code>id</code> 把这个文件找出来。</p></li><li><p><code>Ctrl + P</code>，根据文件名查找所有站内资源文件。</p><p>  <img src="../../../../images/201703/chrome_11.png" alt="ctrl+p"></p></li><li><p>漂亮打印。对于 <code>Sources</code> 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。</p><p>  <img src="../../../../images/201703/chrome_14.png" alt="pretty-print"></p></li><li><p>在 <code>Sources</code> 面板中找到图片资源，然后在图片上右键即可获取图片的 <code>Data URI</code>。</p><p>  <img src="../../../../images/201703/chrome_15.png" alt="data-uri"></p></li><li><p>使用 <code>console.dir( ele )</code> 将 <code>DOM</code> 元素格式化为 <code>JavaScript</code> 对象</p><p>  <img src="../../../../images/201703/chrome_18.png" alt="console.dir"></p></li><li><p>在 <code>Sources</code> 面板编辑文件小技巧</p><ul><li>使用 <code>Ctrl + p</code> 打开输入框输入 <code>:20:30</code> 回车后，光标位置将跳转到当前文件的第20行第30列</li><li>使用使用 <code>Alt + -</code> 和 <code>Alt + =</code> 可以在上一个鼠标位置和下一个鼠标位置之间跳转</li><li>使用 <code>Ctrl +</code> 鼠标左键可以添加多个光标输入位置</li><li><p>使用 <code>Alt +</code> 鼠标拖动可以拉出一块矩形选区</p><p>  <img src="../../../../images/201703/chrome_16.png" alt="alt-move"></p></li></ul></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">chrome-devtools</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;chrome&lt;/code&gt; 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 &lt;code&gt;chrome&lt;/code&gt; 开发者工具都有哪些很常用或实用的功能。&lt;br&gt;写这篇文章的时候，chrome的版本如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../images/201703/chrome_01.png&quot; alt=&quot;chrome版本&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web综合" scheme="https://datou-y.github.io/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="chrome" scheme="https://datou-y.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题的安装和使用</title>
    <link href="https://datou-y.github.io/posts/4a1d4f4f.html/"/>
    <id>https://datou-y.github.io/posts/4a1d4f4f.html/</id>
    <published>2018-06-04T07:20:21.000Z</published>
    <updated>2019-05-28T11:59:26.173Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo博客框架有很多第三方主题，我们可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题官网</a>去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是<a href="https://github.com/bulandent/hexo-theme-bubuzou" target="_blank" rel="noopener">bubuzou</a></p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul><li>官网下载好主题后放在博客的<code>themes</code>文件夹下</li><li>然后修改根目录<code>_config.yml</code>文件的<code>theme</code>配置为当前下载的主题文件夹名称</li><li>然后根据每个主题的使用文档修改下载的对应主题文件夹下的<code>_config.yml</code>来配置对应主题功能<div class="tip"><br>  这里我以<a href="https://bubuzou.com/" target="_blank" rel="noopener">bubuzou</a>主题为例<br></div></li></ul><a id="more"></a><p>配置这个主题需要注意的点</p><ul><li>他的评论，文章阅读次数，功能用的LeanCloud需要自己注册，对应的LeanCloud统计次数class是Timer不是Counter否则会出现访问次数没有</li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud官网</a></li></ul><blockquote><p>主题文档  <a href="https://github.com/bulandent/hexo-theme-bubuzou/blob/master/doc/doc-zh.md" target="_blank" rel="noopener">bubuzou</a></p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/y_z_w123/article/details/78801096" target="_blank" rel="noopener">hexo的安装和主题的替换</a></li><li><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">hexo教程系列</a> </li><li><a href="https://blog.csdn.net/lijing742180/article/details/87928554" target="_blank" rel="noopener">Hexo博客使用LeanCloud统计页面访问次数</a></li><li><a href="https://www.jianshu.com/p/b4b758ee81dd" target="_blank" rel="noopener">leanCloud的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo博客框架有很多第三方主题，我们可以到&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主题官网&lt;/a&gt;去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是&lt;a href=&quot;https://github.com/bulandent/hexo-theme-bubuzou&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bubuzou&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;官网下载好主题后放在博客的&lt;code&gt;themes&lt;/code&gt;文件夹下&lt;/li&gt;
&lt;li&gt;然后修改根目录&lt;code&gt;_config.yml&lt;/code&gt;文件的&lt;code&gt;theme&lt;/code&gt;配置为当前下载的主题文件夹名称&lt;/li&gt;
&lt;li&gt;然后根据每个主题的使用文档修改下载的对应主题文件夹下的&lt;code&gt;_config.yml&lt;/code&gt;来配置对应主题功能&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;  这里我以&lt;a href=&quot;https://bubuzou.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bubuzou&lt;/a&gt;主题为例&lt;br&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="博客" scheme="https://datou-y.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="blog" scheme="https://datou-y.github.io/tags/blog/"/>
    
      <category term="Hexo Themes" scheme="https://datou-y.github.io/tags/Hexo-Themes/"/>
    
  </entry>
  
  <entry>
    <title>hexo-abbrlink插件使用</title>
    <link href="https://datou-y.github.io/posts/32d54ad4.html/"/>
    <id>https://datou-y.github.io/posts/32d54ad4.html/</id>
    <published>2018-06-01T06:20:21.000Z</published>
    <updated>2019-05-28T11:56:36.075Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">Hexo plugin</a>基于文章标题用来生成静态文章链接。查看官方文档<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>获得详细使用信息</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="How-to-install"><a href="#How-to-install" class="headerlink" title="How to install"></a>How to install</h3><p>Add plugin to Hexo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></p><h3 id="Modify-permalink-in-config-yml-file"><a href="#Modify-permalink-in-config-yml-file" class="headerlink" title="Modify permalink in config.yml file:"></a>Modify permalink in config.yml file:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html/</span><br></pre></td></tr></table></figure><h3 id="There-are-two-settings"><a href="#There-are-two-settings" class="headerlink" title="There are two settings:"></a>There are two settings:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)</span><br><span class="line">rep -- Represent (the generated link could be presented in hex or dec value)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  #support crc16(default) and crc32</span><br><span class="line">  rep: hex    #support dec(default) and hex</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>The generated link will look like the following:</p><blockquote><p>crc16 &amp; hex<br><a href="https://post.zz173.com/posts/66c8.html" target="_blank" rel="noopener">https://post.zz173.com/posts/66c8.html</a><br>crc16 &amp; dec<br><a href="https://post.zz173.com/posts/65535.html" target="_blank" rel="noopener">https://post.zz173.com/posts/65535.html</a></p></blockquote><blockquote><p>crc32 &amp; hex<br><a href="https://post.zz173.com/posts/8ddf18fb.html" target="_blank" rel="noopener">https://post.zz173.com/posts/8ddf18fb.html</a><br>crc32 &amp; dec<br><a href="https://post.zz173.com/posts/1690090958.html" target="_blank" rel="noopener">https://post.zz173.com/posts/1690090958.html</a></p></blockquote><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h2><p>Maximum number of posts is 65535 for crc16. (For a personal blog site, this number is decent)</p><h2 id="More-info"><a href="#More-info" class="headerlink" title="More info"></a>More info</h2><p>see  <a href="https://post.zz173.com/detail/hexo-abbrlink.html" target="_blank" rel="noopener">this</a>(Chinese)</p><h2 id="ThanksFor"><a href="#ThanksFor" class="headerlink" title="ThanksFor"></a>ThanksFor</h2><p><a href="https://github.com/NoahDragon" target="_blank" rel="noopener">NoahDragon</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个&lt;a href=&quot;https://hexo.io/plugins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo plugin&lt;/a&gt;基于文章标题用来生成静态文章链接。查看官方文档&lt;a href=&quot;https://github.com/rozbo/hexo-abbrlink&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-abbrlink&lt;/a&gt;获得详细使用信息&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;How-to-install&quot;&gt;&lt;a href=&quot;#How-to-install&quot; class=&quot;headerlink&quot; title=&quot;How to install&quot;&gt;&lt;/a&gt;How to install&lt;/h3&gt;&lt;p&gt;Add plugin to Hexo:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-abbrlink --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Modify-permalink-in-config-yml-file&quot;&gt;&lt;a href=&quot;#Modify-permalink-in-config-yml-file&quot; class=&quot;headerlink&quot; title=&quot;Modify permalink in config.yml file:&quot;&gt;&lt;/a&gt;Modify permalink in config.yml file:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;permalink: posts/:abbrlink.html/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;There-are-two-settings&quot;&gt;&lt;a href=&quot;#There-are-two-settings&quot; class=&quot;headerlink&quot; title=&quot;There are two settings:&quot;&gt;&lt;/a&gt;There are two settings:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rep -- Represent (the generated link could be presented in hex or dec value)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="博客" scheme="https://datou-y.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="blog" scheme="https://datou-y.github.io/tags/blog/"/>
    
      <category term="Hexo" scheme="https://datou-y.github.io/tags/Hexo/"/>
    
      <category term="Hexo Plugins" scheme="https://datou-y.github.io/tags/Hexo-Plugins/"/>
    
  </entry>
  
  <entry>
    <title>快速、简洁且高效的博客框架Hexo</title>
    <link href="https://datou-y.github.io/posts/4a17b156.html/"/>
    <id>https://datou-y.github.io/posts/4a17b156.html/</id>
    <published>2018-05-30T10:20:21.000Z</published>
    <updated>2019-05-28T12:35:06.404Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是一个快速、简洁且高效的博客框架，查看官方文档 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> 找到答案，或者你可以询问我<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Clean-cache"><a href="#Clean-cache" class="headerlink" title="Clean cache"></a>Clean cache</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://easyhexo.com/" target="_blank" rel="noopener">Easy Hexo 👨‍💻</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! 这是一个快速、简洁且高效的博客框架，查看官方文档 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; 找到答案，或者你可以询问我&lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="博客" scheme="https://datou-y.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="blog" scheme="https://datou-y.github.io/tags/blog/"/>
    
      <category term="Hexo" scheme="https://datou-y.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
