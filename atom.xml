<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://datou-y.github.io/"/>
  <updated>2019-06-16T02:07:13.060Z</updated>
  <id>https://datou-y.github.io/</id>
  
  <author>
    <name>daTou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA工具开发使用@Autowired注解报错解决方案 </title>
    <link href="https://datou-y.github.io/posts/794ce61d.html/"/>
    <id>https://datou-y.github.io/posts/794ce61d.html/</id>
    <published>2019-06-16T01:55:51.289Z</published>
    <updated>2019-06-16T02:07:13.060Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>IDEA</code>工具进行开发的时候,需要<code>@Autowired</code>自动注解<code>bean</code>时会报红线,但是项目依然能够运行<br>点击<code>File--》Project Structure...--》Facets</code>删除右边对应的<code>spring</code>模块<br>对应的<code>IDEA</code>版本仅限于如下版本<br><img src="https://ae01.alicdn.com/kf/HTB1CSx7c21H3KVjSZFH762KppXau.png" alt><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;IDEA&lt;/code&gt;工具进行开发的时候,需要&lt;code&gt;@Autowired&lt;/code&gt;自动注解&lt;code&gt;bean&lt;/code&gt;时会报红线,但是项目依然能够运行&lt;br&gt;点击&lt;code&gt;File--》Project Structure...--》Facets&lt;/code&gt;删除右边对应的&lt;code&gt;spring&lt;/code&gt;模块&lt;br&gt;对应的&lt;code&gt;IDEA&lt;/code&gt;版本仅限于如下版本&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1CSx7c21H3KVjSZFH762KppXau.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="问题" scheme="https://datou-y.github.io/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="problem" scheme="https://datou-y.github.io/tags/problem/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.x(四):整合Mybatis的四种方式</title>
    <link href="https://datou-y.github.io/posts/7f83a289.html/"/>
    <id>https://datou-y.github.io/posts/7f83a289.html/</id>
    <published>2019-06-15T13:16:19.128Z</published>
    <updated>2019-06-16T08:01:16.254Z</updated>
    
    <content type="html"><![CDATA[<p>目前的大环境下，使用<code>Mybatis</code>作为持久层框架还是占了绝大多数的，下面我们来说一下使用<code>Mybatis</code>整合<code>Spring Boot</code>的几种姿势。</p><h2 id="零配置注解开发"><a href="#零配置注解开发" class="headerlink" title="零配置注解开发"></a>零配置注解开发</h2><ol><li>引入依赖</li></ol><ul><li>我们需要在<code>pom</code>文件中添加依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ol start="2"><li><code>application.properties</code> 添加相关配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/spring_boot_demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>Spring Boot</code> 会自动加载 <code>spring.datasource.*</code> 相关配置，数据源就会自动注入到 <code>sqlSessionFactory</code> 中，<code>sqlSessionFactory</code> 会自动注入到 Mapper 中，对了，你一切都不用管了，直接拿起来使用就行了。</li></ul><ol start="3"><li>在启动类中添加对 <code>mapper</code> 包扫描<code>@MapperScan</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.example.demo.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>在启动类指定<code>@MapperScan，</code>这样做就可以不用去挨个的在<code>Mapper</code>接口中添加<code>@Mapper</code>注解。这里的值就是你的<code>Mapper</code>接口所在的包的路径。不然每个 <code>mapper</code> 加个注解也挺麻烦的</li></ul><ol start="4"><li>编写<code>Mapper</code>接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.enumerate.EnumerateUserSex;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.model.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from users"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>, column = <span class="string">"user_sex"</span>, javaType = EnumerateUserSex.class),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from users where id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"userSex"</span>, column = <span class="string">"user_sex"</span>, javaType = EnumerateUserSex.class),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"nickName"</span>, column = <span class="string">"nick_name"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into users(userName,passWord,user_sex,nick_name) values(#&#123;userName&#125;,#&#123;passWord&#125;,#&#123;userSex&#125;,#&#123;nickName&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"UPDATE users SET userName=#&#123;userName&#125;,nick_name=#&#123;nickName&#125; WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"DELETE FROM users WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>为了更接近生产我特地将 <code>user_sex、nick_name</code> 两个属性在数据库加了下划线和实体类属性名不一致，另外 <code>user_sex</code> 使用了枚举</p></li><li><p><code>@Select</code> 是查询类的注解，所有的查询均使用这个</p></li><li><p><code>@Result</code> 修饰返回的结果集，关联实体类属性和数据库字段一一对应其中对应的参数分别有<code>property，</code>对应实体属性，<code>column</code>对应数据库字段，<code>javaType</code>指定对应<code>java</code>类型。如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。</p></li><li><p><code>@Insert</code> 插入数据库使用，直接传入实体类会自动解析属性到对应的值</p></li><li><p><code>@Update</code> 负责修改，也可以直接传入对象</p></li><li><p><code>@delete</code> 负责删除</p></li></ul><ol start="5"><li>测试程序编写<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.model.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUsers"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.getAll();</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUser/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        User user = userMapper.getOne(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/add"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/update"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/delete/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = userMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="极简-xml-版本"><a href="#极简-xml-版本" class="headerlink" title="极简 xml 版本"></a>极简 xml 版本</h2><p>极简 <code>xml</code> 版本保持映射文件的老传统，接口层只需要定义空方法，系统会自动根据方法名在映射文件中找对应的 <code>Sql</code></p><ol><li>编写配置文件<br><code>pom</code> 文件第一步与姿势一的重复，只是<code>application.properties</code>新增以下配置</li></ol><ul><li>我们需要在配置文件中添加<code>mybatis-config.xml</code>的路径以及用于<code>Mapper*.xml</code>的文件的路径：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location=classpath:mybatis/mybatis-config.xml</span><br><span class="line">mybatis.mapper-locations=classpath:mybatis/mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写Mapper接口以及配置文件：</li></ol><p><code>Mapper</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;UserEntity&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">UserEntity <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(UserEntity user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mybatis-config.xml</code> 配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Integer"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Long"</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"HashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.HashMap"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedHashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedHashMap"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ArrayList"</span> <span class="attr">type</span>=<span class="string">"java.util.ArrayList"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedList"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedList"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>UserMapper.xml：</code>的映射文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.neo.mapper.UserMapper"</span> &gt;</span><br><span class="line">    &lt;resultMap id=<span class="string">"BaseResultMap"</span> type=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">        &lt;id column=<span class="string">"id"</span> property=<span class="string">"id"</span> jdbcType=<span class="string">"BIGINT"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"userName"</span> property=<span class="string">"userName"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"passWord"</span> property=<span class="string">"passWord"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">"user_sex"</span> property=<span class="string">"userSex"</span> javaType=<span class="string">"com.neo.enums.UserSexEnum"</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">"nick_name"</span> property=<span class="string">"nickName"</span> jdbcType=<span class="string">"VARCHAR"</span> /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;sql id=<span class="string">"Base_Column_List"</span> &gt;</span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"getAll"</span> resultMap=<span class="string">"BaseResultMap"</span>  &gt;</span><br><span class="line">       SELECT </span><br><span class="line">       &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;</span><br><span class="line">   FROM users</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">"getOne"</span> parameterType=<span class="string">"java.lang.Long"</span> resultMap=<span class="string">"BaseResultMap"</span> &gt;</span><br><span class="line">        SELECT </span><br><span class="line">       &lt;include refid=<span class="string">"Base_Column_List"</span> /&gt;</span><br><span class="line">   FROM users</span><br><span class="line">   WHERE id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">       INSERT INTO </span><br><span class="line">       users</span><br><span class="line">       (userName,passWord,user_sex) </span><br><span class="line">       VALUES</span><br><span class="line">       (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;update id=<span class="string">"update"</span> parameterType=<span class="string">"com.neo.entity.UserEntity"</span> &gt;</span><br><span class="line">       UPDATE </span><br><span class="line">       users </span><br><span class="line">       SET </span><br><span class="line">       &lt;if test="userName != null"&gt;userName = #&#123;userName&#125;,&lt;/if&gt;</span><br><span class="line">       &lt;if test="passWord != null"&gt;passWord = #&#123;passWord&#125;,&lt;/if&gt;</span><br><span class="line">       nick_name = #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">       id = #&#123;id&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;delete id=<span class="string">"delete"</span> parameterType=<span class="string">"java.lang.Long"</span> &gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">        users </span><br><span class="line">       WHERE </span><br><span class="line">        id =#&#123;id&#125;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><ul><li>其实就是把上个版本中 <code>Mapper</code>的 <code>Sql</code> 搬到了这里的 <code>xml</code>中了</li><li>这里需要注意<code>UserMapper.xml</code>中的<code>namespace</code>需要与接口的路径一致，否则会出现错误</li></ul><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>使用<code>SqlSession</code>的姿势和可以与上面两种方式进行结合，emmm。。。可以这么理解，<code>SQL</code>就在那里，只不过分为了两个不同的方法去调用。其余的代码我们就不再多讲，直接来看是如何调用的：</p><p><img src="https://ae01.alicdn.com/kf/HTB1qavQafBj_uVjSZFp7630SXXaf.png" alt></p><ul><li>这里不再基于<code>Mapper</code>代理方式调用而是我们自己指定对应的Mapper接口实现类手动调用对应<code>Mapper.xml</code>中对应方法.</li><li>可以看到，参数写的是要调用的<code>方法的路径</code>（这里是与<code>namespace</code>相对应）。</li></ul><h2 id="基于SqlSession的升级"><a href="#基于SqlSession的升级" class="headerlink" title="基于SqlSession的升级"></a>基于SqlSession的升级</h2><p>这里，我们基于<code>SqlSession</code>进行了一次升级，首先我们写了一个<code>BaseDao，</code>作为一个公用的接口。接口的实现是通过<code>sqlSessionTemplate。</code><br>然后我们将<code>*Mapper.xml</code>的<code>namespace</code>改为<code>*Mapper。</code>现在，我们可以直接将所有的<code>Mapper</code>接口删除，直接通过<code>dao</code>进行调用~</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul><li><p>每个模式各有特点，<code>注解版</code>适合简单快速的模式，其实像现在流行的这种微服务模式，一个微服务就会对应一个自已的数据库，多表连接查询的需求会大大的降低，会越来越适合这种模式。</p></li><li><p><code>xml</code>老传统模式比适合大型项目，可以灵活的动态生成 <code>Sql</code>，方便调整 <code>Sql ，</code>也有痛痛快快，洋洋洒洒的写 Sql 的感觉。</p></li><li><p>其他两种模式基于<code>SqlSession</code>属于低层一点，初步学习者可以练手，可以了解mybatis如何进行映射的和对应方法调用过程。</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.ityouknow.com/springboot/2016/11/06/spring-boot-mybatis.html" target="_blank" rel="noopener">Spring Boot(六)：如何优雅的使用 Mybatis</a><br>-<a href="https://www.cnblogs.com/viyoung/p/10167856.html" target="_blank" rel="noopener">Spring Boot 2.x（四）：整合Mybatis的四种方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前的大环境下，使用&lt;code&gt;Mybatis&lt;/code&gt;作为持久层框架还是占了绝大多数的，下面我们来说一下使用&lt;code&gt;Mybatis&lt;/code&gt;整合&lt;code&gt;Spring Boot&lt;/code&gt;的几种姿势。&lt;/p&gt;
&lt;h2 id=&quot;零配置注解开发&quot;&gt;&lt;a href=&quot;#零配置注解开发&quot; class=&quot;headerlink&quot; title=&quot;零配置注解开发&quot;&gt;&lt;/a&gt;零配置注解开发&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;引入依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;我们需要在&lt;code&gt;pom&lt;/code&gt;文件中添加依赖&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门快速搭建web项目</title>
    <link href="https://datou-y.github.io/posts/914fc93.html/"/>
    <id>https://datou-y.github.io/posts/914fc93.html/</id>
    <published>2019-06-15T01:21:26.064Z</published>
    <updated>2019-06-15T13:14:01.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h2><p><code>Spring Boot</code> 是由 <code>Pivotal</code> 团队提供的全新框架，其设计目的是用来简化新 <code>Spring</code> 应用的初始搭建以及开发过程。该框架使用了<code>特定的方式</code>来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 <code>Spring Boot</code> 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 <code>Maven</code> 整合了所有的 <code>Jar</code> 包，<code>Spring Boot</code> 整合了所有的框架。</p><h2 id="使用-Spring-Boot-有什么好处"><a href="#使用-Spring-Boot-有什么好处" class="headerlink" title="使用 Spring Boot 有什么好处"></a>使用 Spring Boot 有什么好处</h2><ul><li>配置 <code>web.xml</code>，加载 <code>Spring</code> 和 <code>Spring mvc</code></li><li>配置数据库连接、配置 <code>Spring</code> 事务</li><li>配置加载配置文件的读取，开启注解</li><li>配置日志文件</li><li>…</li><li>配置完成之后部署 <code>Tomcat</code> 调试</li></ul><p>现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!</p><p>但是如果使用 <code>Spring Boot</code> 呢？<br>很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！</p><p>使用 <code>Spring Boot</code> 到底有多爽，用下面这幅图来表达<br><img src="https://ae01.alicdn.com/kf/HTB1DT75cRCw3KVjSZFlq6AJkFXaO.jpg" alt></p><a id="more"></a><h2 id="官网在线搭建"><a href="#官网在线搭建" class="headerlink" title="官网在线搭建"></a>官网在线搭建</h2><ol><li><p><a href="http://start.spring.io/" target="_blank" rel="noopener">访问官网 https://start.spring.io/</a></p></li><li><p>选择构建工具 <code>Maven Project</code>、语言<code>Java</code>、<code>Spring Boot</code>版本 <code>Project Metadata</code> 工程基本信息</p></li></ol><p><img src="https://ae01.alicdn.com/kf/HTB1AtQ1cLWG3KVjSZFg762TspXa2.png" alt></p><ol start="3"><li><p>点击 <code>Generate Project</code>下载项目压缩包</p></li><li><p>解压后，使用 <code>Idea</code> 导入项目，<code>File -&gt; New -&gt; Model from Existing Source.. -&gt;</code>选择解压后的文件夹 -&gt;<code>OK，</code>选择 <code>Maven 一路 Next，OK done!</code></p></li></ol><h2 id="通过Intellij-IDEA搭建"><a href="#通过Intellij-IDEA搭建" class="headerlink" title="通过Intellij IDEA搭建"></a>通过Intellij IDEA搭建</h2><ol><li>选择 <code>File -&gt; New —&gt; Project…</code> 弹出新建项目的框</li><li>选择 <code>Spring Initializr，Next</code> 也会出现上述类似的配置界面，Idea 帮我们做了集成</li><li>填写相关内容后，点击 <code>Next</code> 选择依赖的包再点击 <code>Next</code>，最后确定信息无误点击 <code>Finish</code></li><li>如果使用的是 <code>Eclipse，</code> <code>Import -&gt; Existing Maven Projects -&gt; Next -&gt;</code>选择解压后的文件夹 -&gt; <code>Finsh，OK done!</code></li></ol><h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2><p><img src="https://ae01.alicdn.com/kf/HTB1FEo7cR1D3KVjSZFy762uFpXad.png" alt></p><p>如上图所示，Spring Boot 的基础结构共三个文件:</p><ul><li><code>src/main/java</code> 程序开发以及主程序入口</li><li><code>src/main/resources</code> 配置文件</li><li><code>src/test/java</code> 测试程序</li></ul><p>另外， <code>Spring Boot</code> 建议的目录结果如下：<br><code>root package</code> 结构：<code>com.example.myproject</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- model</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure></p><ol><li><code>Application.java</code> 建议放到根目录下面,主要用于做一些框架配置</li><li><code>model</code> 目录主要用于实体与数据访问层（<code>Repository</code>）</li><li><code>service</code> 层主要是业务类代码</li><li><code>controller</code> 负责页面访问控制</li></ol><p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改<br>最后，启动 Application main 方法，至此一个 Java 项目搭建好了！</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><code>pom.xml</code>中添加支持<code>web</code>的模块：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p><code>pom.xml</code> 文件中默认有两个模块:<br><code>spring-boot-starter</code> ：核心模块，包括自动配置支持、日志和 <code>YAML</code><br><code>spring-boot-starter-test</code> ：测试模块，包括 <code>JUnit、Hamcrest、Mockito</code><br><code>spring-boot-starter-web</code> 自动依赖了 <code>spring-boot-starter</code>加了<code>web</code>模块后可以去掉<code>spring-boot-starter</code>模块</p><ol start="2"><li>编写 Controller 内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@RestController</code> 的意思就是 <code>Controller</code> 里面的方法都以 <code>json</code> 格式输出，不用再写什么 <code>jackjson</code> 配置的了！</p><ol start="3"><li>启动主程序，打开浏览器访问 <code>http://localhost:8080/hello</code>，就可以看到效果了，有木有很简单！</li></ol><p><div class="tip"><a href="https://github.com/daTou-Y/spring-boot-examples/tree/master/spring-boot-helloWorld" target="_blank" rel="noopener">GitHub示例代码</a><div></div></div></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_27317475/article/details/81119098" target="_blank" rel="noopener">SpringBoot入门，快速搭建简单Web应用环境</a></li><li><a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html" target="_blank" rel="noopener">Spring Boot(一)：入门篇</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Spring-Boot&quot;&gt;&lt;a href=&quot;#什么是Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring Boot&quot;&gt;&lt;/a&gt;什么是Spring Boot&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 是由 &lt;code&gt;Pivotal&lt;/code&gt; 团队提供的全新框架，其设计目的是用来简化新 &lt;code&gt;Spring&lt;/code&gt; 应用的初始搭建以及开发过程。该框架使用了&lt;code&gt;特定的方式&lt;/code&gt;来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 &lt;code&gt;Spring Boot&lt;/code&gt; 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 &lt;code&gt;Maven&lt;/code&gt; 整合了所有的 &lt;code&gt;Jar&lt;/code&gt; 包，&lt;code&gt;Spring Boot&lt;/code&gt; 整合了所有的框架。&lt;/p&gt;
&lt;h2 id=&quot;使用-Spring-Boot-有什么好处&quot;&gt;&lt;a href=&quot;#使用-Spring-Boot-有什么好处&quot; class=&quot;headerlink&quot; title=&quot;使用 Spring Boot 有什么好处&quot;&gt;&lt;/a&gt;使用 Spring Boot 有什么好处&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置 &lt;code&gt;web.xml&lt;/code&gt;，加载 &lt;code&gt;Spring&lt;/code&gt; 和 &lt;code&gt;Spring mvc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置数据库连接、配置 &lt;code&gt;Spring&lt;/code&gt; 事务&lt;/li&gt;
&lt;li&gt;配置加载配置文件的读取，开启注解&lt;/li&gt;
&lt;li&gt;配置日志文件&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;li&gt;配置完成之后部署 &lt;code&gt;Tomcat&lt;/code&gt; 调试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍!&lt;/p&gt;
&lt;p&gt;但是如果使用 &lt;code&gt;Spring Boot&lt;/code&gt; 呢？&lt;br&gt;很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;Spring Boot&lt;/code&gt; 到底有多爽，用下面这幅图来表达&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1DT75cRCw3KVjSZFlq6AJkFXaO.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://datou-y.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>java中数据类型分类</title>
    <link href="https://datou-y.github.io/posts/2b16cdcb.html/"/>
    <id>https://datou-y.github.io/posts/2b16cdcb.html/</id>
    <published>2019-06-13T13:04:29.649Z</published>
    <updated>2019-06-13T13:17:55.523Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Na0AcRGE3KVjSZFh763kaFXaM.png" alt><br><a id="more"></a></p><h2 id="区别表"><a href="#区别表" class="headerlink" title="区别表"></a>区别表</h2><p><img src="https://ae01.alicdn.com/kf/HTB1UMFxcL1H3KVjSZFB762SMXXal.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Na0AcRGE3KVjSZFh763kaFXaM.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql查询结果去除重复数据</title>
    <link href="https://datou-y.github.io/posts/e1a86da4.html/"/>
    <id>https://datou-y.github.io/posts/e1a86da4.html/</id>
    <published>2019-06-12T13:57:50.756Z</published>
    <updated>2019-06-13T09:52:43.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> st.stu_name <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.stu_name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删选出重复数据</span></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> A <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;distinct去重&quot;&gt;&lt;a href=&quot;#distinct去重&quot; class=&quot;headerlink&quot; title=&quot;distinct去重&quot;&gt;&lt;/a&gt;distinct去重&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;distinct&lt;/span&gt; st.stu_name &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student st&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; st.stu_name &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;group-by&quot;&gt;&lt;a href=&quot;#group-by&quot; class=&quot;headerlink&quot; title=&quot;group by&quot;&gt;&lt;/a&gt;group by&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 删选出重复数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;having&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*)&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql查询字段为null的处理</title>
    <link href="https://datou-y.github.io/posts/8a034c1e.html/"/>
    <id>https://datou-y.github.io/posts/8a034c1e.html/</id>
    <published>2019-06-12T10:43:41.101Z</published>
    <updated>2019-06-12T14:15:11.116Z</updated>
    
    <content type="html"><![CDATA[<ol><li>通过<code>is (not) null</code>进行<code>where</code>条件判断处理</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> A <span class="keyword">where</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过 <code>case when</code>进行逻辑语句上的判断<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">case</span></span><br><span class="line">      <span class="keyword">when</span> a <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span></span><br><span class="line">      <span class="string">''</span></span><br><span class="line">      <span class="keyword">when</span> a=<span class="string">"a"</span> <span class="keyword">then</span></span><br><span class="line">      <span class="string">"b"</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="string">"idbs"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    ) <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li>通过<code>IFNULL</code>函数进行判断<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>(a,<span class="string">"b"</span>) <span class="keyword">from</span> A</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>ifnull(a,&quot;b&quot;)</code>第一个参数是你要查询字段，第二个是字段为<code>null</code>是的值</li></ul><ol start="4"><li><code>null</code>值概念</li></ol><ul><li>空值是不占用空间的。</li><li><code>mysql</code>中的<code>NULL</code>其实是占用空间的,打个比方来说，你有一个杯子，空值代表杯子是真空的，<code>NULL</code>代表杯子中装满了空气，虽然杯子看起来都是空的，但是区别是很大的</li><li><code>NOT NULL</code> 的字段是不能插入<code>“NULL”</code>的，只能插入<code>“空值”</code></li></ul><ol start="5"><li>总结</li></ol><ul><li>在进行<code>count()</code>统计某列的记录数的时候，如果采用的<code>NULL</code>值，系统会自动忽略掉，但是空值是会进行统计到其中的。</li><li>判断<code>NULL</code> 用<code>IS NULL</code> 或者 <code>IS NOT NULL</code>, SQL语句函数中可以使用<code>ifnull()</code>函数来进行处理，判断<code>空字符</code>用<code>=&#39;&#39;</code>或者 <code>&lt;&gt;&#39;&#39;</code>来进行处理</li><li>对于<code>MySQL</code>特殊的注意事项，对于<code>timestamp</code>数据类型，如果往这个数据类型插入的列插入<code>NULL</code>值，则出现的值是<code>当前系统时间</code>。插入<code>空值</code>，则会出现 <code>0000-00-00 00:00:00</code><br>对于<code>空值</code>的判断到底是使用<code>is null</code> 还是<code>=&#39;&#39;</code> 要根据实际业务来进行区分。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/WNsshssm/article/details/79558452" target="_blank" rel="noopener">mysql查询字段为null时，返回空字符串</a></li><li><a href="https://blog.csdn.net/huanghanqian/article/details/85381552" target="_blank" rel="noopener">MySQL判断字段是否为null</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;is (not) null&lt;/code&gt;进行&lt;code&gt;where&lt;/code&gt;条件判断处理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;通过 &lt;code&gt;case when&lt;/code&gt;进行逻辑语句上的判断&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; a=&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;idbs&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; A&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>java全能最新自己面试企业真题总结</title>
    <link href="https://datou-y.github.io/posts/4112469.html/"/>
    <id>https://datou-y.github.io/posts/4112469.html/</id>
    <published>2019-06-12T09:44:46.521Z</published>
    <updated>2019-06-12T10:20:52.384Z</updated>
    
    <content type="html"><![CDATA[<p>这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。<br><img src="https://ae01.alicdn.com/kf/HTB1Kq2ccA5E3KVjSZFCq6zuzXXad.jpg" alt><br><a id="more"></a></p><div class="tip"><br>所有题目都在博客文章中有涉及<br></div><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ol><li><code>List</code>，<code>Set</code>，<code>Map</code>的区别</li><li><code>ArrayList</code>,<code>LinkList</code>,<code>Vector</code>区别</li><li><code>HashMap</code>,<code>HashTable</code>的区别</li><li><code>List</code>排序</li><li><code>List</code>去重</li><li><code>List</code>进行遍历修改操作是否会报错</li><li><code>List</code>数据的获取</li><li>数组排序</li><li><code>String</code>,<code>StringBuild</code>,<code>StringBuffer</code>区别</li><li><code>jdk1.8</code>新特性</li><li><code>Exception</code> 和<code>Error</code>区别</li><li>线程同步，与线程通信</li><li>java基本数据类型</li><li>生产指定的随机数</li><li>表单重复提交</li><li>单点登录</li><li><code>split(&quot;|&quot;)</code>和<code>split(&quot;//|&quot;)</code>区别</li><li><code>final</code>,<code>finaly</code>,<code>finalize</code>区别</li><li><code>overload</code>和<code>override</code>区别<code>overrided</code>返回值可以改变吗</li><li>如何实现<code>HashMap</code>同步或者是<code>ArrayList</code>同步</li><li><code>抽象类</code>，和<code>接口</code>的区别</li><li><code>==</code>和<code>equal</code>区别</li></ol><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol><li><code>mysql</code>数据去重</li><li>给你题目手写<code>mysql</code>语句</li><li>mysql<code>日期函数</code></li><li>mysql优化</li><li>mysql中<code>union</code>和<code>union all</code>区别</li><li>mysql中<code>in</code> 和 <code>exists</code>区别</li><li>mysql<code>索引</code></li><li>事物特性</li><li>判断什么情况下索引会失效</li><li>使用函数表达式会影响效率吗，会破坏索引吗</li><li>如何获取自增主键</li><li>如何获取重复的数据</li><li>如何对数据库<code>null</code>值处理</li></ol><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ol><li>项目中什么时候用到<code>redis</code></li><li><code>redis</code>原理</li><li>项目中用到<code>redis</code>那些类型</li></ol><h2 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h2><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><ol><li>项目中有没有遇到数据比较多的时候，如何处理的</li><li>项目中高并发解决</li></ol><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><ol><li>介绍自己项目经验，和做过的项目</li><li>会就简历上有的项目进行技术点提问</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Kq2ccA5E3KVjSZFCq6zuzXXad.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="面试" scheme="https://datou-y.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析MySQL中exists与in的使用和区别</title>
    <link href="https://datou-y.github.io/posts/df7b0a0e.html/"/>
    <id>https://datou-y.github.io/posts/df7b0a0e.html/</id>
    <published>2019-06-11T12:46:01.117Z</published>
    <updated>2019-06-11T14:20:49.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是exists"><a href="#什么是exists" class="headerlink" title="什么是exists"></a>什么是exists</h2><p>exists表示存在，它常常和子查询配合使用，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">      <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> score sc <span class="keyword">where</span> sc.stu_id= st.stu_id);</span><br></pre></td></tr></table></figure><ul><li><code>exists</code>用于检查<code>子查询</code>是否至少会返回一行数据,如果返回空集<code>exists</code>返回值就是<code>false</code>，否则就是<code>true</code>,该子查询实际不返还任何数据。</li><li><code>exists</code>对外表用<code>loop</code>逐条查询，每次查询都会查看<code>exists</code>的条件语句</li><li>当子查询返回为真时，则外层查询语句将进行查询</li><li>当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。<a id="more"></a><h2 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h2></li><li>与<code>exists</code>条件相反，就是当<code>exists</code>结果集有反会值是时候条件为<code>false</code>否则为<code>true</code></li></ul><h2 id="in-查询"><a href="#in-查询" class="headerlink" title="in 查询"></a>in 查询</h2><ul><li><p>in查询相当于多个or条件的叠加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id=<span class="number">1</span> <span class="keyword">or</span> st.stu_id=<span class="number">2</span> <span class="keyword">or</span> st.stu_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>not in</code>与<code>in</code>相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment"># 等效于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id!=<span class="number">1</span> <span class="keyword">and</span> st.stu_id!=<span class="number">2</span> <span class="keyword">and</span> st.stu_id!=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="in-子查询"><a href="#in-子查询" class="headerlink" title="in 子查询"></a>in 子查询</h2><ul><li><code>in</code>查询的子条件返回结果必须只有一个字段</li><li><code>in()</code>语句只会执行一次，会将符合子查询条件的记录全都查出来，假设结果集为B，共有m条记录并且缓存起来，然后在将子查询条件的结果集分解成m个，再进行m次查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure><ul><li>以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将<code>A</code>表的记录加入结果集中,直到遍历完A表的所有记录</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/ye411685846/article/details/61196162" target="_blank" rel="noopener">浅析MySQL中exists与in的使用</a></li><li><a href="https://blog.csdn.net/cool_wayen/article/details/79614806" target="_blank" rel="noopener">mysql中exit和in的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是exists&quot;&gt;&lt;a href=&quot;#什么是exists&quot; class=&quot;headerlink&quot; title=&quot;什么是exists&quot;&gt;&lt;/a&gt;什么是exists&lt;/h2&gt;&lt;p&gt;exists表示存在，它常常和子查询配合使用，&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student st &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; score sc &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; sc.stu_id= st.stu_id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;用于检查&lt;code&gt;子查询&lt;/code&gt;是否至少会返回一行数据,如果返回空集&lt;code&gt;exists&lt;/code&gt;返回值就是&lt;code&gt;false&lt;/code&gt;，否则就是&lt;code&gt;true&lt;/code&gt;,该子查询实际不返还任何数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exists&lt;/code&gt;对外表用&lt;code&gt;loop&lt;/code&gt;逐条查询，每次查询都会查看&lt;code&gt;exists&lt;/code&gt;的条件语句&lt;/li&gt;
&lt;li&gt;当子查询返回为真时，则外层查询语句将进行查询&lt;/li&gt;
&lt;li&gt;当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="exists" scheme="https://datou-y.github.io/tags/exists/"/>
    
      <category term="in" scheme="https://datou-y.github.io/tags/in/"/>
    
  </entry>
  
  <entry>
    <title>mysql union 和union all使用</title>
    <link href="https://datou-y.github.io/posts/7bb7ade4.html/"/>
    <id>https://datou-y.github.io/posts/7bb7ade4.html/</id>
    <published>2019-06-11T11:58:04.162Z</published>
    <updated>2019-06-11T12:45:21.743Z</updated>
    
    <content type="html"><![CDATA[<p>在数据库中，<code>UNION</code>和<code>UNION ALL</code>关键字都是将两个结果集合并为一个，<code>UNION</code>用的比较多<code>union all</code>是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 </p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>[SQL 语句 1]<br>    UNION<br>[SQL 语句 2]</p><p>[SQL 语句 1]<br>   UNION ALL<br>[SQL 语句 2]<br><a id="more"></a></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>对重复结果的处理：<code>UNION</code>在进行表链接后会筛选掉重复的记录，<code>Union All</code>不会去除重复<br>记录</li><li>对排序的处理：<code>Union</code>将会按照字段的顺序进行排序；<code>UNION ALL</code>只是简单的将两个结果合并后就返回</li><li>从效率上说，<code>UNION ALL</code> 要比<code>UNION</code>快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用<code>UNION ALL</code>。</li></ul><div class="tip"><br>如果您想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/youpai/p/9473231.html" target="_blank" rel="noopener">mysql中union与union all的区别</a></li><li><a href="https://www.cnblogs.com/hanyouchun/p/3688070.html" target="_blank" rel="noopener">MySQL中UNION和UNION ALL的使用</a></li><li><a href="https://www.liangzl.com/get-article-detail-37503.html" target="_blank" rel="noopener">mysql union 和union all使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据库中，&lt;code&gt;UNION&lt;/code&gt;和&lt;code&gt;UNION ALL&lt;/code&gt;关键字都是将两个结果集合并为一个，&lt;code&gt;UNION&lt;/code&gt;用的比较多&lt;code&gt;union all&lt;/code&gt;是直接连接，取到得是所有值，记录可能有重复   union 是取唯一值，记录没有重复 &lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;[SQL 语句 1]&lt;br&gt;    UNION&lt;br&gt;[SQL 语句 2]&lt;/p&gt;
&lt;p&gt;[SQL 语句 1]&lt;br&gt;   UNION ALL&lt;br&gt;[SQL 语句 2]&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="union" scheme="https://datou-y.github.io/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>mysql中聚合函数日期函数使用详细和实例</title>
    <link href="https://datou-y.github.io/posts/74138ad2.html/"/>
    <id>https://datou-y.github.io/posts/74138ad2.html/</id>
    <published>2019-06-08T02:14:41.114Z</published>
    <updated>2019-06-11T12:11:10.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p><code>mysql</code> 数据库中 <code>count()</code> 函数是统计查询结果中的行数。列如下面的<code>empy</code>表</p><p><img src="https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png" alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://ae01.alicdn.com/kf/HTB1902abW5s3KVjSZFN763D3FXaO.png" alt></p><div class="tip"><br>注意的是，count 会忽略掉 NULL 的结果， 所以 count(字段名) 这样使用的话，如果字段中包含为null的结果，将导致查询结果不准确，列如：<br></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1.sq4b25G3KVjSZPx762I3XXaT.png" alt></p><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p><code>mysql</code> 中 <code>sum()</code> 函数用于计算某一字段中所有行的数值之和（ <code>sum 求和时会对 null 进行过滤，不计算</code>）,如果对无法计算的列进行<code>sum()</code>sum 函数的返回值为 <code>0</code>,如果没有符合条件的行，<code>sum()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为0</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为32</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><p><code>mysql</code> 中 <code>max()</code> 函数用于计算某一字段中所有行的最大值,如果对无法比较的列进行<code>max()</code>max 函数的返回值为 <code>xxx</code>,如果没有符合条件的行，<code>max()</code>将返回<code>null</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回结果为xxx</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">name</span>) <span class="keyword">from</span> empy;</span><br><span class="line">返回结果为4</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy</span><br><span class="line">返回结果为<span class="literal">null</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(dept_id) <span class="keyword">from</span> empy <span class="keyword">where</span> dept_id=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><p><code>mysql</code>中 <code>min()</code>函数用于计算某一字段中所有行的最小值</p><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><ul><li>返回指定字段的数据的平均值</li><li><code>avg()</code> 通过对表中行数计数并计算指定字段的数据总和，求得该字段的平均值。</li></ul><h2 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h2><ul><li>获得当前日期+时间（<code>date + time</code>）函数：<code>now()</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">now</span>(), <span class="keyword">sleep</span>(<span class="number">3</span>), <span class="keyword">now</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="sysdate"><a href="#sysdate" class="headerlink" title="sysdate()"></a>sysdate()</h2><ul><li><code>sysdate()</code> 日期时间函数跟 <code>now()</code>类似，不同之处在于：<code>now()</code> 在执行开始时值就得到了<code>sysdate()</code>在函数执行时动态得到值</li><li><code>sysdate()</code> 日期时间函数，一般情况下很少用到。</li></ul><h2 id="current-timestamp"><a href="#current-timestamp" class="headerlink" title="current_timestamp()"></a>current_timestamp()</h2><ul><li>获得当前时间戳函数<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">current_timestamp</span>, <span class="keyword">current_timestamp</span>();</span><br></pre></td></tr></table></figure></li></ul><h2 id="date-format-date-format"><a href="#date-format-date-format" class="headerlink" title="date_format(date,format)"></a>date_format(date,format)</h2><ul><li>日期/时间转换为字符串<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">date_format</span>(<span class="string">'2008-08-08 22:23:01'</span>, <span class="string">'%Y%m%d%H%i%s'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="str-to-date-str-format"><a href="#str-to-date-str-format" class="headerlink" title="str_to_date(str,format)"></a>str_to_date(str,format)</h2><ul><li>可以把一些杂乱无章的字符串转换为日期格式也可以转换为时间<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/2008'</span>, <span class="string">'%m/%d/%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08/09/08'</span> , <span class="string">'%m/%d/%y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008'</span>, <span class="string">'%m.%d.%Y'</span>); <span class="comment">-- 2008-08-09</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08:09:30'</span>, <span class="string">'%h:%i:%s'</span>); <span class="comment">-- 08:09:30</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">str_to_date</span>(<span class="string">'08.09.2008 08:09:30'</span>, <span class="string">'%m.%d.%Y %h:%i:%s'</span>); <span class="comment">--</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/progor/p/8832663.html" target="_blank" rel="noopener">mysql之常用函数</a></li><li><a href="https://www.cnblogs.com/ggjucheng/p/3352280.html" target="_blank" rel="noopener"> MySQL 获得当前日期时间 函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;count&quot;&gt;&lt;a href=&quot;#count&quot; class=&quot;headerlink&quot; title=&quot;count&quot;&gt;&lt;/a&gt;count&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mysql&lt;/code&gt; 数据库中 &lt;code&gt;count()&lt;/code&gt; 函数是统计查询结果中的行数。列如下面的&lt;code&gt;empy&lt;/code&gt;表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1z3W4b21G3KVjSZFk761K4XXa8.png&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; empy;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="聚合函数" scheme="https://datou-y.github.io/tags/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>java中随机数使用</title>
    <link href="https://datou-y.github.io/posts/7b083b8f.html/"/>
    <id>https://datou-y.github.io/posts/7b083b8f.html/</id>
    <published>2019-06-07T09:32:12.122Z</published>
    <updated>2019-06-07T10:31:35.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机数创建"><a href="#随机数创建" class="headerlink" title="随机数创建"></a>随机数创建</h2><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line">System.out.println(timeMillis);</span><br></pre></td></tr></table></figure><ul><li><code>long currentTimeMillis()</code> 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>  <span class="keyword">long</span>  timeMillis=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( timeMillis % <span class="number">1000</span> );</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要除以<code>100</code>获取<code>[0-1000]</code>就除以<code>1000</code>类推即可</li></ul><a id="more"></a><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure><ul><li><code>double Math.random()</code>来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的<code>double</code>值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line"><span class="keyword">int</span> i=(<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li>若要获取<code>int</code>类型的整数，只需要将上面的结果转成<code>int</code>类型即可。比如，<code>获取[0, 100)</code>之间的<code>int</code>整数要乘以<code>100</code>获取<code>[0-1000]</code>就乘以<code>1000</code>类推即可</li></ul><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line">Random r=<span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//指定值构造方法</span></span><br><span class="line">Random rs=<span class="keyword">new</span> Random(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt(<span class="number">100</span>);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><ul><li><code>int r.nextInt(100)</code>获取[0, 100)之间的<code>int</code>整数Random支持的随机值类型包括：boolean, byte, int, long, float, double等</li></ul><h2 id="Random常用方法"><a href="#Random常用方法" class="headerlink" title="Random常用方法"></a>Random常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java 的随机数测试程序。共3种获取随机数的方法：</span></span><br><span class="line"><span class="comment"> *   (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。</span></span><br><span class="line"><span class="comment"> *   (02)、通过Math.random()返回一个0到1之间的double值。</span></span><br><span class="line"><span class="comment"> *   (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> kuiwu-wang@163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过System的currentTimeMillis()返回随机数</span></span><br><span class="line">        testSystemTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Math的random()返回随机数</span></span><br><span class="line">        testMathRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建“种子为1000”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 1st Random(1000)"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(<span class="number">1000</span>), <span class="string">" 2nd Random(1000)"</span>);</span><br><span class="line">        <span class="comment">// 新建“默认种子”的Random对象，并通过该种子去测试Random的API</span></span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 1st Random()"</span>);</span><br><span class="line">        testRandomAPIs(<span class="keyword">new</span> Random(), <span class="string">" 2nd Random()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-01：测试System的currentTimeMillis()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSystemTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 通过l获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)( l % <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- System.currentTimeMillis() ----\n l=%s i=%s\n"</span>, l, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-02：测试Math的random()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMathRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> d = Math.random();</span><br><span class="line">        <span class="comment">// 通过d获取一个[0, 100)之间的整数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>)(d*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- Math.random() ----\n d=%s i=%s\n"</span>, d, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回随机数-03：测试Random的API</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAPIs</span><span class="params">(Random random, String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_LEN = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机的boolean值</span></span><br><span class="line">        <span class="keyword">boolean</span> b = random.nextBoolean();</span><br><span class="line">        <span class="comment">// 获取随机的数组buf[]</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_LEN];</span><br><span class="line">        random.nextBytes(buf);</span><br><span class="line">        <span class="comment">// 获取随机的Double值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">double</span> d = random.nextDouble();</span><br><span class="line">        <span class="comment">// 获取随机的float值，范围[0.0, 1.0)</span></span><br><span class="line">        <span class="keyword">float</span> f = random.nextFloat();</span><br><span class="line">        <span class="comment">// 获取随机的int值</span></span><br><span class="line">        <span class="keyword">int</span> i1 = random.nextInt();</span><br><span class="line">        <span class="comment">// 获取随机的[0,100)之间的int值</span></span><br><span class="line">        <span class="keyword">int</span> i2 = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 获取随机的高斯分布的double值</span></span><br><span class="line">        <span class="keyword">double</span> g = random.nextGaussian();</span><br><span class="line">        <span class="comment">// 获取随机的long值</span></span><br><span class="line">        <span class="keyword">long</span> l = random.nextLong();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"\n---- %s ----\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=["</span>,</span><br><span class="line">                title, b, d, f, i1, i2, g, l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> bt:buf) </span><br><span class="line">            System.out.printf(<span class="string">"%s, "</span>, bt);</span><br><span class="line">        System.out.println(<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/skywang12345/p/3341423.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3341423.html</a></li><li><a href="https://www.cnblogs.com/blogxjc/p/9687297.html" target="_blank" rel="noopener">java的三种随机数生成方式</a></li><li><a href="https://www.cnblogs.com/dyx2018/p/9189700.html" target="_blank" rel="noopener">Java 生成随机数</a></li><li><a href="https://www.cnblogs.com/cx-code/p/10005915.html" target="_blank" rel="noopener">java随机生成6位随机数 5位随机数 4位随机数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;随机数创建&quot;&gt;&lt;a href=&quot;#随机数创建&quot; class=&quot;headerlink&quot; title=&quot;随机数创建&quot;&gt;&lt;/a&gt;随机数创建&lt;/h2&gt;&lt;h3 id=&quot;currentTimeMillis&quot;&gt;&lt;a href=&quot;#currentTimeMillis&quot; class=&quot;headerlink&quot; title=&quot;currentTimeMillis()&quot;&gt;&lt;/a&gt;currentTimeMillis()&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(timeMillis);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;long currentTimeMillis()&lt;/code&gt; 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;  timeMillis=System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)( timeMillis % &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;若要获取&lt;code&gt;int&lt;/code&gt;类型的整数，只需要将上面的结果转成&lt;code&gt;int&lt;/code&gt;类型即可。比如，&lt;code&gt;获取[0, 100)&lt;/code&gt;之间的&lt;code&gt;int&lt;/code&gt;整数要除以&lt;code&gt;100&lt;/code&gt;获取&lt;code&gt;[0-1000]&lt;/code&gt;就除以&lt;code&gt;1000&lt;/code&gt;类推即可&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="random" scheme="https://datou-y.github.io/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>java中进程和线程</title>
    <link href="https://datou-y.github.io/posts/c206fba0.html/"/>
    <id>https://datou-y.github.io/posts/c206fba0.html/</id>
    <published>2019-06-06T13:53:01.653Z</published>
    <updated>2019-06-07T11:47:19.386Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg" alt><br><a id="more"></a></p><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><blockquote><p><code>run()</code>方法是执行的线程体，<code>start()</code>用于启动线程</p></blockquote><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><ul><li>继承<code>Thread</code>类的类就是一个线程类，通过创建当前类的实例，来创建多个线程</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span>   <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 线程体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">"---&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><ul><li>由于<code>Runnable</code>接口没有定义<code>start</code>方法，而一定的规定要求，必须通过<code>Thread.start</code><br>方法来启动继承；</li><li><code>Thread</code>类中有 <code>【Thread（Runnable target）】</code>构造方法，可以接收<code>Runnable接口</code><br>的参数</li><li>于是我们可以实例化<code>Threda</code>类，将<code>Runnable</code>对象交给<code>Thread</code>类处理并调用其<code>start()</code>方法启动多线程</li></ul><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ul><li><code>Runnable</code>接口实现的多线程不能返回操作结果；所以提供了一个新的多线程接口——<code>Callable接口【java.util.concurrent 包】</code></li><li><code>call()</code>方法在 执行主要功能后，可以返回结果，而返回结果的类型有<code>Calable</code>接口泛型来决定。</li><li><code>Callable接口</code>的<code>call()</code>是线程执行体，代替原来<code>run()</code>方法可以有返回值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* Thread类中并没有接收Callabel对象的构造方法，所以无法通过start()来启动多线程</span></span><br><span class="line"><span class="comment">* 但是Java提供java.util.concurrent。FutureTask&lt;V&gt; 类 ， </span></span><br><span class="line"><span class="comment">* 在FutureTask类的定义结构如下：</span></span><br><span class="line"><span class="comment">* public class FutureTask&lt;V&gt; extends Object implements Future&lt;V&gt; , Runnable</span></span><br><span class="line"><span class="comment">* 类中有如下的构造方法：</span></span><br><span class="line"><span class="comment">* public FutureTask(Callable&lt;V&gt; callable)</span></span><br><span class="line"><span class="comment">* FutureTask类接收Callable接口对象。目的就是：取得call()方法的返回结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OKOK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread); <span class="comment">// 目的是为了接收call返回值</span></span><br><span class="line">FutureTask&lt;String&gt; task1 = <span class="keyword">new</span> FutureTask&lt;String&gt;(thread1);</span><br><span class="line"><span class="comment">// FutureTask是Runnable接口子类，所以可以使用Thread类的构造来接收task对象</span></span><br><span class="line"><span class="keyword">new</span> Thread(task1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(task).start();</span><br><span class="line"><span class="comment">// 多线程执行完毕后，依靠FutureTask的父接口 Future中的get()方法完成。</span></span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task.get());</span><br><span class="line">System.out.println(<span class="string">"A---&gt;"</span> + task1.get());</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="tip"><br>使用Runnable接口与Thread类相比之下，解决了Thrad类单继承局限的问题<br></div><ul><li>数据共享的不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line">MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"B"</span>);</span><br><span class="line">MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyThread thread = <span class="keyword">new</span> MyThread(<span class="string">"A"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread).start();</span><br></pre></td></tr></table></figure><p>两个程序例子，都是实现三个线程的启动；不同的地方在于，<code>Thread</code>的三个线程使用的是三个不同的实例对象如<code>代码块一</code>，而<code>Runnable</code>的三个线程均是通过<code>实例化Thread</code>类调用<code>Start()</code>方法对<code>同一实例对象</code>进行三个线程的操作如<code>代码块二</code>。<code>Runnable</code>更好的实现了同一数据共享（当然Thread也可以，只是没有Runnable简单）</p><p>  两者的区别</p><p>　　Thread类是Runnable接口的一个子类，使用Runnable接口实现多线程可以避免单继承的局限性</p><p>　　Runnable接口实现的多线程可以比Thrad类实现的多线程更加清楚的描述</p><h2 id="多线程的常用操作方法"><a href="#多线程的常用操作方法" class="headerlink" title="多线程的常用操作方法"></a>多线程的常用操作方法</h2><h3 id="线程的命名与获得"><a href="#线程的命名与获得" class="headerlink" title="线程的命名与获得"></a>线程的命名与获得</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName()</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = A"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = B"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread,<span class="string">"线程 = C"</span>).start();</span><br><span class="line">thread.setName(<span class="string">"线程A"</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Thread.currentThread().getName()</code> 获取当前线程的名称，如果自己没有设置名称默认的名称为<code>Thread-0</code>,<code>Thread-1</code>依次类推</li><li><code>new Thread(thread,&quot;线程A&quot;).start()</code> 设置线程名称适用于实现接口方式的线程创建</li><li><code>thread.setName(&quot;线程A&quot;)</code> 设置线程的名称，适用于继承Thread类的线程创建</li></ul><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sleep(long millis)</code>  线程睡眠 <code>millis</code> 毫秒</li><li><code>sleep(long millis, int nanos)</code>  线程睡眠 <code>millis</code> 毫秒 + <code>nanos</code> 纳秒</li><li>因为<code>sleep()</code>是静态方法，所以最好的调用方法就是 <code>Thread.sleep()</code></li><li>线程的<code>sleep</code>方法应该写在线程的run()方法里，就能让对应的线程睡眠,<code>sleep</code>调用无关调用的线程对象，在那里调用那个线程就睡眠</li><li><code>sleep()</code>方法导致了程序暂停执行指定的时间，让出<code>cpu</code>给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。<br>在调用<code>sleep()</code>方法的过程中，线程不会释放对象锁资源</li></ul><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>优先级越高，越有可能先执行；Thread类中设置了两个方法：</p><blockquote><p>改变线程优先级：    public final void setPriority(int newPriority) ;<br>返回线程优先级：    public final void getPriority() ;</p></blockquote><p><div class="tip"><br>java中线程优先级效果不是特别明显所以不使用一般</div></p><div><h2 id="线程的同步与死锁"><a href="#线程的同步与死锁" class="headerlink" title="线程的同步与死锁"></a>线程的同步与死锁</h2><p>同步指的是<code>多个线程访问同一资源</code>时的问题；即多个线程对象操作同一个对象资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/HTB1OPJgb21G3KVjSZFk761K4XXaL.png" alt><br>此时，上例没有出现任何问题！<br>但在代码<code>run()</code>的for中加入延迟<code>【Thread.sleep();】</code>就会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://ae01.alicdn.com/kf/HTB1h1JpbYus3KVjSZKb760qkFXa8.png" alt></p><ul><li>可以明显的发现，结果中出现了相同值（意外值）；这就是“不同步”的状况【异步操作】。<br>上例代码的想法是：从同一个资源取得当前的剩余的点数，但是由于<code>延迟</code>的存在，后续的线程不会等待之前的线程，会直接的进入，导致剩余值没有得到及时的刷新,而出现问题</li></ul><blockquote><p>同步的操作<br>所谓同步就是指<code>多个线程操作同一时间只能有一个线程进入同一个空间运行</code>，其他线程要等待此线程完成之后才可以继续执行。而之前的不同步【或称为异步操作】，则是多个线程可以同一时间进入同一个空间运行。</p></blockquote><ul><li><code>java</code>中实现线程得同步则使用：synchronized 关键字。使用方法：1、同步代码块；2、<code>[线程]同步方法；</code></li></ul><p><div class="tip"><br>Java 四种代码块：<br>    普通代码块、构造块、静态块、<code>同步块</code></div></p><div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例代码实现得则是<code>“同步块”</code>，利用<code>synchronized</code>关键字使得会出现异常行代码被关键字锁住，每一次执行只可以进入一个对象，<code>实现同步</code>需要接受一个<code>this</code>参数表示当前线程对象<br> 所有（多个）线程，只有当里面得线程结束了，自己才可以进入同步块【一次只可以进入一个对象】<br>但是有人翻译同步代码块比较<code>“粗糙”</code>不美观,所以还有另外得<code>【同步方法】</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + <span class="keyword">this</span>.tick--);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>上例代码则是放弃了<code>同步块</code>，使用<code>同步方法</code>实现“同步”同步方法得定义结构依旧是使用synchronized关键字在run()方法中，使用<code>this</code>方法调用同步方法。</p></li><li><p>异步操作得速度高于同步操作，而同步操作时得数据安全性高于异步操作时得数据安全性；】</p></li><li><p><code>死锁：</code>所谓的同步就是一个线程对象等待另外一个线程对象执行完毕后的操作形式；线程同步过多，就有可能造成死锁。也就是多个线程条件互斥进入等待造成死锁</p></li><li>死锁是程序开发中，由于某种逻辑上的错误所造成的问题；</li></ul><p>同步产生的问题：<br>多个线程访问同一空间资源是一定要处理好同步，可以使用同步代码块或同步方法解决；<br>但是过多的同步，有可能造成“死锁”</p><ul><li>最简单的同步或异步操作，就是通过 <code>synchronized</code> 关键字实现。</li><li><code>死锁是一种不定、不可预的状态</code></li></ul><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><h2 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h2><p><code>java</code>中的<code>ThreadLocal</code>类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个<code>ThreadLocal</code>变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的<code>ThreadLocal</code>变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; tick=<span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tick.get()&gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                tick.set(tick.get()-<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"&gt;&gt;&gt;&gt;"</span> + <span class="string">"机票还剩下"</span> + tick.get());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">"线程B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ThreadLocal&lt;Integer&gt; tick=new ThreadLocal&lt;Integer&gt;</code> 创建ThreadLocal变量</li><li><code>initialValue</code> 设定初始值</li><li><code>get()</code>访问ThreadLocal变量</li><li><code>set()</code>设置对应值</li><li><code>ThreadLocal</code> 线程局部变量，每个线程单独维护一份自己的<code>ThreadLocal</code>变量相当于对每个线程都有一个独立的<code>ThreadLocal</code>副本</li></ul><h2 id="join-sleep-wait-区别"><a href="#join-sleep-wait-区别" class="headerlink" title="join ,sleep,wait,区别"></a>join ,sleep,wait,区别</h2><ul><li><code>sleep</code>是<code>Thread</code>类的静态方法一般写在<code>run</code>方法里面表示休眠当前线程于调用线程无关，会让出cpu资源，不会释放对象锁，会抛出异常</li><li><code>join</code>方法联合线程，当一个线程调用该方法后，会强制执行该线程（此时原来执行的线程处于阻塞状态），直到执行结束再执行原来的线程，这样把两个线程联合在了一一起。</li><li><code>wait</code> 方法会让出cpu释放对象锁，需要配和<code>synchronized</code>使用接收锁对象</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/wangyuyang1016/p/10952161.html" target="_blank" rel="noopener">Java 线程与多线程</a></li><li><a href="http://yayihouse.com/yayishuwu/chapter/1750" target="_blank" rel="noopener">java线程两种睡眠方法比较</a></li><li><a href="https://blog.csdn.net/p312011150/article/details/81741505" target="_blank" rel="noopener">Java多线程 -sleep 用法详解</a></li><li><a href="http://ifeve.com/java-threadlocal%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Java ThreadLocal的使用</a></li><li><a href="https://blog.csdn.net/qq_38293564/article/details/80459827" target="_blank" rel="noopener">Java并发编程之ThreadLocal详解</a></li><li><a href="https://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener">JAVA多线程之线程间的通信方式</a></li><li><a href="http://www.importnew.com/26850.html" target="_blank" rel="noopener">Java 里如何实现线程间通信</a></li></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1Q4P6bLWG3KVjSZPcq6zkbXXaD.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Thread" scheme="https://datou-y.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>java中StringBuffer和StringBuilder和String</title>
    <link href="https://datou-y.github.io/posts/2a5743c8.html/"/>
    <id>https://datou-y.github.io/posts/2a5743c8.html/</id>
    <published>2019-06-06T09:59:13.017Z</published>
    <updated>2019-06-06T13:28:32.004Z</updated>
    
    <content type="html"><![CDATA[<p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。<br>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。<br>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h2 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"I AM DOG"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(a);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"I AM DOG"</span>);</span><br><span class="line">System.out.println(a + b + c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>&#125;;</span><br><span class="line">String str1 = <span class="keyword">new</span> String(c1);</span><br><span class="line">System.out.println(str1);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.length()</span><br></pre></td></tr></table></figure><ul><li><code>length()</code>是方法区别与数组的<code>length</code>属性还有集合的<code>size()</code>方法</li><li>字符串的长度是指其所包含的字符的个数,一个字符算一个长度，一个空格算一个长度</li></ul><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"I am"</span>;</span><br><span class="line">String b = <span class="string">" Tom"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">14</span>;</span><br><span class="line">System.out.println(a + b + <span class="string">" "</span> + <span class="string">"我的年龄是"</span> + age);</span><br><span class="line"></span><br><span class="line">String result = <span class="string">"The result 2 + 2 is "</span> + <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">System.out.println(result);</span><br><span class="line">String a=<span class="string">"fafafa"</span>;</span><br><span class="line">String c=result.concat(a);</span><br></pre></td></tr></table></figure><ul><li><code>&quot; + &quot;</code>可以连接两个字符串，产生一个新<code>String</code>对象，也可以使用一连串的字符串<code>+</code>进行运算</li><li>字符串在使用<code>+</code>号进行连接的时候，会默认把int类型自动的转换为String类型再进行连接，这种转换思想具有普适性，其他数据类型也是如此</li><li><p>正如上面所说的，<code>String</code>类型和任何类型的相加都会变为<code>String</code>类型的结果，上面程序的运行过程会先执行<code>&quot;The result 2 + 2 is&quot;</code> 加2，得到的结果再加2 ，就会变成<code>The result 2 + 2 is 22</code></p></li><li><p><code>concat()</code>方法用于字符串连接效果和<code>+</code>是一样的</p></li></ul><h3 id="获取某个位置字符"><a href="#获取某个位置字符" class="headerlink" title="获取某个位置字符"></a>获取某个位置字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.charAt(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><ul><li><code>charAt()</code>获取字符串某个位置上的字符</li></ul><h3 id="获取字符的位置"><a href="#获取字符的位置" class="headerlink" title="获取字符的位置"></a>获取字符的位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.indexOf(<span class="string">"2"</span>));</span><br><span class="line">System.out.println(result.lastIndexOf(<span class="string">"2"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>indexOf()</code>获取字符对应位置的索引位置</li><li><code>lastIndexOf()</code>获取字符对应位置的最后索引位置</li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line"><span class="keyword">if</span>(result.contains(<span class="string">"he result"</span>))&#123;</span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">result.isEmpty()</span><br><span class="line">System.out.println(result.startsWith(<span class="string">"r"</span>));</span><br><span class="line">System.out.println(result.endsWith(<span class="string">" "</span>));</span><br><span class="line">System.out.println(result.equals(<span class="string">"t"</span>));</span><br><span class="line">System.out.println(result.equalsIgnoreCase(<span class="string">"T"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>boolean contains()</code>判断字符串中是否包含某一个子串</li><li><code>boolean isEmpty()</code>原理就是判断长度是否为0</li><li><code>boolean startsWith()</code>字符串是否以指定内容开头</li><li><code>boolean endsWith()</code> 字符串是否以指定内容结尾</li><li><code>boolean equals(str)</code>判断字符内容是否相同</li><li><code>boolean.equalsIgnorecase()</code>判断内容是否相同，并忽略大小写。</li></ul><h3 id="去掉字符串空格"><a href="#去掉字符串空格" class="headerlink" title="去掉字符串空格"></a>去掉字符串空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;   </span><br><span class="line">System.out.println(result.trim());</span><br></pre></td></tr></table></figure><ul><li><code>String trim()</code>将字符串两端的多个空格去除</li></ul><h3 id="转换大小写"><a href="#转换大小写" class="headerlink" title="转换大小写"></a>转换大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.toUpperCase());</span><br><span class="line">System.out.println(result.toLowerCase());</span><br></pre></td></tr></table></figure><ul><li><code>String toUpperCsae()</code> 大转小 </li><li><code>String toLowerCsae()</code> 小转大</li></ul><h3 id="截取替换"><a href="#截取替换" class="headerlink" title="截取替换"></a>截取替换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"The result 2 + 2 is "</span>;</span><br><span class="line">System.out.println(result.substring(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">System.out.println(result.replace(<span class="string">"r"</span>,<span class="string">"h"</span>));</span><br></pre></td></tr></table></figure><ul><li><code>String subString()</code>获取字符串中子串</li><li><code>String replace()</code> 将字符串指定字符替换。</li></ul><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"222"</span>;</span><br><span class="line"><span class="keyword">int</span> c = Integer.valueOf(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">String b = String.valueOf(a);</span><br><span class="line"></span><br><span class="line">String d = <span class="string">"True"</span>;</span><br><span class="line">Boolean e = Boolean.valueOf(d);</span><br><span class="line"></span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure><ul><li><code>valueOf()</code> 字符串转换，转换什么类型就调用什么类型的<code>valueOf()</code>方法</li></ul><h2 id="StringBuffer常用操作"><a href="#StringBuffer常用操作" class="headerlink" title="StringBuffer常用操作"></a>StringBuffer常用操作</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">StringBuffer ssb=<span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure><ul><li>要初始化内容可以直接在<code>创建</code>时候初始化</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.append(<span class="string">"true"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>append()</code>追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后<code>StringBuffer</code>对象的内容也发生改变</li><li>使用该方法进行字符串的连接，将比<code>String</code>更加节约内容应用于数据库<code>SQL</code>语句的连接</li></ul><h3 id="reverse方法"><a href="#reverse方法" class="headerlink" title="reverse方法"></a>reverse方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>reverse()</code>作用是将StringBuffer对象中的内容反转，然后形成新的字符串</li></ul><h3 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.insert(<span class="number">3</span>,<span class="string">"true"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li>作用是在<code>StringBuffer</code>对象中插入内容索引不包含最后一个，然后形成新的字符串</li></ul><h3 id="deleteCharAt方法"><a href="#deleteCharAt方法" class="headerlink" title="deleteCharAt方法"></a>deleteCharAt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.delete(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">sb.deleteCharAt(<span class="number">1</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li>作用是删除指定位置的字符，然后将剩余的内容形成新的字符串</li></ul><h3 id="setCharAt方法"><a href="#setCharAt方法" class="headerlink" title="setCharAt方法"></a>setCharAt方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">0</span>,<span class="string">'A'</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>setCharAt(int index, char ch)</code>作用是修改对象中索引值为index位置的字符为新的字符ch</li></ul><h2 id="St1ringBuilder和String类型转换"><a href="#St1ringBuilder和String类型转换" class="headerlink" title="St1ringBuilder和String类型转换"></a>St1ringBuilder和String类型转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure><ul><li><code>toString()</code>方法进行转换为<code>String</code></li><li>需要注意的是，<code>StringBuffer</code>和<code>String</code>属于不同的类型，也不能直接进行强制类型转换</li></ul><h2 id="String，StringBuilder，StringBuffer三者的区别"><a href="#String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="String，StringBuilder，StringBuffer三者的区别"></a>String，StringBuilder，StringBuffer三者的区别</h2><div class="tip"><br>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。<br></div><ul><li>首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：<code>StringBuilder &gt; StringBuffer &gt; String</code></li><li><code>String最慢的原因</code>String为字符串<code>常量</code>，而StringBuilder和StringBuffer均为字符串<code>变量</code>即<code>String对象</code>一旦创建之后该对象是<code>不可更改</code>的，但后两者的对象是变量，是<code>可以更改的</code></li><li>Java中对<code>String</code>对象进行的操作实际上是一个不断<code>创建新的对象</code>并且将旧的对象回收的一个过程，所以执行速度<code>很慢</code></li><li><code>StringBuilder和StringBuffer的对象是变量</code>，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比<code>String</code>快很多</li></ul><blockquote><p>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</p></blockquote><ul><li><code>String：</code>适用于少量的字符串操作的情况</li><li><code>StringBuilder：</code>适用于单线程下在字符缓冲区进行大量操作的情况</li><li><code>StringBuffer：</code>适用多线程下在字符缓冲区进行大量操作的情况</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="java中String-s-new-String-“abc”-创建了几个对象"><a href="#java中String-s-new-String-“abc”-创建了几个对象" class="headerlink" title="java中String s = new String(“abc”)创建了几个对象"></a>java中String s = new String(“abc”)创建了几个对象</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/hey-man/p/6833242.html" target="_blank" rel="noopener">Java中String的用法</a></li><li><a href="https://www.cnblogs.com/cxuanBlog/p/10927557.html" target="_blank" rel="noopener">String 字符串基本使用</a></li><li><a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">Java中的String，StringBuilder，StringBuffer三者的区别</a></li><li><a href="https://www.cnblogs.com/liu-chao-feng/p/5636063.html" target="_blank" rel="noopener">StringBuffer的用法</a></li><li><a href="https://www.jb51.net/article/128551.htm" target="_blank" rel="noopener">java之StringBuffer常见使用方法解析</a></li><li><a href="https://www.cnblogs.com/ydpvictor/archive/2012/09/09/2677260.html" target="_blank" rel="noopener">String s=new String(“abc”)创建了几个对象?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。&lt;br&gt;和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。&lt;br&gt;StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。&lt;br&gt;由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。&lt;/p&gt;
&lt;h2 id=&quot;字符串的创建&quot;&gt;&lt;a href=&quot;#字符串的创建&quot; class=&quot;headerlink&quot; title=&quot;字符串的创建&quot;&gt;&lt;/a&gt;字符串的创建&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String a = &lt;span class=&quot;string&quot;&gt;&quot;I AM DOG&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String c = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;I AM DOG&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a + b + c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c1[] = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;4&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;5&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String str1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(c1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(str1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="字符串" scheme="https://datou-y.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>java中数组用法和实例详解</title>
    <link href="https://datou-y.github.io/posts/4d11ca6.html/"/>
    <id>https://datou-y.github.io/posts/4d11ca6.html/</id>
    <published>2019-06-06T08:25:00.935Z</published>
    <updated>2019-06-06T10:21:36.315Z</updated>
    
    <content type="html"><![CDATA[<p>数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] a=&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">String[] names = <span class="keyword">new</span> String[] &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型</li><li>创建并分配空间在 Java中可以使用<code>new</code>关键字来给数组分配空间<a id="more"></a></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>]=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(b[<span class="number">0</span>]);</span><br><span class="line">System.out.println(b.length);</span><br></pre></td></tr></table></figure><ul><li><code>length</code>属性获取数组长度</li><li><code>b[0]</code> 直接通过下标获取数组对应位置元素</li></ul><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">Arrays.sort(b);</span><br><span class="line">Arrays.sort(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer s : b) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Arrays.sort()</code>方法进行数组排序，字符串就按26个字符位置排序，数组就按大小排序</li></ul><h2 id="数组转换集合"><a href="#数组转换集合" class="headerlink" title="数组转换集合"></a>数组转换集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="keyword">for</span> (String s : ls) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a); </span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行反转</span></span><br><span class="line">Collections.reverse(ls);</span><br><span class="line"><span class="keyword">for</span>(String s:ls)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组获取最大值和最小值"><a href="#数组获取最大值和最小值" class="headerlink" title="数组获取最大值和最小值"></a>数组获取最大值和最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行比较</span></span><br><span class="line">System.out.println(Collections.max(ls));</span><br><span class="line">System.out.println(Collections.min(ls));</span><br></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b = &#123;<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>&#125;;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(a));</span><br><span class="line"><span class="comment">//在调用集合的合并方法</span></span><br><span class="line"></span><br><span class="line">ls.addAll(Arrays.asList(b));</span><br><span class="line">Object[] o = ls.toArray();</span><br><span class="line">System.out.println(Arrays.toString(o));</span><br><span class="line"><span class="keyword">for</span> (Object s : o) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip"><br>注意这里遇到一个坑<br></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s=Arrays.asList(a);</span><br><span class="line">s.add(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure><ul><li>这样接收的<code>List</code>集合和我们<code>new</code>创建的有区别所以<code>add</code>等方法是又区别的</li><li>参考<a href="https://www.2cto.com/kf/201806/751606.html" target="_blank" rel="noopener">ArrayList报错：UnsupportedOperationException的解决办法</a></li></ul><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/bahcelor/p/6593514.html" target="_blank" rel="noopener">Java关于数组操作函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String[] a=&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;d&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String[] b=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String[] names = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型&lt;/li&gt;
&lt;li&gt;创建并分配空间在 Java中可以使用&lt;code&gt;new&lt;/code&gt;关键字来给数组分配空间
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Array" scheme="https://datou-y.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList、LinkedList、Vector的区别和实现原理</title>
    <link href="https://datou-y.github.io/posts/57b1f1b.html/"/>
    <id>https://datou-y.github.io/posts/57b1f1b.html/</id>
    <published>2019-06-06T07:37:14.550Z</published>
    <updated>2019-06-06T08:14:20.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="https://ae01.alicdn.com/kf/HTB1yVDlbUGF3KVjSZFvq6z_nXXaR.jpg" alt><br><a id="more"></a></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>查询，和随机访问效率快，修改比较慢</li><li>数据结构基于<code>数组</code>实现按照顺序将元素存储（从下表为0开始），删除元素时，删除操作完成后，需要使部分元素移位，默认的初始容量为10</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部</li><li>查询慢，修改比较慢</li><li><code>LinkedList</code>是基于双向链表实现的（含有头结点）</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li><code>Vector</code>属于线程安全级别的大部分的方法都包含关键字<code>synchronized</code></li><li><code>Vector</code>的效率没有ArraykList和LinkedList高</li><li>基于数组实现的</li><li><code>Vector</code>提供<code>indexOf(obj, start)</code>接口，<code>ArrayList</code>没有。</li></ul><h2 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h2><blockquote><p>ArrayList不具有有线程安全性，在单线程的环境中，LinkedList也是线程不安全的，如果在并发环境下使用它们，可以用Collections类中的静态方法synchronizedList(）对ArrayList和LinkedList进行调用即可。<br>Vector实现线程安全的，即它大部分的方法都包含关键字synchronized,但是Vector的效率没有ArraykList和LinkedList高</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/kuangsonghan/article/details/79861170" target="_blank" rel="noopener">ArrayList、LinkedList、Vector的区别和实现原理</a></li><li><a href="https://blog.csdn.net/u012814441/article/details/80671604" target="_blank" rel="noopener">源码浅析ArrayList、LinkedList和Vector的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;继承关系&quot;&gt;&lt;a href=&quot;#继承关系&quot; class=&quot;headerlink&quot; title=&quot;继承关系&quot;&gt;&lt;/a&gt;继承关系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1yVDlbUGF3KVjSZFvq6z_nXXaR.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="List" scheme="https://datou-y.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和Hashtable的区别和实现原理</title>
    <link href="https://datou-y.github.io/posts/425444d1.html/"/>
    <id>https://datou-y.github.io/posts/425444d1.html/</id>
    <published>2019-06-06T06:00:25.209Z</published>
    <updated>2019-06-06T08:20:55.268Z</updated>
    
    <content type="html"><![CDATA[<p>Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分<br>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。<br><a id="more"></a></p><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul><li><code>HashMap</code>和<code>Hashtable</code>都实现了<code>Map</code>接口</li><li><code>HashMap</code>是线程不安全的不允许键值重复,允许空键和空值;由于非线程安全,<code>HashMap</code> 的效率要较 <code>HashTable</code> 的效率高一些.</li><li><code>HashTable</code> 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值</li><li><code>HashTable</code> 是 <code>synchronized</code> 同步的,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步</li><li><code>HashMap</code>的迭代器(<code>Iterator</code>)是<code>fail-fast</code>迭代器，而<code>Hashtable</code>的<code>enumerator</code>迭代器不是<code>fail-fast</code>的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出<code>ConcurrentModificationException</code>，但迭代器本身的<code>remove()</code>方法移除元素则不会抛出<code>ConcurrentModificationException</code>异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>底层数据结构基于数组+链表实现</li></ul><h2 id="HashMap同步"><a href="#HashMap同步" class="headerlink" title="HashMap同步"></a>HashMap同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m=Collections.synchronizedMap(map)</span><br></pre></td></tr></table></figure><ul><li><code>Collections</code>类不是集合，这个类里面提供了<code>synchronizedMap</code>方法</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/itcx1213/p/10963751.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></li><li><a href="https://www.cnblogs.com/lchzls/p/6714335.html" target="_blank" rel="noopener">JAVA中HashMap和Hashtable区别</a></li><li><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">HashMap和Hashtable原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分&lt;br&gt;HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Map" scheme="https://datou-y.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>java中map字典用法和详细实例</title>
    <link href="https://datou-y.github.io/posts/f2f0bf25.html/"/>
    <id>https://datou-y.github.io/posts/f2f0bf25.html/</id>
    <published>2019-06-05T10:52:00.847Z</published>
    <updated>2019-06-06T07:42:48.288Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap字典用于存放键值对，<code>&lt;key,value&gt;</code>，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！<br><img src="https://ae01.alicdn.com/kf/HTB1cDhBbUGF3KVjSZFo762mpFXaS.png" alt><br><a id="more"></a></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://ae01.alicdn.com/kf/HTB1TzFBbMmH3KVjSZKz7622OXXas.png" alt></p><h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = Hashtable&lt;String, Integer&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>HashMap</code>底层是哈希表数据结构，线程是不同步的也就是线程不安全的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法</li><li><p><code>TreeMap</code>TreeMap可以对集合中的键进行排序</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>put()</code>方法在没有hashCode和equals方式   添加重复的键值（值不同）,会覆盖掉前面key值相同的值</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="string">"tom"</span>);</span><br><span class="line">map.clear();  </span><br><span class="line">map.remove(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code>方法清空集合对象  </li><li><code>remove()</code>方法指定key，返回删除的键值对映射的值如果key不存在删除失败，返回null<br>如果同时指定了key，和value删除成功返回true，否则返回false</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size()</span><br><span class="line">map.get(<span class="string">"toms"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>方法获取容器大小,从1开始计算，集合索引从0开始计算</li><li><code>get()</code>方法指定key，获取对应键值，如果key不存在返回null</li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map.isEmpty()</span><br><span class="line">map.containsKey(<span class="string">"toms"</span>)</span><br><span class="line">map.containsValue(<span class="number">11</span>)</span><br><span class="line">Set&lt;String&gt; key = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String s:key)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; S=map.values();</span><br><span class="line"><span class="keyword">for</span>(Integer s:S)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; es=map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry e:es)&#123;</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>boolean isEmpty()</code>方法判断集合是否为空   长度为0返回true否则false </li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的key </li><li><code>boolean containsValue(Object value)</code>判断集合中是否包含指定的value</li><li><code>Set keySet()</code>方法获取所有的key返回一个<code>Set</code>集合</li><li><code>Collection values()</code>方法获取所有的值返回一个<code>Collection</code>集合</li><li><code>entrySet()</code> 方法获取map所有实体<code>Set</code>集合包含键和值</li></ul><h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure><p>通过<code>keySet()</code> 获取key  通过key 找到value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Map.Entry(String,Integer)</code> 获取，然后使用<code>entry.getKey()</code>获取到键，通过<code>entry.getValue()</code>获取到值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry e:map.entrySet())&#123;</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只遍历键或者值，通过增强for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer a:map.values())&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Iterator</code>迭代器来遍历通过<code>getKey</code>获取所有键<code>getValue</code>获取所有值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it= map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; next=it.next();</span><br><span class="line">    String key=next.getKey();</span><br><span class="line">    Integer v=next.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key"</span>+key+<span class="string">"value"</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map合并"><a href="#Map合并" class="headerlink" title="Map合并"></a>Map合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map1.put(<span class="string">"t"</span>, <span class="number">21</span>);</span><br><span class="line">map1.put(<span class="string">"g"</span>, <span class="number">2</span>);</span><br><span class="line">map.putAll(map1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>putAll()</code>方法可以接收另一个<code>Map</code>让两个集合合并为一个<br><div class="tip"><br><code>Set</code>的元素不可重复，<code>Map</code>的键不可重复<br><code>Set</code>元素重复元素不能存入add方法返回<code>false</code><br><code>Map</code>的重复健将覆盖旧键，将旧值返回。</div></li></ul><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><p>增加<code>for</code>循环进行遍历新增,删除操作会触发<code>fail-fast</code>机制，修改也就是覆盖不会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    map.put(<span class="string">"jack"</span>,<span class="number">222</span>);</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        map.remove(<span class="string">"jack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用迭代器迭<code>Iterator</code>迭代时候迭代器删除不会触发<code>fail-fast</code>机制只有新增会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; s=it.next();</span><br><span class="line">    String key=s.getKey();</span><br><span class="line">    Integer value=s.getValue();</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"tom"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882#12-set" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/douyu2580860/p/8358768.html" target="_blank" rel="noopener">java基础集合简介Map（三）下</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap字典用于存放键值对，&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！&lt;br&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1cDhBbUGF3KVjSZFo762mpFXaS.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="Map" scheme="https://datou-y.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>java中List集合用法和实例详解</title>
    <link href="https://datou-y.github.io/posts/50eb6371.html/"/>
    <id>https://datou-y.github.io/posts/50eb6371.html/</id>
    <published>2019-06-04T13:33:38.510Z</published>
    <updated>2019-06-06T07:42:33.669Z</updated>
    
    <content type="html"><![CDATA[<p>集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作</p><div class="tip"><br>下面是java中集合框架主要结构图<br></div><p><img src="https://ae01.alicdn.com/kf/HTB1aUHPbBiE3KVjSZFM762QhVXaJ.png" alt><br><a id="more"></a></p><h1 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li><code>List</code>继承自<code>Collection</code>接口，是有序集合,即先放入的元素排在前面允许相同元素和<code>null</code>,实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li><li><code>ArrayList</code>非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多</li><li><code>LinkedList</code> 非同步，允许相同元素和null，遍历效率低插入和删除效率高</li><li><code>Vector</code> 同步，允许相同元素和null，效率低</li></ul><h1 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h1><div class="tip"><br>集合的索引，也就是下标是从0开始，长度是从1开始<br></div><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls.add(<span class="string">"a"</span>); </span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="number">2</span>,<span class="string">"c"</span>);</span><br><span class="line">ls.set(<span class="number">0</span>,<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>add()</code>方法添加元素到集合中，也可以指定添加元素到集合指定位置，如果当前位置已经有了其他元素，后面的元素就依次往后移动，如果添加的位置索引不存在就会抛异常</p></li><li><p><code>set()</code>方法替换掉原来位置的元素，如果索引不存在抛异常</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.remove(<span class="string">"a"</span>);</span><br><span class="line">ls.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><code>remove()</code>方法删除元素，可以根据元素删除如果当前元素不存在，或者已经删除就返回false，如果存在删除成功返回true。</li><li>也可以根据索引，也就是下标来删除，如果下标不存在就抛异常，返回删除后的元素信息</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>get()</code>方法获取元素，根据下标获取元素，如果下标不存在抛异常</li></ul><h3 id="清空元素"><a href="#清空元素" class="headerlink" title="清空元素"></a>清空元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.clear()</span><br></pre></td></tr></table></figure><h3 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.size()</span><br><span class="line">System.out.println(ls.size());</span><br></pre></td></tr></table></figure><ul><li><code>size()</code> 获取元素个数，从1开始计算</li></ul><h3 id="集合是否为空"><a href="#集合是否为空" class="headerlink" title="集合是否为空"></a>集合是否为空</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f = ls.isEmpty();</span><br><span class="line"><span class="keyword">if</span> (f) &#123;</span><br><span class="line">    System.out.println(<span class="string">"full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合包含某个元素"><a href="#集合包含某个元素" class="headerlink" title="集合包含某个元素"></a>集合包含某个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f=ls.contains(<span class="string">"g"</span>);</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure><ul><li><code>contains()</code>方法，判断集合包含某个元素，如果存在返回true，否则返回false</li></ul><h3 id="获取元素对应的索引"><a href="#获取元素对应的索引" class="headerlink" title="获取元素对应的索引"></a>获取元素对应的索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a= ls.indexOf(<span class="string">"e"</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="keyword">int</span> b=ls.lastIndexOf(<span class="string">"a"</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><ul><li><code>indexOf()</code>方法判断元素对应的索引位置，如果当前元素存在返回对应索引，不存在返回-1</li><li><code>lastIndexOf()</code>方法和<code>indexOf()</code>一样，唯一不同就是当集合中有多个重复元素时候，会返回最后一个元素的下标，也就是索引。</li></ul><h2 id="集合转换为数组"><a href="#集合转换为数组" class="headerlink" title="集合转换为数组"></a>集合转换为数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"d"</span>);</span><br><span class="line">ls.add(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Object[] a=ls.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ls.size();i++)&#123;</span><br><span class="line">    System.out.println(ls.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=personList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        String p=iterator.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><ul><li>单线程环境 集合被创建后,在遍历它的过程中修改了结构,会抛异常</li><li>多线程环境 当一个线程在遍历这个集合,而另一个线程对这个集合的结构进行了修改会抛异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=<span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">Person person=<span class="keyword">new</span> Person();</span><br><span class="line">person.setAge(<span class="number">23</span>);</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">personList.add(person);</span><br><span class="line">Person person1=<span class="keyword">new</span> Person();</span><br><span class="line">person1.setAge(<span class="number">22</span>);</span><br><span class="line">person1.setName(<span class="string">"jack"</span>);</span><br><span class="line">personList.add(person1);</span><br><span class="line">Iterator&lt;Person&gt; iterator=personList.iterator();</span><br></pre></td></tr></table></figure><p>普通for循环遍历时候修改元素不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;personList.size();i++)&#123;</span><br><span class="line">    Person p=personList.get(i);</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加for循环遍历时候修改元素会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>迭代器遍历，使用迭代器删除不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Person p=iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        <span class="comment">//这里要使用Iterator的remove方法移除当前对象，</span></span><br><span class="line">        <span class="comment">// 如果使用List的remove方法，则同样会出现ConcurrentModificationException</span></span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="集合和数组区别"><a href="#集合和数组区别" class="headerlink" title="集合和数组区别"></a>集合和数组区别</h2><ul><li>数组长度是固定的，集合长度是可变的</li><li>数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li><li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求</li></ul><h2 id="集合案例"><a href="#集合案例" class="headerlink" title="集合案例"></a>集合案例</h2><h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!list1.contains(list.get(i)))&#123;</span><br><span class="line">        list1.add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list1)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环list中的所有元素然后删除重复<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = list.size() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">            list.remove(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过HashSet踢除重复元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h=<span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">h.addAll(list);</span><br><span class="line">list.clear();</span><br><span class="line">list.addAll(h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新版本的 JDK 可以支持 Stream 流操作，因此集合去重可以简单的使用下述语句来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="集合合并"><a href="#集合合并" class="headerlink" title="集合合并"></a>集合合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">"c"</span>);</span><br><span class="line">list1.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.addAll(list1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/B_evan/article/details/80611522" target="_blank" rel="noopener">Java集合（一）什么是集合</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82354205#2-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">Java基础List详解</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/cainiao-Shun666/p/7911142.html" target="_blank" rel="noopener">Java中List集合去除重复数据的方法</a></li><li><a href="https://www.cnblogs.com/Luouy/p/6482733.html" target="_blank" rel="noopener">JAVA List合并集合</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;下面是java中集合框架主要结构图&lt;br&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/HTB1aUHPbBiE3KVjSZFM762QhVXaJ.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://datou-y.github.io/categories/java/"/>
    
    
      <category term="List" scheme="https://datou-y.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>mysql复杂的sql语句查询案例之GROUP BY系列</title>
    <link href="https://datou-y.github.io/posts/1077e6d7.html/"/>
    <id>https://datou-y.github.io/posts/1077e6d7.html/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-06-09T09:46:17.784Z</updated>
    
    <content type="html"><![CDATA[<p>sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，</p><div class="tip"><br>    group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用<code>where</code> 再用<code>group by</code> 或者先用group by 再用<code>having</code><br></div><ul><li><code>GROUP BY X</code>意思是将所有具有相同X字段值的记录放到一个分组里</li><li><code>GROUP BY X, Y</code>意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从<code>左到右</code>，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 </li><li><code>group by</code> 一般和聚合函数一起使用才有意义,比如 count sum avg等</li></ul><a id="more"></a><h2 id="常用的聚合函数"><a href="#常用的聚合函数" class="headerlink" title="常用的聚合函数"></a>常用的聚合函数</h2><ul><li>count() 计数</li><li>sum() 求和</li><li>avg() 平均数</li><li>max() 最大值</li><li>min() 最小值</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure><ul><li><p><code>group by</code>字句也和<code>where</code>条件语句结合在一起使用。当结合在一起时，<code>where</code>在前，<code>group by</code> 在后。即先对<code>select xx from xx</code>的记录集合用<code>where</code>进行筛选，然后再使用<code>group by</code> 对筛选后的结果进行分组。 </p></li><li><p>使用<code>having</code>字句对分组后的结果进行筛选，语法和<code>where</code>差不多:<code>having</code> 条件表达式<br><div class="tip"><br>1<code>having</code>只能用在<code>group by</code>之后，对分组后的结果进行筛选(即使用<code>having</code>的前提条件是<br>分组)<br>2<code>where</code>肯定在<code>group by</code> 之前，即也在<code>having</code>之前。<br>3.<code>where</code>后的条件表达式里不允许使用聚合函数，而<code>having</code>可以。</div></p><div></div></li><li><p>当一个查询语句同时出现了<code>where,group by,having,order by</code>的时候，执行顺序和编写顺序是： </p></li></ul><ol><li><p>执行<code>where xx</code>对全表数据做筛选，返回第1个结果集。 </p></li><li><p>针对第1个结果集使用<code>group by</code>分组，返回第2个结果集。 </p></li><li><p>针对第2个结果集中的每<code>1</code>组数据执行<code>select xx</code>，有几组就执行几次，返回第3个结果集。 </p></li><li><p>针对第3个结集执行<code>having xx</code>进行筛选，返回第4个结果集。 </p></li><li><p>针对第4个结果集<code>排序</code>。</p></li></ol><h2 id="sql分析"><a href="#sql分析" class="headerlink" title="sql分析"></a>sql分析</h2><blockquote><p>按由高到低的顺序显示个人平均分在70分以上的学生姓名和平均分，为了尽可能地提高平均分，在计算平均分前不包括分数在60分以下的成绩，并且也不计算Tom的成绩</p></blockquote><ul><li>拿到一个比较复杂的需求<code>sql</code>语句不要<code>慌</code>我们要一步步的进行需求<code>拆分</code></li></ul><p><code>分析：</code></p><ol><li><p>要求显示<code>学生姓名</code>和<code>平均分</code>因此确定第1步<code>select s_name,avg(score) from student</code> </p></li><li><p>计算平均分前<code>不</code>包括分数在<code>60分以下</code>的成绩，并且也不计算Tom的成绩因此确定第2步 <code>where score&gt;=60 and s_name!=’Tom’</code></p></li><li><p>显示<code>个人平均分</code>相同名字的学生（同一个学生）考了多门科目 因此按姓名分组确定第3步 <code>group by s_name</code></p></li><li><p>显示个人<code>平均分在70分以上</code>因此确定第4步 <code>having avg(s_score)&gt;=70</code></p></li><li><p>按由高到低的顺序 因此确定第5步 <code>order by avg(s_score) desc</code></p></li></ol><h2 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h2><h3 id="学生信息"><a href="#学生信息" class="headerlink" title="学生信息"></a>学生信息</h3><p>班级表<br><img src="https://ae01.alicdn.com/kf/HTB1_FB2aMKG3KVjSZFL761MvXXab.png" alt><br>学生表<br><img src="https://ae01.alicdn.com/kf/HTB1uqh3aLWG3KVjSZPc762kbXXa0.png" alt><br>成绩表<br><img src="https://ae01.alicdn.com/kf/HTB1HAB4aROD3KVjSZFF763n9pXaZ.png" alt></p><ul><li><p>插入班级信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span> (class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"A"</span>,<span class="string">"一班"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span> (class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"B"</span>,<span class="string">"二班"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">class</span>(class_id, class_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"C"</span>,<span class="string">"三班"</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"A"</span>,<span class="string">"Tom"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">"B"</span>,<span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(class_id, stu_name)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">"C"</span>,<span class="string">"Luck"</span>);</span><br></pre></td></tr></table></figure></li><li><p>插入科目信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">8</span>,<span class="string">"数学"</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">"英语"</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score(stu_id, course, score) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">"语文"</span>,<span class="number">70</span>);</span><br></pre></td></tr></table></figure></li></ul><div class="tip"><br> 插入语句没有<code>from</code>表是<code>into</code>表<br></div><ul><li>查询每个学生总成绩</li><li><code>分析</code></li><li>总成绩 <code>sum(score.score)</code></li><li><p>每个学生 一个学生考了多个科目按照学生姓名分组 <code>group by student.stu_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> st.stu_name <span class="keyword">from</span> student st <span class="keyword">where</span> st.stu_id=sc.stu_id) stu_name,<span class="keyword">sum</span>(sc.score)</span><br><span class="line"><span class="keyword">from</span> student st,score sc</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> st.stu_id;</span><br></pre></td></tr></table></figure></li><li><p>查询语文成绩大于90的学生</p></li><li><code>分析</code></li><li><p>语文成绩大于90 <code>where sc.score&gt;90 and sc.course=&quot;语文&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_name,sc.score</span><br><span class="line"><span class="keyword">from</span> student st,score sc</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> sc.score&gt;<span class="number">90</span> <span class="keyword">and</span> sc.course=<span class="string">"语文"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询A班所有学生信息</p></li><li><code>分析</code></li><li><p>A班 <code>where cl.class_id=&quot;A&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_id,st.stu_name <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.class_id=<span class="string">"A"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询B班学生人数</p></li><li><code>分析</code></li><li>B班 <code>where cl.class_id=B</code></li><li><p>总人数 <code>count(*)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">where</span> st.class_id=<span class="string">"B"</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询A班语文成绩最高的学生</p></li><li><code>分析</code></li><li>A班 <code>st.class_id=A</code></li><li><p>语文成绩最高 <code>where sc.score=max(sc.score) and sc.coures=&quot;语文&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_id,st.stu_name <span class="keyword">from</span> student st, score sc,(<span class="keyword">select</span> <span class="keyword">max</span>(sc.score) max_su <span class="keyword">from</span> score sc,<span class="keyword">class</span> cl,student st</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id <span class="keyword">and</span> sc.course=<span class="string">"语文"</span> <span class="keyword">and</span> st.class_id=<span class="string">"A"</span>) t</span><br><span class="line"><span class="keyword">where</span> sc.course=<span class="string">"语文"</span> <span class="keyword">and</span> sc.stu_id=st.stu_id <span class="keyword">and</span> st.class_id=<span class="string">"A"</span> <span class="keyword">and</span> sc.score=max_su;</span><br></pre></td></tr></table></figure></li><li><p>查询各班级语文成绩最高的学生信息</p></li><li><code>分析</code></li><li>各班级 <code>group by cl.class_id</code></li><li><p>语文成绩最高 <code>max(sc.score) and sc.score=语文</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st1.stu_name ,cl1.class_name,sc1.score</span><br><span class="line"><span class="keyword">from</span> student st1,<span class="keyword">class</span> cl1,score sc1,(<span class="keyword">select</span> <span class="keyword">max</span>(sc.score) max_su <span class="keyword">from</span> score sc,<span class="keyword">class</span> cl,student st</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cl.class_id) t</span><br><span class="line"><span class="keyword">where</span> st1.stu_id=sc1.stu_id <span class="keyword">and</span> st1.class_id=cl1.class_id <span class="keyword">and</span> sc1.course=<span class="string">"语文"</span></span><br><span class="line"><span class="keyword">and</span> sc1.score=max_su</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sc1.score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询各个班级成绩最高的学生信息</p></li><li><code>分析</code></li><li>各班级 <code>group by cl.class_id</code></li><li>成绩最高 <code>max(sc.score)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> st.stu_name,cl.class_name,sc.course,sc.score</span><br><span class="line"><span class="keyword">from</span> student st,score sc,<span class="keyword">class</span> cl,</span><br><span class="line">     (<span class="keyword">select</span> <span class="keyword">max</span>(sc1.score) max_score <span class="keyword">from</span> student st1,score sc1,<span class="keyword">class</span> cl1</span><br><span class="line">       <span class="keyword">where</span> st1.stu_id=sc1.stu_id <span class="keyword">and</span> st1.class_id=cl1.class_id</span><br><span class="line">       <span class="keyword">group</span> <span class="keyword">by</span> cl1.class_id) t</span><br><span class="line"><span class="keyword">where</span> st.stu_id=sc.stu_id <span class="keyword">and</span> st.class_id=cl.class_id <span class="keyword">and</span> sc.score=max_score;</span><br></pre></td></tr></table></figure></li></ul><h3 id="部门信息"><a href="#部门信息" class="headerlink" title="部门信息"></a>部门信息</h3><p>员工表 <code>empy</code></p><p><img src="https://ae01.alicdn.com/kf/HTB1ZZvPb2WG3KVjSZFg762TspXam.png" alt></p><p>部门表 <code>dept</code><br><img src="https://ae01.alicdn.com/kf/HTB1zB6Vb8Gw3KVjSZFw762Q2FXaY.png" alt></p><ul><li>查询每个部门工资最高的员工</li><li><code>分析</code></li><li>每个部门 <code>group by ep.dept_id</code></li><li><p>工资最高 <code>max(ep.salary)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empy.name,salary,dept.name <span class="keyword">from</span> empy,dept,</span><br><span class="line">(<span class="keyword">select</span> dept_id,<span class="keyword">max</span>(ep.salary) maxsal <span class="keyword">from</span> empy ep <span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id) t</span><br><span class="line"><span class="keyword">where</span> empy.dept_id=t.dept_id <span class="keyword">and</span> empy.salary=maxsal <span class="keyword">and</span> empy.dept_id=dept.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门的人员信息</p></li><li><code>分析</code></li><li><p>每个部门 <code>group by ep.dept_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ep.name <span class="keyword">name</span>,ep.salary salary,dp.name department <span class="keyword">from</span> empy ep ,dept dp</span><br><span class="line"><span class="keyword">where</span> ep.dept_id=dp.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门的平均工资</p></li><li><code>分析：</code></li><li>平均工资 <code>avg(ep.salary)</code></li><li><p>每个部门 <code>group by dept_id</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(ep.salary) avg_salary, dp.name <span class="keyword">from</span> empy ep,dept dp</span><br><span class="line"><span class="keyword">where</span> dp.id=ep.dept_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id;</span><br></pre></td></tr></table></figure></li><li><p>查询销售部Tom的个人信息</p></li><li><code>分析</code></li><li><p><code>where ep.name=&quot;Tom&quot; and dp.name=&quot;销售部&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> empy ep,dept dp</span><br><span class="line"><span class="keyword">where</span>  ep.name=<span class="string">"Tom"</span> <span class="keyword">and</span> dp.name=<span class="string">"销售"</span> <span class="keyword">and</span> ep.dept_id=dp.id;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门前三名员工信息</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_id, <span class="keyword">name</span>, salary</span><br><span class="line"><span class="keyword">from</span> empy e1</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> empy e2</span><br><span class="line">    <span class="keyword">where</span> e2.dept_id=e1.dept_id <span class="keyword">and</span> e2.salary&gt;=e1.salary</span><br><span class="line">   ) &lt;=<span class="number">3</span> <span class="comment">/*这里的数值表示你想取前几名*/</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_id, salary <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><ul><li>查询每个部门工资最高的前两名员工并且按照工资降序</li><li><code>分析</code></li><li>每个部门 <code>group by ep.dept_id</code></li><li>工资最高 <code>max(ep.salary)</code></li><li>前两名员工 <code>count(*)&lt;=2</code></li><li><p>工资降序 <code>order by ep.salary desc</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ep.name,ep.salary,dp.name <span class="keyword">from</span> empy ep,dept dp,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">max</span>(empy.salary) max_salary,empy.dept_id <span class="keyword">from</span> empy <span class="keyword">group</span> <span class="keyword">by</span> empy.dept_id) t</span><br><span class="line"><span class="keyword">where</span> ep.dept_id=dp.id <span class="keyword">and</span> ep.dept_id=t.dept_id <span class="keyword">and</span> ep.salary=max_salary  <span class="keyword">and</span></span><br><span class="line">      (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> empy e2 <span class="keyword">where</span> e2.dept_id=ep.dept_id <span class="keyword">and</span> e2.salary=ep.salary)&lt;=<span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> max_salary <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure></li><li><p>查询每个部门每月发放的工资总和</p></li><li><code>分析</code></li><li>每个部门 <code>group by dp.dept_id</code></li><li>工资总和 <code>sum(ep.salary)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> dp.name <span class="keyword">from</span> dept dp <span class="keyword">where</span> dp.id=ep.dept_id) dept, <span class="keyword">sum</span>(ep.salary)  sum_salary <span class="keyword">from</span> empy ep</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ep.dept_id</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.jianshu.com/p/8b135d373df1" target="_blank" rel="noopener">SQL中GROUP BY用法示例</a></li><li><a href="https://blog.csdn.net/zhu940923/article/details/81084080" target="_blank" rel="noopener">查询每班分数最高的学生</a></li><li><a href="https://blog.csdn.net/xx_star1204/article/details/72884983" target="_blank" rel="noopener">mysql group by 对多个字段进行分组</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;    group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用&lt;code&gt;where&lt;/code&gt; 再用&lt;code&gt;group by&lt;/code&gt; 或者先用group by 再用&lt;code&gt;having&lt;/code&gt;&lt;br&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GROUP BY X&lt;/code&gt;意思是将所有具有相同X字段值的记录放到一个分组里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP BY X, Y&lt;/code&gt;意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从&lt;code&gt;左到右&lt;/code&gt;，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;group by&lt;/code&gt; 一般和聚合函数一起使用才有意义,比如 count sum avg等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://datou-y.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://datou-y.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>防止表单重复提交的多种策略手段</title>
    <link href="https://datou-y.github.io/posts/9fe2dfd3.html/"/>
    <id>https://datou-y.github.io/posts/9fe2dfd3.html/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-05-29T04:36:21.097Z</updated>
    
    <content type="html"><![CDATA[<p>在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><ul><li>场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交</li><li>场景二：表单提交后用户点击【刷新】按钮导致表单重复提交</li><li>场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交</li><li>场景四：使用浏览器历史记录重复提交表单。<a id="more"></a></li></ul><h2 id="问题方案"><a href="#问题方案" class="headerlink" title="问题方案"></a>问题方案</h2><h3 id="利用JavaScript防止表单重复提交"><a href="#利用JavaScript防止表单重复提交" class="headerlink" title="利用JavaScript防止表单重复提交"></a>利用JavaScript防止表单重复提交</h3><ol><li><p>表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮</p></li><li><p>用JavaScript控制Form表单只能提交一次阻止submit提交事件第二次提交</p></li><li><p>另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。</p></li></ol><div class="tip"><br>    使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题<br></div><h3 id="利用Session防止表单重复提交"><a href="#利用Session防止表单重复提交" class="headerlink" title="利用Session防止表单重复提交"></a>利用Session防止表单重复提交</h3><blockquote><p>对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到<code>session</code>了。</p></blockquote><p>在服务器端，生成一个唯一的标识符，将它存入session，并且返回给前端，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p><h3 id="通过重定向实现"><a href="#通过重定向实现" class="headerlink" title="通过重定向实现"></a>通过重定向实现</h3><p>当用户提交表单，服务器端处理后立即转向其他的页面</p><h3 id="使用Cookie处理"><a href="#使用Cookie处理" class="headerlink" title="使用Cookie处理"></a>使用Cookie处理</h3><p>使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单，</p><h3 id="在数据库里添加约束"><a href="#在数据库里添加约束" class="headerlink" title="在数据库里添加约束"></a>在数据库里添加约束</h3><p>在数据库里添加唯一约束或创建唯一索引，防止出现重复数据</p><h3 id="对表单提交数据进行检验"><a href="#对表单提交数据进行检验" class="headerlink" title="对表单提交数据进行检验"></a>对表单提交数据进行检验</h3><p>检查表单的数据是否重复或者是否符合提交要求</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/myon/p/6636934.html" target="_blank" rel="noopener">防止表单重复提交的八种简单有效的策略</a></li><li><a href="https://www.cnblogs.com/xdp-gacl/p/3859416.html" target="_blank" rel="noopener">表单重复提交的常见应用场景</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。&lt;/p&gt;
&lt;h2 id=&quot;问题再现&quot;&gt;&lt;a href=&quot;#问题再现&quot; class=&quot;headerlink&quot; title=&quot;问题再现&quot;&gt;&lt;/a&gt;问题再现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交&lt;/li&gt;
&lt;li&gt;场景二：表单提交后用户点击【刷新】按钮导致表单重复提交&lt;/li&gt;
&lt;li&gt;场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交&lt;/li&gt;
&lt;li&gt;场景四：使用浏览器历史记录重复提交表单。
    
    </summary>
    
      <category term="web综合" scheme="https://datou-y.github.io/categories/web%E7%BB%BC%E5%90%88/"/>
    
    
      <category term="form" scheme="https://datou-y.github.io/tags/form/"/>
    
  </entry>
  
</feed>
