<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java中数组用法和实例详解</title>
      <link href="/posts/4d11ca6.html/"/>
      <url>/posts/4d11ca6.html/</url>
      
        <content type="html"><![CDATA[<p>数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] a=&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">String[] names = <span class="keyword">new</span> String[] &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型</li><li>创建并分配空间在 Java中可以使用<code>new</code>关键字来给数组分配空间<a id="more"></a></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b[<span class="number">0</span>]=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(b[<span class="number">0</span>]);</span><br><span class="line">System.out.println(b.length);</span><br></pre></td></tr></table></figure><ul><li><code>length</code>属性获取数组长度</li><li><code>b[0]</code> 直接通过下标获取数组对应位置元素</li></ul><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">Arrays.sort(b);</span><br><span class="line">Arrays.sort(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer s : b) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Arrays.sort()</code>方法进行数组排序，字符串就按26个字符位置排序，数组就按大小排序</li></ul><h2 id="数组转换集合"><a href="#数组转换集合" class="headerlink" title="数组转换集合"></a>数组转换集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="keyword">for</span> (String s : ls) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a); </span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行反转</span></span><br><span class="line">Collections.reverse(ls);</span><br><span class="line"><span class="keyword">for</span>(String s:ls)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组获取最大值和最小值"><a href="#数组获取最大值和最小值" class="headerlink" title="数组获取最大值和最小值"></a>数组获取最大值和最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line">List&lt;String&gt; ls = Arrays.asList(a);</span><br><span class="line"><span class="comment">//然后调用Collections工具方法进行比较</span></span><br><span class="line">System.out.println(Collections.max(ls));</span><br><span class="line">System.out.println(Collections.min(ls));</span><br></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line">String[] b = &#123;<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>&#125;;</span><br><span class="line"><span class="comment">//先将数组转换为集合</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(a));</span><br><span class="line"><span class="comment">//在调用集合的合并方法</span></span><br><span class="line"></span><br><span class="line">ls.addAll(Arrays.asList(b));</span><br><span class="line">Object[] o = ls.toArray();</span><br><span class="line">System.out.println(Arrays.toString(o));</span><br><span class="line"><span class="keyword">for</span> (Object s : o) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip"><br>注意这里遇到一个坑<br></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s=Arrays.asList(a);</span><br><span class="line">s.add(<span class="string">"1"</span>);</span><br></pre></td></tr></table></figure><ul><li>这样接收的<code>List</code>集合和我们<code>new</code>创建的有区别所以<code>add</code>等方法是又区别的</li><li>参考<a href="https://www.2cto.com/kf/201806/751606.html" target="_blank" rel="noopener">ArrayList报错：UnsupportedOperationException的解决办法</a></li></ul><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> s:a)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/bahcelor/p/6593514.html" target="_blank" rel="noopener">Java关于数组操作函数</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList、LinkedList、Vector的区别和实现原理</title>
      <link href="/posts/57b1f1b.html/"/>
      <url>/posts/57b1f1b.html/</url>
      
        <content type="html"><![CDATA[<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="https://ae01.alicdn.com/kf/HTB1yVDlbUGF3KVjSZFvq6z_nXXaR.jpg" alt><br><a id="more"></a></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>查询，和随机访问效率快，修改比较慢</li><li>数据结构基于<code>数组</code>实现按照顺序将元素存储（从下表为0开始），删除元素时，删除操作完成后，需要使部分元素移位，默认的初始容量为10</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>线程不安全，没有实现同步</li><li>有序的，先添加的元素放在前面，允许<code>null</code>值</li><li>LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部</li><li>查询慢，修改比较慢</li><li><code>LinkedList</code>是基于双向链表实现的（含有头结点）</li></ul><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li><code>Vector</code>属于线程安全级别的大部分的方法都包含关键字<code>synchronized</code></li><li><code>Vector</code>的效率没有ArraykList和LinkedList高</li><li>基于数组实现的</li><li><code>Vector</code>提供<code>indexOf(obj, start)</code>接口，<code>ArrayList</code>没有。</li></ul><h2 id="线程安全实现"><a href="#线程安全实现" class="headerlink" title="线程安全实现"></a>线程安全实现</h2><blockquote><p>ArrayList不具有有线程安全性，在单线程的环境中，LinkedList也是线程不安全的，如果在并发环境下使用它们，可以用Collections类中的静态方法synchronizedList(）对ArrayList和LinkedList进行调用即可。<br>Vector实现线程安全的，即它大部分的方法都包含关键字synchronized,但是Vector的效率没有ArraykList和LinkedList高</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/kuangsonghan/article/details/79861170" target="_blank" rel="noopener">ArrayList、LinkedList、Vector的区别和实现原理</a></li><li><a href="https://blog.csdn.net/u012814441/article/details/80671604" target="_blank" rel="noopener">源码浅析ArrayList、LinkedList和Vector的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和Hashtable的区别和实现原理</title>
      <link href="/posts/425444d1.html/"/>
      <url>/posts/425444d1.html/</url>
      
        <content type="html"><![CDATA[<p>Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分<br>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。<br><a id="more"></a></p><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul><li><code>HashMap</code>和<code>Hashtable</code>都实现了<code>Map</code>接口</li><li><code>HashMap</code>是线程不安全的不允许键值重复,允许空键和空值;由于非线程安全,<code>HashMap</code> 的效率要较 <code>HashTable</code> 的效率高一些.</li><li><code>HashTable</code> 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值</li><li><code>HashTable</code> 是 <code>synchronized</code> 同步的,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步</li><li><code>HashMap</code>的迭代器(<code>Iterator</code>)是<code>fail-fast</code>迭代器，而<code>Hashtable</code>的<code>enumerator</code>迭代器不是<code>fail-fast</code>的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出<code>ConcurrentModificationException</code>，但迭代器本身的<code>remove()</code>方法移除元素则不会抛出<code>ConcurrentModificationException</code>异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>底层数据结构基于数组+链表实现</li></ul><h2 id="HashMap同步"><a href="#HashMap同步" class="headerlink" title="HashMap同步"></a>HashMap同步</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m=Collections.synchronizedMap(map)</span><br></pre></td></tr></table></figure><ul><li><code>Collections</code>类不是集合，这个类里面提供了<code>synchronizedMap</code>方法</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/itcx1213/p/10963751.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></li><li><a href="https://www.cnblogs.com/lchzls/p/6714335.html" target="_blank" rel="noopener">JAVA中HashMap和Hashtable区别</a></li><li><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">HashMap和Hashtable原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中map字典用法和详细实例</title>
      <link href="/posts/f2f0bf25.html/"/>
      <url>/posts/f2f0bf25.html/</url>
      
        <content type="html"><![CDATA[<p>HashMap字典用于存放键值对，<code>&lt;key,value&gt;</code>，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！<br><img src="https://ae01.alicdn.com/kf/HTB1cDhBbUGF3KVjSZFo762mpFXaS.png" alt><br><a id="more"></a></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://ae01.alicdn.com/kf/HTB1TzFBbMmH3KVjSZKz7622OXXas.png" alt></p><h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a>map创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = Hashtable&lt;String, Integer&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>HashMap</code>底层是哈希表数据结构，线程是不同步的也就是线程不安全的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法</li><li><p><code>TreeMap</code>TreeMap可以对集合中的键进行排序</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"tom"</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>put()</code>方法在没有hashCode和equals方式   添加重复的键值（值不同）,会覆盖掉前面key值相同的值</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="string">"tom"</span>);</span><br><span class="line">map.clear();  </span><br><span class="line">map.remove(<span class="string">"tom"</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><ul><li><code>clear()</code>方法清空集合对象  </li><li><code>remove()</code>方法指定key，返回删除的键值对映射的值如果key不存在删除失败，返回null<br>如果同时指定了key，和value删除成功返回true，否则返回false</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.size()</span><br><span class="line">map.get(<span class="string">"toms"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>size()</code>方法获取容器大小,从1开始计算，集合索引从0开始计算</li><li><code>get()</code>方法指定key，获取对应键值，如果key不存在返回null</li></ul><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map.isEmpty()</span><br><span class="line">map.containsKey(<span class="string">"toms"</span>)</span><br><span class="line">map.containsValue(<span class="number">11</span>)</span><br><span class="line">Set&lt;String&gt; key = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String s:key)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; S=map.values();</span><br><span class="line"><span class="keyword">for</span>(Integer s:S)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; es=map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry e:es)&#123;</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>boolean isEmpty()</code>方法判断集合是否为空   长度为0返回true否则false </li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的key </li><li><code>boolean containsValue(Object value)</code>判断集合中是否包含指定的value</li><li><code>Set keySet()</code>方法获取所有的key返回一个<code>Set</code>集合</li><li><code>Collection values()</code>方法获取所有的值返回一个<code>Collection</code>集合</li><li><code>entrySet()</code> 方法获取map所有实体<code>Set</code>集合包含键和值</li></ul><h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br></pre></td></tr></table></figure><p>通过<code>keySet()</code> 获取key  通过key 找到value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Map.Entry(String,Integer)</code> 获取，然后使用<code>entry.getKey()</code>获取到键，通过<code>entry.getValue()</code>获取到值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry e:map.entrySet())&#123;</span><br><span class="line">    System.out.println(e.getValue());</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只遍历键或者值，通过增强for循环<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Integer a:map.values())&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Iterator</code>迭代器来遍历通过<code>getKey</code>获取所有键<code>getValue</code>获取所有值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it= map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; next=it.next();</span><br><span class="line">    String key=next.getKey();</span><br><span class="line">    Integer v=next.getValue();</span><br><span class="line">    System.out.println(<span class="string">"key"</span>+key+<span class="string">"value"</span>+v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Map合并"><a href="#Map合并" class="headerlink" title="Map合并"></a>Map合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"tom"</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">"jack"</span>, <span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"kom"</span>, <span class="number">23</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map1.put(<span class="string">"t"</span>, <span class="number">21</span>);</span><br><span class="line">map1.put(<span class="string">"g"</span>, <span class="number">2</span>);</span><br><span class="line">map.putAll(map1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>putAll()</code>方法可以接收另一个<code>Map</code>让两个集合合并为一个<br><div class="tip"><br><code>Set</code>的元素不可重复，<code>Map</code>的键不可重复<br><code>Set</code>元素重复元素不能存入add方法返回<code>false</code><br><code>Map</code>的重复健将覆盖旧键，将旧值返回。</div></li></ul><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><p>增加<code>for</code>循环进行遍历新增,删除操作会触发<code>fail-fast</code>机制，修改也就是覆盖不会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">    map.put(<span class="string">"jack"</span>,<span class="number">222</span>);</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        map.remove(<span class="string">"jack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用迭代器迭<code>Iterator</code>迭代时候迭代器删除不会触发<code>fail-fast</code>机制只有新增会触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; s=it.next();</span><br><span class="line">    String key=s.getKey();</span><br><span class="line">    Integer value=s.getValue();</span><br><span class="line">    map.put(<span class="string">"s"</span>,<span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"tom"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(key.equals(<span class="string">"jack"</span>))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882#12-set" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/douyu2580860/p/8358768.html" target="_blank" rel="noopener">java基础集合简介Map（三）下</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中List集合用法和实例详解</title>
      <link href="/posts/50eb6371.html/"/>
      <url>/posts/50eb6371.html/</url>
      
        <content type="html"><![CDATA[<p>集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作</p><div class="tip"><br>下面是java中集合框架主要结构图<br></div><p><img src="https://ae01.alicdn.com/kf/HTB1aUHPbBiE3KVjSZFM762QhVXaJ.png" alt><br><a id="more"></a></p><h1 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li><code>List</code>继承自<code>Collection</code>接口，是有序集合,即先放入的元素排在前面允许相同元素和<code>null</code>,实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code></li><li><code>ArrayList</code>非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多</li><li><code>LinkedList</code> 非同步，允许相同元素和null，遍历效率低插入和删除效率高</li><li><code>Vector</code> 同步，允许相同元素和null，效率低</li></ul><h1 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h1><div class="tip"><br>集合的索引，也就是下标是从0开始，长度是从1开始<br></div><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls.add(<span class="string">"a"</span>); </span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="number">2</span>,<span class="string">"c"</span>);</span><br><span class="line">ls.set(<span class="number">0</span>,<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>add()</code>方法添加元素到集合中，也可以指定添加元素到集合指定位置，如果当前位置已经有了其他元素，后面的元素就依次往后移动，如果添加的位置索引不存在就会抛异常</p></li><li><p><code>set()</code>方法替换掉原来位置的元素，如果索引不存在抛异常</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.remove(<span class="string">"a"</span>);</span><br><span class="line">ls.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><code>remove()</code>方法删除元素，可以根据元素删除如果当前元素不存在，或者已经删除就返回false，如果存在删除成功返回true。</li><li>也可以根据索引，也就是下标来删除，如果下标不存在就抛异常，返回删除后的元素信息</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li><code>get()</code>方法获取元素，根据下标获取元素，如果下标不存在抛异常</li></ul><h3 id="清空元素"><a href="#清空元素" class="headerlink" title="清空元素"></a>清空元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls.clear()</span><br></pre></td></tr></table></figure><h3 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls.size()</span><br><span class="line">System.out.println(ls.size());</span><br></pre></td></tr></table></figure><ul><li><code>size()</code> 获取元素个数，从1开始计算</li></ul><h3 id="集合是否为空"><a href="#集合是否为空" class="headerlink" title="集合是否为空"></a>集合是否为空</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f = ls.isEmpty();</span><br><span class="line"><span class="keyword">if</span> (f) &#123;</span><br><span class="line">    System.out.println(<span class="string">"full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合包含某个元素"><a href="#集合包含某个元素" class="headerlink" title="集合包含某个元素"></a>集合包含某个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> f=ls.contains(<span class="string">"g"</span>);</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure><ul><li><code>contains()</code>方法，判断集合包含某个元素，如果存在返回true，否则返回false</li></ul><h3 id="获取元素对应的索引"><a href="#获取元素对应的索引" class="headerlink" title="获取元素对应的索引"></a>获取元素对应的索引</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a= ls.indexOf(<span class="string">"e"</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="keyword">int</span> b=ls.lastIndexOf(<span class="string">"a"</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><ul><li><code>indexOf()</code>方法判断元素对应的索引位置，如果当前元素存在返回对应索引，不存在返回-1</li><li><code>lastIndexOf()</code>方法和<code>indexOf()</code>一样，唯一不同就是当集合中有多个重复元素时候，会返回最后一个元素的下标，也就是索引。</li></ul><h2 id="集合转换为数组"><a href="#集合转换为数组" class="headerlink" title="集合转换为数组"></a>集合转换为数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"d"</span>);</span><br><span class="line">ls.add(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Object[] a=ls.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ls.add(<span class="string">"a"</span>);</span><br><span class="line">ls.add(<span class="string">"b"</span>);</span><br><span class="line">ls.add(<span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for 循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ls.size();i++)&#123;</span><br><span class="line">    System.out.println(ls.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=personList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        String p=iterator.next();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="fail-fast-快速失败-机制"><a href="#fail-fast-快速失败-机制" class="headerlink" title="fail-fast (快速失败)机制"></a>fail-fast (快速失败)机制</h2><blockquote><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException</p></blockquote><ul><li>单线程环境 集合被创建后,在遍历它的过程中修改了结构,会抛异常</li><li>多线程环境 当一个线程在遍历这个集合,而另一个线程对这个集合的结构进行了修改会抛异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList=<span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">Person person=<span class="keyword">new</span> Person();</span><br><span class="line">person.setAge(<span class="number">23</span>);</span><br><span class="line">person.setName(<span class="string">"Tom"</span>);</span><br><span class="line">personList.add(person);</span><br><span class="line">Person person1=<span class="keyword">new</span> Person();</span><br><span class="line">person1.setAge(<span class="number">22</span>);</span><br><span class="line">person1.setName(<span class="string">"jack"</span>);</span><br><span class="line">personList.add(person1);</span><br><span class="line">Iterator&lt;Person&gt; iterator=personList.iterator();</span><br></pre></td></tr></table></figure><p>普通for循环遍历时候修改元素不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;personList.size();i++)&#123;</span><br><span class="line">    Person p=personList.get(i);</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加for循环遍历时候修改元素会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Person p:personList)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        personList.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>迭代器遍历，使用迭代器删除不会触发<code>fail-fast</code>安全机和制抛异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    Person p=iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(p.getAge()==<span class="number">22</span>)&#123;</span><br><span class="line">        <span class="comment">//这里要使用Iterator的remove方法移除当前对象，</span></span><br><span class="line">        <span class="comment">// 如果使用List的remove方法，则同样会出现ConcurrentModificationException</span></span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="集合和数组区别"><a href="#集合和数组区别" class="headerlink" title="集合和数组区别"></a>集合和数组区别</h2><ul><li>数组长度是固定的，集合长度是可变的</li><li>数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li><li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求</li></ul><h2 id="集合案例"><a href="#集合案例" class="headerlink" title="集合案例"></a>集合案例</h2><h3 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="number">1</span>,<span class="string">"b"</span>);</span><br><span class="line">list.add(<span class="string">"c"</span>);</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!list1.contains(list.get(i)))&#123;</span><br><span class="line">        list1.add(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list1)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环list中的所有元素然后删除重复<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = list.size() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">            list.remove(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过HashSet踢除重复元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h=<span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">h.addAll(list);</span><br><span class="line">list.clear();</span><br><span class="line">list.addAll(h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新版本的 JDK 可以支持 Stream 流操作，因此集合去重可以简单的使用下述语句来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="集合合并"><a href="#集合合并" class="headerlink" title="集合合并"></a>集合合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list1=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">"c"</span>);</span><br><span class="line">list1.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.addAll(list1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/B_evan/article/details/80611522" target="_blank" rel="noopener">Java集合（一）什么是集合</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82354205#2-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">Java基础List详解</a></li><li><a href="https://blog.csdn.net/qq_26807245/article/details/82178882" target="_blank" rel="noopener">Java集合类详解</a></li><li><a href="https://www.cnblogs.com/cainiao-Shun666/p/7911142.html" target="_blank" rel="noopener">Java中List集合去除重复数据的方法</a></li><li><a href="https://www.cnblogs.com/Luouy/p/6482733.html" target="_blank" rel="noopener">JAVA List合并集合</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql复杂的sql语句查询案例之GROUP BY系列</title>
      <link href="/posts/1077e6d7.html/"/>
      <url>/posts/1077e6d7.html/</url>
      
        <content type="html"><![CDATA[<p>sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组，</p><p><div class="tip"><br>    GROUP BY必须得配合聚合函数来用,聚合后的表其他列不能再select查询项中<br></div><br>分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等。</p><a id="more"></a><h2 id="常用的聚合函数"><a href="#常用的聚合函数" class="headerlink" title="常用的聚合函数"></a>常用的聚合函数</h2><ul><li>count() 计数</li><li>sum() 求和</li><li>avg() 平均数</li><li>max() 最大值</li><li>min() 最小值</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="学生信息"><a href="#学生信息" class="headerlink" title="学生信息"></a>学生信息</h3><p>班级表<br><img src="https://ae01.alicdn.com/kf/HTB1_FB2aMKG3KVjSZFL761MvXXab.png" alt><br>学生表<br><img src="https://ae01.alicdn.com/kf/HTB1uqh3aLWG3KVjSZPc762kbXXa0.png" alt><br>成绩表<br><img src="https://ae01.alicdn.com/kf/HTB1HAB4aROD3KVjSZFF763n9pXaZ.png" alt></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.jianshu.com/p/8b135d373df1" target="_blank" rel="noopener">SQL中GROUP BY用法示例</a></li><li><a href="https://blog.csdn.net/zhu940923/article/details/81084080" target="_blank" rel="noopener">查询每班分数最高的学生</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防止表单重复提交的多种策略手段</title>
      <link href="/posts/9fe2dfd3.html/"/>
      <url>/posts/9fe2dfd3.html/</url>
      
        <content type="html"><![CDATA[<p>在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。</p><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><ul><li>场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交</li><li>场景二：表单提交后用户点击【刷新】按钮导致表单重复提交</li><li>场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交</li><li>场景四：使用浏览器历史记录重复提交表单。<a id="more"></a></li></ul><h2 id="问题方案"><a href="#问题方案" class="headerlink" title="问题方案"></a>问题方案</h2><h3 id="利用JavaScript防止表单重复提交"><a href="#利用JavaScript防止表单重复提交" class="headerlink" title="利用JavaScript防止表单重复提交"></a>利用JavaScript防止表单重复提交</h3><ol><li><p>表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮</p></li><li><p>用JavaScript控制Form表单只能提交一次阻止submit提交事件第二次提交</p></li><li><p>另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。</p></li></ol><div class="tip"><br>    使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题<br></div><h3 id="利用Session防止表单重复提交"><a href="#利用Session防止表单重复提交" class="headerlink" title="利用Session防止表单重复提交"></a>利用Session防止表单重复提交</h3><blockquote><p>对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到<code>session</code>了。</p></blockquote><p>在服务器端，生成一个唯一的标识符，将它存入session，并且返回给前端，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。</p><h3 id="通过重定向实现"><a href="#通过重定向实现" class="headerlink" title="通过重定向实现"></a>通过重定向实现</h3><p>当用户提交表单，服务器端处理后立即转向其他的页面</p><h3 id="使用Cookie处理"><a href="#使用Cookie处理" class="headerlink" title="使用Cookie处理"></a>使用Cookie处理</h3><p>使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单，</p><h3 id="在数据库里添加约束"><a href="#在数据库里添加约束" class="headerlink" title="在数据库里添加约束"></a>在数据库里添加约束</h3><p>在数据库里添加唯一约束或创建唯一索引，防止出现重复数据</p><h3 id="对表单提交数据进行检验"><a href="#对表单提交数据进行检验" class="headerlink" title="对表单提交数据进行检验"></a>对表单提交数据进行检验</h3><p>检查表单的数据是否重复或者是否符合提交要求</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.cnblogs.com/myon/p/6636934.html" target="_blank" rel="noopener">防止表单重复提交的八种简单有效的策略</a></li><li><a href="https://www.cnblogs.com/xdp-gacl/p/3859416.html" target="_blank" rel="noopener">表单重复提交的常见应用场景</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> form </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？</title>
      <link href="/posts/c7fb8024.html/"/>
      <url>/posts/c7fb8024.html/</url>
      
        <content type="html"><![CDATA[<p>要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：<code>jpg</code>、<code>gif</code>、<code>png</code>和<code>svg</code>。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？<code>logo</code>应该是选择 <code>svg</code> 还是 <code>png</code> ？而截图是选 <code>jpg</code> 还是 <code>png</code> 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。</p><p>在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。</p><a id="more"></a><h2 id="先来看几个概念"><a href="#先来看几个概念" class="headerlink" title="先来看几个概念"></a>先来看几个概念</h2><ul><li>有损(<code>Lossless</code>)和无损(<code>Lossy</code>)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。</li><li>索引色(<code>Indexed color</code>)和直接色(<code>Direct color</code>)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。</li><li>光栅格式(<code>raster</code>)和矢量格式(<code>vector</code>)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 <code>Photoshop</code> 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。</li></ul><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p><code>JEPG</code>由联合图像专家小组（<code>Joint Photographic Experts Group</code>）于1992年创建，并以创建者命名。<code>JPEG</code>是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。</p><p>因为 <code>JPEG</code> 压缩在亮度和色彩上面的优越性，所以 <code>JPEG</code> 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。</p><p><code>JPEG</code> 的压缩可以用 <code>Photoshop</code> 里存储为 <code>web</code> 格式的时候可以直接选择压缩品质，一般用于 <code>web</code> 的 <code>JPG</code> 图片选择 <code>50%-60%</code> 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 <code>TinyJPG</code>。</p><p>下面这个图，我用的是 <code>50%</code>的品质压缩出来的 <code>JPG</code>，很明显质量要比 <code>GIF</code> 的要好很多，而且文件尺寸也小不少。</p><p><img src="../../../../images/201706/webgra_01.png" alt="webgra_01"></p><blockquote><p><code>JPEG</code> 和 <code>JPG</code> 的区别：<code>JPEG</code> 更多的指的是 <code>.jpg</code> 图像格式的一种压缩算法，而 <code>JPG</code> 就是一种图像存储的格式。</p></blockquote><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>可移植网络图形（<code>Portable Network Graphics</code>）也是一种自1995年以来就一直存在的光栅图像格式。它与 <code>JPEG</code> 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。</p><h3 id="PNG格式"><a href="#PNG格式" class="headerlink" title="PNG格式"></a>PNG格式</h3><p><code>PNG</code>其实可以细分为好几个格式的，有<code>PNG 8</code>、<code>PNG 24</code>和<code>PNG 32</code>。那么怎么区分一个 <code>PNG</code> 图片是什么格式的呢？</p><p><img src="../../../../images/201706/webgra_02.png" alt="png_24"></p><p>打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 <code>PNG 24</code> 格式的图片。同样，<code>PNG 8</code> 和 <code>PNG 32</code> 的位深度分别是8和32。</p><blockquote><p>位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 <code>PNG 8</code> 最多只能存储256种颜色。<code>PNG 24</code> 和 <code>PNG 32</code>又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；<code>PNG 32</code>中剩余的8位存储的是<code>Alpha</code> 通道的透明色。</p></blockquote><p>然后如何生成这些不同格式的图片呢？<br>自然是用专业的图像处理软件啦，比如可以用 <code>Photoshop</code> 或者 <code>Fireworks</code>。这里以 <code>Photoshop</code> 为例子，文件-&gt;存储为 <code>Web</code> 所用格式， 可以看到下拉这里只有 <code>PNG-8</code> 和 <code>PNG-24</code>，而没有 <code>PNG-32</code> 呢？是因为 <code>Photoshop</code>不支持这个格式嘛？并不是。</p><p><img src="../../../../images/201706/webgra_04.png" alt="png_generate"></p><p>在 <code>Photoshop</code> 里导出 <code>PNG-32</code> 格式的图片是通过选择 <code>PNG-24</code>格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 <code>PNG-24</code> 格式。由此看来 <code>PNG-24</code> 是不支持透明的，<code>PNG-32</code> 是支持透明的。</p><h3 id="PNG透明度"><a href="#PNG透明度" class="headerlink" title="PNG透明度"></a>PNG透明度</h3><p>从 <code>Fireworks 8</code>的优化面板里可以看到 <code>PNG</code> 格式存在三种透明格式：不透明、索引透明和 <code>Alpha</code>透明。</p><p><img src="../../../../images/201706/webgra_05.png" alt="png_transparency"></p><ul><li><p><code>PNG 8</code>透明度</p><p>  从上面那个图里可以看出 <code>PNG 8</code> 是支持这三种不透明格式的。但是 <code>Photoshop</code> 只支持导出不透明和索引透明格式。在<code>Photoshop</code> 中如果选择 <code>PNG 8</code>，且勾选了透明度，那么导出的图片就是 <code>PNG 8</code> 索引透明，否则就是 <code>PNG 8</code> 不透明。</p><p>  <img src="../../../../images/201706/webgra_06.png" alt="png_8_index"></p><p>  用 <code>Photoshop</code> 和 <code>Fireworks 8</code> 导出 <code>PNG 8</code> 的各种格式如下所示：</p><p>  <img src="../../../../images/201706/webgra_03.png" alt="png_8_transparency"></p><p>  根据以上图片我们可以得出结论：</p><ul><li><code>Photoshop</code> 导出的 <code>PNG 8</code> 图片都带有锯齿。</li><li><p><code>PNG 8</code> 索引透明都带有锯齿，且 <code>Fireworks 8</code> 导出的 <code>PNG 8</code>索引透明的锯齿是白色的。</p><p>再来看看这些格式在不同浏览器下的表现情况：</p><p><img src="../../../../images/201706/webgra_07.png" alt="png_8_Compatibility"></p><p>根据以上图片我们可以得出结论：</p></li><li><p><code>PNG 8</code> 索引透明和 <code>Alpha</code> 透明都兼容<code>IE 6</code>；但美中不足的是，<code>PNG 8Alpha</code>透明在 <code>IE 6</code>下会产生锯齿。</p></li><li>其他格式的图片在各个浏览器下的表现一致。</li><li><code>Fireworks 8</code>导出的 <code>PNG 8</code>索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。</li></ul></li><li><p><code>PNG 24</code> 和 <code>PNG 32</code></p><p>  <code>PNG 24</code> 是不透明的；<code>PNG 32</code> 是支持透明的，且是 <code>Alpha</code> 透明。来看下它们在不同浏览器下的表现：</p><p>  <img src="../../../../images/201706/webgra_08.png" alt="png_2432_Compatibility"></p><p>  <code>PNG 32</code> 图片的透明区域在 <code>IE 6</code> 下将不再透明，而是颜色值为 <code>f0f0f0</code> 的灰色填充，在更高级版本的 <code>IE</code> 下是正常的。<code>PNG 32</code> 图片不会有锯齿。</p></li></ul><h3 id="PNG压缩"><a href="#PNG压缩" class="headerlink" title="PNG压缩"></a>PNG压缩</h3><p>本文前面提到了 <code>JPEG</code> 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 <code>PNG</code> 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 <a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a>，这个工具可以压缩 <code>JPEG</code> 和 <code>PNG</code> 格式。</p><p><img src="../../../../images/201706/webgra_09.png" alt="png_jpeg"></p><p>从上图这个图中，我们可以从不同角度得出一些结论：</p><ul><li><code>PNG 8</code> 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以<code>PNG 8</code>不适合用于存储颜色复杂的图像。相反，由于其相对于 <code>PNG 24</code> 或者 <code>PNG 32</code> 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。</li><li>对比100%质量的 <code>JPG</code>、55%质量的 <code>JPG</code>、<code>PNG 24</code> 和 <code>PNG 32</code>，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 <code>JPG</code> 占用存储最小；压缩后，<code>PNG 24</code> 和 <code>PNG 32</code> 一样，会比55%质量的 <code>JPG</code> 小一些，但是由于 <code>PNG 32</code> 支持透明，所以对于颜色丰富的图像建议用 <code>PNG 32</code> 格式导出，然后用压缩工具压缩一下即可。</li><li>对比压缩前后的 <code>PNG 24</code> 和 <code>PNG 32</code> 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 <code>web</code> 上的 <code>PNG 24</code> 或 <code>PNG 32</code> 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。</li></ul><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>图形交换格式（<code>Graphics Interchange Format</code>）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 <code>IE 6</code> 下也支持得很好，唯一美中不足的是除了 <code>Fireworks 8</code> 导出的 <code>GIF</code> 不透明格式外，所有的其他 <code>GIF</code> 格式的图片都存在锯齿。</p><p><img src="../../../../images/201706/webgra_10.png" alt="gif"></p><p>但是 <code>GIF</code> 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画：</p><p><img src="../../../../images/201706/traffic-light.gif" alt="gif_ani"></p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>可伸缩矢量图形（<code>Scalable Vector Graphics</code>），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 <code>SVG</code> 相对于光栅格式的图像具有以下优势：</p><ul><li>任意伸缩图像，而不会破坏图像的清晰度和细节。</li><li>完全支持 <code>DOM</code>，以及 <code>JavaScript</code> 能够很好的访问到它。</li><li>总体来讲，<code>SVG</code>的文件会比 <code>GIF</code> 或 <code>JPG</code> 的会小很多。</li></ul><p>就像其它矢量格式，<code>SVG</code> 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 <code>Retina</code> 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片：</p><p><img src="../../../../images/201706/webgra_11.png" alt="svg"></p><h2 id="SVG用途"><a href="#SVG用途" class="headerlink" title="SVG用途"></a>SVG用途</h2><p><code>SVG</code> 在线条艺术，<code>LOGO</code>，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，<code>SVG</code> 和 <code>PNG</code> 都能很好地达到同一个目的。对于线条艺术，<code>SVG</code> 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 <code>SVG</code> 真正出色的地方是数据可视化。由于可以使用<code>JavaScript</code> 来操纵和创建矢量动画，诸如 <code>D3</code> 之类的库提供了无限的可能性。<code>LOGO</code>, 图标和数据可视化是 <code>SVG</code> 使用的优秀范例。</p><p><img src="../../../../images/201706/webgra_12.png" alt="svg_use"></p><h2 id="SVG压缩"><a href="#SVG压缩" class="headerlink" title="SVG压缩"></a>SVG压缩</h2><p>比较好的 <code>SVG</code> 方法应该是通过清除 <code>SVG</code> 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 <code>Adobe Illustrator</code> 编辑 <code>SVG</code>，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。</p><p><img src="../../../../images/201706/webgra_13.png" alt="svg_compress"> </p><p>清理不必要的节点是缩减 <code>SVG</code> 尺寸的一种途径。<br>元素标签是包含在 <code>SVG</code> 文件内的所有内容，包括开始和结束标签。<br>矢量编辑软件，如 <code>Adobe Illustrator</code> 和 <code>Sketch</code> 可能会到处含有非必要元素和属性的 <code>SVG</code> 。<br><code>SVG</code> 压缩器可用于删除这种多余的信息。<code>Compresso</code> 和 <code>SVGOMG</code> 等在线工具可以完成此工作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://web.jobbole.com/91599/" target="_blank" rel="noopener">在网页上使用JPG、PNG和SVG：新手指南</a></li><li><a href="http://www.cnblogs.com/PeunZhang/archive/2013/05/30/3050394.html" target="_blank" rel="noopener">PNG使用技巧</a></li><li><a href="https://stackoverflow.com/questions/2336522/png-vs-gif-vs-jpeg-vs-svg-when-best-to-use" target="_blank" rel="noopener">PNG vs. GIF vs. JPEG vs. SVG - When best to use?</a></li><li><a href="https://www.sitepoint.com/gif-png-jpg-which-one-to-use/" target="_blank" rel="noopener">JPG vs PNG vs GIF vs SVG – What is the Difference?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
            <tag> 图像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome开发者工具实用小技巧</title>
      <link href="/posts/d7262aae.html/"/>
      <url>/posts/d7262aae.html/</url>
      
        <content type="html"><![CDATA[<p><code>chrome</code> 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 <code>chrome</code> 开发者工具都有哪些很常用或实用的功能。<br>写这篇文章的时候，chrome的版本如下：</p><p><img src="../../../../images/201703/chrome_01.png" alt="chrome版本"></p><a id="more"></a><h2 id="Elements面板篇"><a href="#Elements面板篇" class="headerlink" title="Elements面板篇"></a>Elements面板篇</h2><ul><li><p>在 <code>Elements</code> 面板中，使用 <code>Ctrl + F</code> 打开搜索输入框，可以输入常规字符串或选择器来选择 <code>HTML</code> 元素。</p><p>  <img src="../../../../images/201703/chrome_02.png" alt="ctrl+f"></p></li><li><p>在元素前面的小黑三角上用 <code>Alt +</code> 鼠标左键即可展开收起当前元素下的所有子元素。</p><p>  <img src="../../../../images/201703/chrome_03.png" alt="alt+left"></p></li><li><p>css数值使用快捷键调整：</p><ul><li><code>Up / Down</code>：增加减少1</li><li><code>Ctrl + Up / Ctrl + Down</code>：增加减少100</li><li><code>Shift + Up / Shift + Down</code>：增加减少10</li><li><code>Alt + Up / Alt + Down</code>： 增加减少0.1</li><li><p><code>Up / Down</code> 等同于鼠标滚轮</p><p><img src="../../../../images/201703/chrome_04.png" alt="css-number-value"></p></li></ul></li><li><p>查看事件监听器。选中一个元素，然后点击 <code>Event Listeners</code> 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 <code>handler</code>，右键单击选择 <code>Show function definition</code> 即可在 <code>Source</code> 面板中打开且定位到当前事件的处理函数的所在位置。</p><p>  <img src="../../../../images/201703/chrome_05.png" alt="event-listeners"></p></li><li><p>点击颜色方格会打开 <code>chrome</code> 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( <code>toggle color picker</code> )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，<code>Color Palettes</code> 里分3小块，分别是：<code>Material Design</code>，一组符合 <code>Material Design</code> 规范的颜色；<code>Page Colors</code>，一组从页面的 <code>CSS</code> 自动生成的颜色；<code>Custom</code>，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 <code>chrome</code> 的 <code>DevTools</code> 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。</p><p>  <img src="../../../../images/201703/chrome_06.png" alt="color-palette"></p></li><li><p>可视化 <code>Shadow DOM</code>。在 <code>dom</code> 元素列表中，都是我们写的看得见的元素。其实在构建 <code>dom</code> 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 <code>Settings</code> -&gt; <code>Preferences</code> -&gt; <code>Elements</code> 下的 <code>Show user agent shadow DOM</code> 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。</p><p>  <img src="../../../../images/201703/chrome_07.png" alt="shadow-dom"></p></li><li><p>给元素添加状态。元素有4种用户行为状态：:<code>active</code>、<code>:hover</code>、<code>:focus</code>、<code>:visited</code>。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 <code>Styles</code>面板中进行设置。</p><p>  <img src="../../../../images/201703/chrome_08.png" alt="ele-state"></p></li><li><p>使用 <code>Tab</code> 键可以在 <code>CSS</code> 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 <code>Shift + Tab</code>。但是再使用快捷键切换选定之前需要先让光标在 <code>Styles</code> 面板，处于输入状态即可。</p></li></ul><h2 id="Console面板篇"><a href="#Console面板篇" class="headerlink" title="Console面板篇"></a>Console面板篇</h2><ul><li><p>使用 <code>$0-$4</code> 选择元素。<code>$0</code> 返回最后一次选择的元素，<code>$1</code> 返回仅在最后一次之前选择的元素，以此类推。<code>$(selector)</code> 返回带有指定 <code>CSS</code> 选择器的第一个DOM元素的引用。<code>$$(selector)</code> 返回 <code>CSS</code> 选择所有匹配的元素数组。</p><p>  <img src="../../../../images/201703/chrome_09.png" alt="$_selector"></p>  <div class="tip"><br>      如果页面使用了类 <code>Jquery</code> 库，则 <code>$(selector)</code> 功能将被覆盖， <code>$</code> 将与该库的实现对应。<br>  </div></li><li><p>一些实用的方法:</p><ul><li><code>console.log()</code>、<code>console.info()</code>、<code>console.warn()</code>、<code>console.error()</code>打印不同的状态信息</li><li><p>使用CSS设置控制台输出样式，利用CSS格式说明符%c。</p><p>  <img src="../../../../images/201703/chrome_17.png" alt="css-format"></p></li><li><p><code>copy(object)</code>，将指定对象的字符串表示复制到剪贴板。</p></li><li><p><code>getEventListeners(object)</code>，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 <code>Event Listeners</code> 面板那边 <code>show function definition</code> 那样的功能。</p><p>  <img src="../../../../images/201703/chrome_13.png" alt="ctrl+p"></p></li><li><p><code>inspect(elem)</code>， 跳转到 <code>Elements</code> 面板的指定元素节点</p></li></ul></li><li><p><code>console.time(str)</code> 和 <code>console.timeEnd(str)</code> 返回这中间间隔的时间。下图的 <code>4.24e+3ms</code> 是数字的科学计数法表示，表示的实际值是：<code>4.24*10*10*10ms</code>，即4.24秒。</p><p>  <img src="../../../../images/201703/chrome_12.png" alt="console.time"></p></li></ul><h2 id="Sources面板篇"><a href="#Sources面板篇" class="headerlink" title="Sources面板篇"></a>Sources面板篇</h2><ul><li><p><code>Ctrl + Shift + F</code>，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 <code>className</code> 或者 <code>id</code> 把这个文件找出来。</p></li><li><p><code>Ctrl + P</code>，根据文件名查找所有站内资源文件。</p><p>  <img src="../../../../images/201703/chrome_11.png" alt="ctrl+p"></p></li><li><p>漂亮打印。对于 <code>Sources</code> 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。</p><p>  <img src="../../../../images/201703/chrome_14.png" alt="pretty-print"></p></li><li><p>在 <code>Sources</code> 面板中找到图片资源，然后在图片上右键即可获取图片的 <code>Data URI</code>。</p><p>  <img src="../../../../images/201703/chrome_15.png" alt="data-uri"></p></li><li><p>使用 <code>console.dir( ele )</code> 将 <code>DOM</code> 元素格式化为 <code>JavaScript</code> 对象</p><p>  <img src="../../../../images/201703/chrome_18.png" alt="console.dir"></p></li><li><p>在 <code>Sources</code> 面板编辑文件小技巧</p><ul><li>使用 <code>Ctrl + p</code> 打开输入框输入 <code>:20:30</code> 回车后，光标位置将跳转到当前文件的第20行第30列</li><li>使用使用 <code>Alt + -</code> 和 <code>Alt + =</code> 可以在上一个鼠标位置和下一个鼠标位置之间跳转</li><li>使用 <code>Ctrl +</code> 鼠标左键可以添加多个光标输入位置</li><li><p>使用 <code>Alt +</code> 鼠标拖动可以拉出一块矩形选区</p><p>  <img src="../../../../images/201703/chrome_16.png" alt="alt-move"></p></li></ul></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">chrome-devtools</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题的安装和使用</title>
      <link href="/posts/4a1d4f4f.html/"/>
      <url>/posts/4a1d4f4f.html/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客框架有很多第三方主题，我们可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题官网</a>去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是<a href="https://github.com/bulandent/hexo-theme-bubuzou" target="_blank" rel="noopener">bubuzou</a></p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul><li>官网下载好主题后放在博客的<code>themes</code>文件夹下</li><li>然后修改根目录<code>_config.yml</code>文件的<code>theme</code>配置为当前下载的主题文件夹名称</li><li>然后根据每个主题的使用文档修改下载的对应主题文件夹下的<code>_config.yml</code>来配置对应主题功能<div class="tip"><br>  这里我以<a href="https://bubuzou.com/" target="_blank" rel="noopener">bubuzou</a>主题为例<br></div></li></ul><a id="more"></a><p>配置这个主题需要注意的点</p><ul><li>他的评论，文章阅读次数，功能用的LeanCloud需要自己注册，对应的LeanCloud统计次数class是Timer不是Counter否则会出现访问次数没有</li><li><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud官网</a></li></ul><blockquote><p>主题文档  <a href="https://github.com/bulandent/hexo-theme-bubuzou/blob/master/doc/doc-zh.md" target="_blank" rel="noopener">bubuzou</a></p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/y_z_w123/article/details/78801096" target="_blank" rel="noopener">hexo的安装和主题的替换</a></li><li><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">hexo教程系列</a> </li><li><a href="https://blog.csdn.net/lijing742180/article/details/87928554" target="_blank" rel="noopener">Hexo博客使用LeanCloud统计页面访问次数</a></li><li><a href="https://www.jianshu.com/p/b4b758ee81dd" target="_blank" rel="noopener">leanCloud的使用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo Themes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-abbrlink插件使用</title>
      <link href="/posts/32d54ad4.html/"/>
      <url>/posts/32d54ad4.html/</url>
      
        <content type="html"><![CDATA[<p>这是一个<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">Hexo plugin</a>基于文章标题用来生成静态文章链接。查看官方文档<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a>获得详细使用信息</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="How-to-install"><a href="#How-to-install" class="headerlink" title="How to install"></a>How to install</h3><p>Add plugin to Hexo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></p><h3 id="Modify-permalink-in-config-yml-file"><a href="#Modify-permalink-in-config-yml-file" class="headerlink" title="Modify permalink in config.yml file:"></a>Modify permalink in config.yml file:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html/</span><br></pre></td></tr></table></figure><h3 id="There-are-two-settings"><a href="#There-are-two-settings" class="headerlink" title="There are two settings:"></a>There are two settings:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)</span><br><span class="line">rep -- Represent (the generated link could be presented in hex or dec value)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  #support crc16(default) and crc32</span><br><span class="line">  rep: hex    #support dec(default) and hex</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><p>The generated link will look like the following:</p><blockquote><p>crc16 &amp; hex<br><a href="https://post.zz173.com/posts/66c8.html" target="_blank" rel="noopener">https://post.zz173.com/posts/66c8.html</a><br>crc16 &amp; dec<br><a href="https://post.zz173.com/posts/65535.html" target="_blank" rel="noopener">https://post.zz173.com/posts/65535.html</a></p></blockquote><blockquote><p>crc32 &amp; hex<br><a href="https://post.zz173.com/posts/8ddf18fb.html" target="_blank" rel="noopener">https://post.zz173.com/posts/8ddf18fb.html</a><br>crc32 &amp; dec<br><a href="https://post.zz173.com/posts/1690090958.html" target="_blank" rel="noopener">https://post.zz173.com/posts/1690090958.html</a></p></blockquote><h2 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h2><p>Maximum number of posts is 65535 for crc16. (For a personal blog site, this number is decent)</p><h2 id="More-info"><a href="#More-info" class="headerlink" title="More info"></a>More info</h2><p>see  <a href="https://post.zz173.com/detail/hexo-abbrlink.html" target="_blank" rel="noopener">this</a>(Chinese)</p><h2 id="ThanksFor"><a href="#ThanksFor" class="headerlink" title="ThanksFor"></a>ThanksFor</h2><p><a href="https://github.com/NoahDragon" target="_blank" rel="noopener">NoahDragon</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> Hexo Plugins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速、简洁且高效的博客框架Hexo</title>
      <link href="/posts/4a17b156.html/"/>
      <url>/posts/4a17b156.html/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是一个快速、简洁且高效的博客框架，查看官方文档 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> 找到答案，或者你可以询问我<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Clean-cache"><a href="#Clean-cache" class="headerlink" title="Clean cache"></a>Clean cache</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://easyhexo.com/" target="_blank" rel="noopener">Easy Hexo 👨‍💻</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
