{"meta":{"title":"随记","subtitle":null,"description":"良好的学习习惯，能够提高工作、生活效率。所以阶段总结反省，随记很重要。","author":"daTou","url":"https://datou-y.github.io","root":"/"},"pages":[],"posts":[{"title":"IDEA工具开发使用@Autowired注解报错解决方案 ","slug":"dev-problem","date":"2019-06-16T01:55:51.289Z","updated":"2019-06-16T02:07:13.060Z","comments":true,"path":"posts/794ce61d.html/","link":"","permalink":"https://datou-y.github.io/posts/794ce61d.html/","excerpt":"使用IDEA工具进行开发的时候,需要@Autowired自动注解bean时会报红线,但是项目依然能够运行点击File--》Project Structure...--》Facets删除右边对应的spring模块对应的IDEA版本仅限于如下版本","text":"使用IDEA工具进行开发的时候,需要@Autowired自动注解bean时会报红线,但是项目依然能够运行点击File--》Project Structure...--》Facets删除右边对应的spring模块对应的IDEA版本仅限于如下版本","categories":[{"name":"问题","slug":"问题","permalink":"https://datou-y.github.io/categories/问题/"}],"tags":[{"name":"problem","slug":"problem","permalink":"https://datou-y.github.io/tags/problem/"}]},{"title":"Spring Boot 2.x(四):整合Mybatis的四种方式","slug":"spring-boot-mybatis","date":"2019-06-15T13:16:19.128Z","updated":"2019-06-15T13:21:45.074Z","comments":true,"path":"posts/7f83a289.html/","link":"","permalink":"https://datou-y.github.io/posts/7f83a289.html/","excerpt":"目前的大环境下，使用Mybatis作为持久层框架还是占了绝大多数的，下面我们来说一下使用Mybatis整合Spring Boot的几种姿势。","text":"目前的大环境下，使用Mybatis作为持久层框架还是占了绝大多数的，下面我们来说一下使用Mybatis整合Spring Boot的几种姿势。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://datou-y.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://datou-y.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot入门快速搭建web项目","slug":"spring-boot-fast","date":"2019-06-15T01:21:26.064Z","updated":"2019-06-15T13:14:01.906Z","comments":true,"path":"posts/914fc93.html/","link":"","permalink":"https://datou-y.github.io/posts/914fc93.html/","excerpt":"什么是Spring BootSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 使用 Spring Boot 有什么好处 配置 web.xml，加载 Spring 和 Spring mvc 配置数据库连接、配置 Spring 事务 配置加载配置文件的读取，开启注解 配置日志文件 … 配置完成之后部署 Tomcat 调试 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍! 但是如果使用 Spring Boot 呢？很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！ 使用 Spring Boot 到底有多爽，用下面这幅图来表达","text":"什么是Spring BootSpring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 使用 Spring Boot 有什么好处 配置 web.xml，加载 Spring 和 Spring mvc 配置数据库连接、配置 Spring 事务 配置加载配置文件的读取，开启注解 配置日志文件 … 配置完成之后部署 Tomcat 调试 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍! 但是如果使用 Spring Boot 呢？很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！ 使用 Spring Boot 到底有多爽，用下面这幅图来表达 官网在线搭建 访问官网 https://start.spring.io/ 选择构建工具 Maven Project、语言Java、Spring Boot版本 Project Metadata 工程基本信息 点击 Generate Project下载项目压缩包 解压后，使用 Idea 导入项目，File -&gt; New -&gt; Model from Existing Source.. -&gt;选择解压后的文件夹 -&gt;OK，选择 Maven 一路 Next，OK done! 通过Intellij IDEA搭建 选择 File -&gt; New —&gt; Project… 弹出新建项目的框 选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成 填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish 如果使用的是 Eclipse， Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹 -&gt; Finsh，OK done! 项目结构介绍 如上图所示，Spring Boot 的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外， Spring Boot 建议的目录结果如下：root package 结构：com.example.myproject123456789101112131415com +- example +- myproject +- Application.java | +- model | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到根目录下面,主要用于做一些框架配置 model 目录主要用于实体与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改最后，启动 Application main 方法，至此一个 Java 项目搭建好了！ 快速入门 pom.xml中添加支持web的模块：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml 文件中默认有两个模块:spring-boot-starter ：核心模块，包括自动配置支持、日志和 YAMLspring-boot-starter-test ：测试模块，包括 JUnit、Hamcrest、Mockitospring-boot-starter-web 自动依赖了 spring-boot-starter加了web模块后可以去掉spring-boot-starter模块 编写 Controller 内容：1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/hello\") public String index() &#123; return \"Hello World\"; &#125;&#125; @RestController 的意思就是 Controller 里面的方法都以 json 格式输出，不用再写什么 jackjson 配置的了！ 启动主程序，打开浏览器访问 http://localhost:8080/hello，就可以看到效果了，有木有很简单！ GitHub示例代码 参考文献 SpringBoot入门，快速搭建简单Web应用环境 Spring Boot(一)：入门篇","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://datou-y.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://datou-y.github.io/tags/Spring-Boot/"}]},{"title":"java中数据类型分类","slug":"java-data-type","date":"2019-06-13T13:04:29.649Z","updated":"2019-06-13T13:17:55.523Z","comments":true,"path":"posts/2b16cdcb.html/","link":"","permalink":"https://datou-y.github.io/posts/2b16cdcb.html/","excerpt":"","text":"区别表","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[]},{"title":"mysql查询结果去除重复数据","slug":"mysql-repeat","date":"2019-06-12T13:57:50.756Z","updated":"2019-06-13T09:52:43.335Z","comments":true,"path":"posts/e1a86da4.html/","link":"","permalink":"https://datou-y.github.io/posts/e1a86da4.html/","excerpt":"distinct去重12select distinct st.stu_name from student stwhere st.stu_name is not null; group by12# 删选出重复数据select a from A group by a having count(*)&gt;1","text":"distinct去重12select distinct st.stu_name from student stwhere st.stu_name is not null; group by12# 删选出重复数据select a from A group by a having count(*)&gt;1","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[]},{"title":"mysql查询字段为null的处理","slug":"mysql-null","date":"2019-06-12T10:43:41.101Z","updated":"2019-06-12T14:15:11.116Z","comments":true,"path":"posts/8a034c1e.html/","link":"","permalink":"https://datou-y.github.io/posts/8a034c1e.html/","excerpt":"通过is (not) null进行where条件判断处理 1select a from A where a is not null 通过 case when进行逻辑语句上的判断123456789101112select ( case when a is null then '' when a=\"a\" then \"b\" else \"idbs\" end ) as cfrom A","text":"通过is (not) null进行where条件判断处理 1select a from A where a is not null 通过 case when进行逻辑语句上的判断123456789101112select ( case when a is null then '' when a=\"a\" then \"b\" else \"idbs\" end ) as cfrom A 通过IFNULL函数进行判断1select ifnull(a,\"b\") from A ifnull(a,&quot;b&quot;)第一个参数是你要查询字段，第二个是字段为null是的值 null值概念 空值是不占用空间的。 mysql中的NULL其实是占用空间的,打个比方来说，你有一个杯子，空值代表杯子是真空的，NULL代表杯子中装满了空气，虽然杯子看起来都是空的，但是区别是很大的 NOT NULL 的字段是不能插入“NULL”的，只能插入“空值” 总结 在进行count()统计某列的记录数的时候，如果采用的NULL值，系统会自动忽略掉，但是空值是会进行统计到其中的。 判断NULL 用IS NULL 或者 IS NOT NULL, SQL语句函数中可以使用ifnull()函数来进行处理，判断空字符用=&#39;&#39;或者 &lt;&gt;&#39;&#39;来进行处理 对于MySQL特殊的注意事项，对于timestamp数据类型，如果往这个数据类型插入的列插入NULL值，则出现的值是当前系统时间。插入空值，则会出现 0000-00-00 00:00:00对于空值的判断到底是使用is null 还是=&#39;&#39; 要根据实际业务来进行区分。 参考文献 mysql查询字段为null时，返回空字符串 MySQL判断字段是否为null","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[]},{"title":"java全能最新自己面试企业真题总结","slug":"java-work","date":"2019-06-12T09:44:46.521Z","updated":"2019-06-12T10:20:52.384Z","comments":true,"path":"posts/4112469.html/","link":"","permalink":"https://datou-y.github.io/posts/4112469.html/","excerpt":"这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。","text":"这里你看面试题说明你已经离职了，没离职的建议考虑清楚再离职，你是否承担的起离职的代价，你为下一份工作做好了准备了吗。你是否具备离职条件，下一份工作你对自己的期望是什么，在没有考虑这些问题你慎重离职。 所有题目都在博客文章中有涉及 java List，Set，Map的区别 ArrayList,LinkList,Vector区别 HashMap,HashTable的区别 List排序 List去重 List进行遍历修改操作是否会报错 List数据的获取 数组排序 String,StringBuild,StringBuffer区别 jdk1.8新特性 Exception 和Error区别 线程同步，与线程通信 java基本数据类型 生产指定的随机数 表单重复提交 单点登录 split(&quot;|&quot;)和split(&quot;//|&quot;)区别 final,finaly,finalize区别 overload和override区别overrided返回值可以改变吗 如何实现HashMap同步或者是ArrayList同步 抽象类，和接口的区别 ==和equal区别 mysql mysql数据去重 给你题目手写mysql语句 mysql日期函数 mysql优化 mysql中union和union all区别 mysql中in 和 exists区别 mysql索引 事物特性 判断什么情况下索引会失效 使用函数表达式会影响效率吗，会破坏索引吗 如何获取自增主键 如何获取重复的数据 如何对数据库null值处理 redis 项目中什么时候用到redis redis原理 项目中用到redis那些类型 springMVCweb 项目中有没有遇到数据比较多的时候，如何处理的 项目中高并发解决 简历 介绍自己项目经验，和做过的项目 会就简历上有的项目进行技术点提问","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://datou-y.github.io/tags/面试/"}]},{"title":"浅析MySQL中exists与in的使用和区别","slug":"mysql-in-exits","date":"2019-06-11T12:46:01.117Z","updated":"2019-06-11T14:20:49.425Z","comments":true,"path":"posts/df7b0a0e.html/","link":"","permalink":"https://datou-y.github.io/posts/df7b0a0e.html/","excerpt":"什么是existsexists表示存在，它常常和子查询配合使用， 1234select * from student st where exists(select * from score sc where sc.stu_id= st.stu_id); exists用于检查子查询是否至少会返回一行数据,如果返回空集exists返回值就是false，否则就是true,该子查询实际不返还任何数据。 exists对外表用loop逐条查询，每次查询都会查看exists的条件语句 当子查询返回为真时，则外层查询语句将进行查询 当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。","text":"什么是existsexists表示存在，它常常和子查询配合使用， 1234select * from student st where exists(select * from score sc where sc.stu_id= st.stu_id); exists用于检查子查询是否至少会返回一行数据,如果返回空集exists返回值就是false，否则就是true,该子查询实际不返还任何数据。 exists对外表用loop逐条查询，每次查询都会查看exists的条件语句 当子查询返回为真时，则外层查询语句将进行查询 当子查询返回为假时，外层查询语句将不进行查询或者查询不出任何记录。 not exists 与exists条件相反，就是当exists结果集有反会值是时候条件为false否则为true in 查询 in查询相当于多个or条件的叠加 123select * from student st where st.stu_id in (1,2,3)# 等效于select * from student st where st.stu_id=1 or st.stu_id=2 or st.stu_id=3; not in与in相反 123select * from student st where st.stu_id not in (1,2,3);# 等效于select * from student st where st.stu_id!=1 and st.stu_id!=2 and st.stu_id!=3; in 子查询 in查询的子条件返回结果必须只有一个字段 in()语句只会执行一次，会将符合子查询条件的记录全都查出来，假设结果集为B，共有m条记录并且缓存起来，然后在将子查询条件的结果集分解成m个，再进行m次查询 12select * from Awhere id in(select id from B) 以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将A表的记录加入结果集中,直到遍历完A表的所有记录 参考文献 浅析MySQL中exists与in的使用 mysql中exit和in的区别","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[{"name":"exists","slug":"exists","permalink":"https://datou-y.github.io/tags/exists/"},{"name":"in","slug":"in","permalink":"https://datou-y.github.io/tags/in/"}]},{"title":"mysql union 和union all使用","slug":"mysql-union","date":"2019-06-11T11:58:04.162Z","updated":"2019-06-11T12:45:21.743Z","comments":true,"path":"posts/7bb7ade4.html/","link":"","permalink":"https://datou-y.github.io/posts/7bb7ade4.html/","excerpt":"在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个，UNION用的比较多union all是直接连接，取到得是所有值，记录可能有重复 union 是取唯一值，记录没有重复 语法[SQL 语句 1] UNION[SQL 语句 2] [SQL 语句 1] UNION ALL[SQL 语句 2]","text":"在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个，UNION用的比较多union all是直接连接，取到得是所有值，记录可能有重复 union 是取唯一值，记录没有重复 语法[SQL 语句 1] UNION[SQL 语句 2] [SQL 语句 1] UNION ALL[SQL 语句 2] 区别 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。 如果您想使用ORDER BY或LIMIT子句来对全部UNION结果进行分类或限制，则应对单个地SELECT语句加圆括号，并把ORDER BY或LIMIT放到最后一个的后面： 1234(SELECT a FROM tbl_name WHERE a=10 AND B=1)UNION(SELECT a FROM tbl_name WHERE a=11 AND B=2)ORDER BY a LIMIT 10; 参考文献 mysql中union与union all的区别 MySQL中UNION和UNION ALL的使用 mysql union 和union all使用","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[{"name":"union","slug":"union","permalink":"https://datou-y.github.io/tags/union/"}]},{"title":"mysql中聚合函数日期函数使用详细和实例","slug":"mysql-count-sum","date":"2019-06-08T02:14:41.114Z","updated":"2019-06-11T12:11:10.634Z","comments":true,"path":"posts/74138ad2.html/","link":"","permalink":"https://datou-y.github.io/posts/74138ad2.html/","excerpt":"countmysql 数据库中 count() 函数是统计查询结果中的行数。列如下面的empy表 1select count(*) from empy;","text":"countmysql 数据库中 count() 函数是统计查询结果中的行数。列如下面的empy表 1select count(*) from empy; 注意的是，count 会忽略掉 NULL 的结果， 所以 count(字段名) 这样使用的话，如果字段中包含为null的结果，将导致查询结果不准确，列如： 1select count(name) from empy; summysql 中 sum() 函数用于计算某一字段中所有行的数值之和（ sum 求和时会对 null 进行过滤，不计算）,如果对无法计算的列进行sum()sum 函数的返回值为 0,如果没有符合条件的行，sum()将返回null 123456返回结果为0select sum(name) from empy;返回结果为32select sum(dept_id) from empy返回结果为nullselect sum(dept_id) from empy where dept_id=9; maxmysql 中 max() 函数用于计算某一字段中所有行的最大值,如果对无法比较的列进行max()max 函数的返回值为 xxx,如果没有符合条件的行，max()将返回null 123456返回结果为xxxselect max(name) from empy;返回结果为4select max(dept_id) from empy返回结果为nullselect max(dept_id) from empy where dept_id=9; minmysql中 min()函数用于计算某一字段中所有行的最小值 avg 返回指定字段的数据的平均值 avg() 通过对表中行数计数并计算指定字段的数据总和，求得该字段的平均值。 now() 获得当前日期+时间（date + time）函数：now()1select now(), sleep(3), now(); sysdate() sysdate() 日期时间函数跟 now()类似，不同之处在于：now() 在执行开始时值就得到了sysdate()在函数执行时动态得到值 sysdate() 日期时间函数，一般情况下很少用到。 current_timestamp() 获得当前时间戳函数1select current_timestamp, current_timestamp(); date_format(date,format) 日期/时间转换为字符串1select date_format('2008-08-08 22:23:01', '%Y%m%d%H%i%s'); str_to_date(str,format) 可以把一些杂乱无章的字符串转换为日期格式也可以转换为时间12345select str_to_date('08/09/2008', '%m/%d/%Y'); -- 2008-08-09select str_to_date('08/09/08' , '%m/%d/%y'); -- 2008-08-09select str_to_date('08.09.2008', '%m.%d.%Y'); -- 2008-08-09select str_to_date('08:09:30', '%h:%i:%s'); -- 08:09:30select str_to_date('08.09.2008 08:09:30', '%m.%d.%Y %h:%i:%s'); -- 参考文献 mysql之常用函数 MySQL 获得当前日期时间 函数","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[{"name":"聚合函数","slug":"聚合函数","permalink":"https://datou-y.github.io/tags/聚合函数/"}]},{"title":"java中随机数使用","slug":"java-random","date":"2019-06-07T09:32:12.122Z","updated":"2019-06-07T10:31:35.412Z","comments":true,"path":"posts/7b083b8f.html/","link":"","permalink":"https://datou-y.github.io/posts/7b083b8f.html/","excerpt":"随机数创建currentTimeMillis()12final long timeMillis=System.currentTimeMillis();System.out.println(timeMillis); long currentTimeMillis() 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用 123final long timeMillis=System.currentTimeMillis();final int i = (int)( timeMillis % 1000 );System.out.println(i); 若要获取int类型的整数，只需要将上面的结果转成int类型即可。比如，获取[0, 100)之间的int整数要除以100获取[0-1000]就除以1000类推即可","text":"随机数创建currentTimeMillis()12final long timeMillis=System.currentTimeMillis();System.out.println(timeMillis); long currentTimeMillis() 获得当前时间毫秒数，每次获取都是不一样，可以当成随机数来使用 123final long timeMillis=System.currentTimeMillis();final int i = (int)( timeMillis % 1000 );System.out.println(i); 若要获取int类型的整数，只需要将上面的结果转成int类型即可。比如，获取[0, 100)之间的int整数要除以100获取[0-1000]就除以1000类推即可 Math.random()12double d = Math.random();System.out.println(d); double Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的double值 123double d = Math.random();int i=(int)(d*100);System.out.println(i); 若要获取int类型的整数，只需要将上面的结果转成int类型即可。比如，获取[0, 100)之间的int整数要乘以100获取[0-1000]就乘以1000类推即可 Random类123456//默认构造方法Random r=new Random();//指定值构造方法Random rs=new Random(1000);int i = r.nextInt(100);System.out.println(i); int r.nextInt(100)获取[0, 100)之间的int整数Random支持的随机值类型包括：boolean, byte, int, long, float, double等 Random常用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Random;import java.lang.Math;/** * java 的随机数测试程序。共3种获取随机数的方法： * (01)、通过System.currentTimeMillis()来获取一个当前时间毫秒数的long型数字。 * (02)、通过Math.random()返回一个0到1之间的double值。 * (03)、通过Random类来产生一个随机数，这个是专业的Random工具类，功能强大。 * * @author skywang * @email kuiwu-wang@163.com */public class RandomTest&#123; public static void main(String args[])&#123; // 通过System的currentTimeMillis()返回随机数 testSystemTimeMillis(); // 通过Math的random()返回随机数 testMathRandom(); // 新建“种子为1000”的Random对象，并通过该种子去测试Random的API testRandomAPIs(new Random(1000), \" 1st Random(1000)\"); testRandomAPIs(new Random(1000), \" 2nd Random(1000)\"); // 新建“默认种子”的Random对象，并通过该种子去测试Random的API testRandomAPIs(new Random(), \" 1st Random()\"); testRandomAPIs(new Random(), \" 2nd Random()\"); &#125; /** * 返回随机数-01：测试System的currentTimeMillis() */ private static void testSystemTimeMillis() &#123; // 通过 final long l = System.currentTimeMillis(); // 通过l获取一个[0, 100)之间的整数 final int i = (int)( l % 100 ); System.out.printf(\"\\n---- System.currentTimeMillis() ----\\n l=%s i=%s\\n\", l, i); &#125; /** * 返回随机数-02：测试Math的random() */ private static void testMathRandom() &#123; // 通过Math的random()函数返回一个double类型随机数，范围[0.0, 1.0) final double d = Math.random(); // 通过d获取一个[0, 100)之间的整数 final int i = (int)(d*100); System.out.printf(\"\\n---- Math.random() ----\\n d=%s i=%s\\n\", d, i); &#125; /** * 返回随机数-03：测试Random的API */ private static void testRandomAPIs(Random random, String title) &#123; final int BUFFER_LEN = 5; // 获取随机的boolean值 boolean b = random.nextBoolean(); // 获取随机的数组buf[] byte[] buf = new byte[BUFFER_LEN]; random.nextBytes(buf); // 获取随机的Double值，范围[0.0, 1.0) double d = random.nextDouble(); // 获取随机的float值，范围[0.0, 1.0) float f = random.nextFloat(); // 获取随机的int值 int i1 = random.nextInt(); // 获取随机的[0,100)之间的int值 int i2 = random.nextInt(100); // 获取随机的高斯分布的double值 double g = random.nextGaussian(); // 获取随机的long值 long l = random.nextLong(); System.out.printf(\"\\n---- %s ----\\nb=%s, d=%s, f=%s, i1=%s, i2=%s, g=%s, l=%s, buf=[\", title, b, d, f, i1, i2, g, l); for (byte bt:buf) System.out.printf(\"%s, \", bt); System.out.println(\"]\"); &#125;&#125; 参考文献 https://www.cnblogs.com/skywang12345/p/3341423.html java的三种随机数生成方式 Java 生成随机数 java随机生成6位随机数 5位随机数 4位随机数","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"random","slug":"random","permalink":"https://datou-y.github.io/tags/random/"}]},{"title":"java中进程和线程","slug":"java-thread","date":"2019-06-06T13:53:01.653Z","updated":"2019-06-07T11:47:19.386Z","comments":true,"path":"posts/c206fba0.html/","link":"","permalink":"https://datou-y.github.io/posts/c206fba0.html/","excerpt":"","text":"线程的创建方式 run()方法是执行的线程体，start()用于启动线程 继承Thread类123456789101112131415class MyThread extends Thread &#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; // run 线程体 @Override public void run() &#123; for (int i = 0; i &lt; 101; i++) &#123; System.out.println(this.name + \"---&gt;\" + i); &#125; &#125;&#125; 1234567MyThread thread = new MyThread(\"A\");MyThread thread1 = new MyThread(\"B\");MyThread thread2 = new MyThread(\"C\");thread.start();thread1.start();thread2.start(); 继承Thread类的类就是一个线程类，通过创建当前类的实例，来创建多个线程 实现Runnable接口123456789101112131415class MyThread implements Runnable&#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; // run 线程体 @Override public void run() &#123; for (int i = 0; i &lt; 101; i++) &#123; System.out.println(this.name + \"---&gt;\" + i); &#125; &#125;&#125; 1234MyThread thread = new MyThread(\"A\");new Thread(thread).start();new Thread(thread).start();new Thread(thread).start(); 由于Runnable接口没有定义start方法，而一定的规定要求，必须通过Thread.start方法来启动继承； Thread类中有 【Thread（Runnable target）】构造方法，可以接收Runnable接口的参数 于是我们可以实例化Threda类，将Runnable对象交给Thread类处理并调用其start()方法启动多线程 实现Callable接口 Runnable接口实现的多线程不能返回操作结果；所以提供了一个新的多线程接口——Callable接口【java.util.concurrent 包】 call()方法在 执行主要功能后，可以返回结果，而返回结果的类型有Calable接口泛型来决定。 Callable接口的call()是线程执行体，代替原来run()方法可以有返回值1234567891011121314151617181920212223242526272829/* * Thread类中并没有接收Callabel对象的构造方法，所以无法通过start()来启动多线程* 但是Java提供java.util.concurrent。FutureTask&lt;V&gt; 类 ， * 在FutureTask类的定义结构如下：* public class FutureTask&lt;V&gt; extends Object implements Future&lt;V&gt; , Runnable* 类中有如下的构造方法：* public FutureTask(Callable&lt;V&gt; callable)* FutureTask类接收Callable接口对象。目的就是：取得call()方法的返回结果*/class MyThread implements Callable&lt;String&gt; &#123; private String name; private int tick = 10; public MyThread(String name) &#123; this.name = name; &#125; @Override public String call() &#123; for (int i = 0; i &lt; 101; i++) &#123; if (this.tick &gt; 0) &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125; return \"OKOK\"; &#125;&#125; 12345678910MyThread thread = new MyThread(\"A\");MyThread thread1 = new MyThread(\"B\");FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(thread); // 目的是为了接收call返回值FutureTask&lt;String&gt; task1 = new FutureTask&lt;String&gt;(thread1);// FutureTask是Runnable接口子类，所以可以使用Thread类的构造来接收task对象new Thread(task1).start();new Thread(task).start();// 多线程执行完毕后，依靠FutureTask的父接口 Future中的get()方法完成。System.out.println(\"A---&gt;\" + task.get());System.out.println(\"A---&gt;\" + task1.get()); 区别使用Runnable接口与Thread类相比之下，解决了Thrad类单继承局限的问题 数据共享的不同 1234567MyThread thread = new MyThread(\"A\");MyThread thread1 = new MyThread(\"B\");MyThread thread2 = new MyThread(\"C\");thread.start();thread1.start();thread2.start(); 1234MyThread thread = new MyThread(\"A\");new Thread(thread).start();new Thread(thread).start();new Thread(thread).start(); 两个程序例子，都是实现三个线程的启动；不同的地方在于，Thread的三个线程使用的是三个不同的实例对象如代码块一，而Runnable的三个线程均是通过实例化Thread类调用Start()方法对同一实例对象进行三个线程的操作如代码块二。Runnable更好的实现了同一数据共享（当然Thread也可以，只是没有Runnable简单） 两者的区别 Thread类是Runnable接口的一个子类，使用Runnable接口实现多线程可以避免单继承的局限性 Runnable接口实现的多线程可以比Thrad类实现的多线程更加清楚的描述 多线程的常用操作方法线程的命名与获得12345Thread.currentThread().getName()new Thread(thread,\"线程 = A\").start();new Thread(thread,\"线程 = B\").start();new Thread(thread,\"线程 = C\").start();thread.setName(\"线程A\"); Thread.currentThread().getName() 获取当前线程的名称，如果自己没有设置名称默认的名称为Thread-0,Thread-1依次类推 new Thread(thread,&quot;线程A&quot;).start() 设置线程名称适用于实现接口方式的线程创建 thread.setName(&quot;线程A&quot;) 设置线程的名称，适用于继承Thread类的线程创建 休眠12345try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; sleep(long millis) 线程睡眠 millis 毫秒 sleep(long millis, int nanos) 线程睡眠 millis 毫秒 + nanos 纳秒 因为sleep()是静态方法，所以最好的调用方法就是 Thread.sleep() 线程的sleep方法应该写在线程的run()方法里，就能让对应的线程睡眠,sleep调用无关调用的线程对象，在那里调用那个线程就睡眠 sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁资源 线程的优先级优先级越高，越有可能先执行；Thread类中设置了两个方法： 改变线程优先级： public final void setPriority(int newPriority) ;返回线程优先级： public final void getPriority() ; java中线程优先级效果不是特别明显所以不使用一般 线程的同步与死锁同步指的是多个线程访问同一资源时的问题；即多个线程对象操作同一个对象资源1234567891011121314151617class MyThread implements Runnable &#123; private String name; private int tick = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.tick &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \"&gt;&gt;&gt;&gt;\" + \"机票还剩下\" + this.tick--); &#125; &#125; &#125;&#125; 1234567public class Main &#123; public static void main(String[] args) throws Exception &#123; MyThread thread = new MyThread(); new Thread(thread, \"线程A\").start(); new Thread(thread, \"线程B\").start(); &#125;&#125; 此时，上例没有出现任何问题！但在代码run()的for中加入延迟【Thread.sleep();】就会出现问题： 123456789101112131415161718192021class MyThread implements Runnable &#123; private String name; private int tick = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.tick &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"&gt;&gt;&gt;&gt;\" + \"机票还剩下\" + this.tick--); &#125; &#125; &#125;&#125; 运行结果 可以明显的发现，结果中出现了相同值（意外值）；这就是“不同步”的状况【异步操作】。上例代码的想法是：从同一个资源取得当前的剩余的点数，但是由于延迟的存在，后续的线程不会等待之前的线程，会直接的进入，导致剩余值没有得到及时的刷新,而出现问题 同步的操作所谓同步就是指多个线程操作同一时间只能有一个线程进入同一个空间运行，其他线程要等待此线程完成之后才可以继续执行。而之前的不同步【或称为异步操作】，则是多个线程可以同一时间进入同一个空间运行。 java中实现线程得同步则使用：synchronized 关键字。使用方法：1、同步代码块；2、[线程]同步方法； Java 四种代码块： 普通代码块、构造块、静态块、同步块 1234567891011121314151617181920212223242526class MyThread implements Runnable &#123; private String name; private int tick = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; synchronized (this) &#123; if (this.tick &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"&gt;&gt;&gt;&gt;\" + \"机票还剩下\" + this.tick--); &#125; &#125; &#125; &#125;&#125; 上例代码实现得则是“同步块”，利用synchronized关键字使得会出现异常行代码被关键字锁住，每一次执行只可以进入一个对象，实现同步需要接受一个this参数表示当前线程对象 所有（多个）线程，只有当里面得线程结束了，自己才可以进入同步块【一次只可以进入一个对象】但是有人翻译同步代码块比较“粗糙”不美观,所以还有另外得【同步方法】123456789101112131415161718192021222324252627class MyThread implements Runnable &#123; private String name; private int tick = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; this.sale(); &#125; &#125; public synchronized void sale() &#123; if (this.tick &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"&gt;&gt;&gt;&gt;\" + \"机票还剩下\" + this.tick--); &#125; &#125;&#125; 上例代码则是放弃了同步块，使用同步方法实现“同步”同步方法得定义结构依旧是使用synchronized关键字在run()方法中，使用this方法调用同步方法。 异步操作得速度高于同步操作，而同步操作时得数据安全性高于异步操作时得数据安全性；】 死锁：所谓的同步就是一个线程对象等待另外一个线程对象执行完毕后的操作形式；线程同步过多，就有可能造成死锁。也就是多个线程条件互斥进入等待造成死锁 死锁是程序开发中，由于某种逻辑上的错误所造成的问题； 同步产生的问题：多个线程访问同一空间资源是一定要处理好同步，可以使用同步代码块或同步方法解决；但是过多的同步，有可能造成“死锁” 最简单的同步或异步操作，就是通过 synchronized 关键字实现。 死锁是一种不定、不可预的状态 线程之间的通信ThreadLocal的使用java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量 12345678910111213141516171819202122232425262728class MyThread implements Runnable &#123; private static ThreadLocal&lt;Integer&gt; tick=new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue() &#123; return 10; &#125; &#125;; private String name; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (tick.get()&gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; tick.set(tick.get()-1); System.out.println(Thread.currentThread().getName() + \"&gt;&gt;&gt;&gt;\" + \"机票还剩下\" + tick.get()); &#125; &#125; &#125;&#125; 12345678public class Main &#123; public static void main(String[] args) throws Exception &#123; MyThread thread = new MyThread(); new Thread(thread, \"线程A\").start(); new Thread(thread, \"线程B\").start(); &#125;&#125; ThreadLocal&lt;Integer&gt; tick=new ThreadLocal&lt;Integer&gt; 创建ThreadLocal变量 initialValue 设定初始值 get()访问ThreadLocal变量 set()设置对应值 ThreadLocal 线程局部变量，每个线程单独维护一份自己的ThreadLocal变量相当于对每个线程都有一个独立的ThreadLocal副本 join ,sleep,wait,区别 sleep是Thread类的静态方法一般写在run方法里面表示休眠当前线程于调用线程无关，会让出cpu资源，不会释放对象锁，会抛出异常 join方法联合线程，当一个线程调用该方法后，会强制执行该线程（此时原来执行的线程处于阻塞状态），直到执行结束再执行原来的线程，这样把两个线程联合在了一一起。 wait 方法会让出cpu释放对象锁，需要配和synchronized使用接收锁对象 参考文献 Java 线程与多线程 java线程两种睡眠方法比较 Java多线程 -sleep 用法详解 Java ThreadLocal的使用 Java并发编程之ThreadLocal详解 JAVA多线程之线程间的通信方式 Java 里如何实现线程间通信","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://datou-y.github.io/tags/Thread/"}]},{"title":"java中StringBuffer和StringBuilder和String","slug":"java-string","date":"2019-06-06T09:59:13.017Z","updated":"2019-06-06T13:28:32.004Z","comments":true,"path":"posts/2a5743c8.html/","link":"","permalink":"https://datou-y.github.io/posts/2a5743c8.html/","excerpt":"当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 字符串的创建12345678String a = \"I AM DOG\";String b = new String(a);String c = new String(\"I AM DOG\");System.out.println(a + b + c);char c1[] = &#123;'2', '3', '4', '5'&#125;;String str1 = new String(c1);System.out.println(str1);","text":"当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 字符串的创建12345678String a = \"I AM DOG\";String b = new String(a);String c = new String(\"I AM DOG\");System.out.println(a + b + c);char c1[] = &#123;'2', '3', '4', '5'&#125;;String str1 = new String(c1);System.out.println(str1); 字符串常用方法获取字符串长度1a.length() length()是方法区别与数组的length属性还有集合的size()方法 字符串的长度是指其所包含的字符的个数,一个字符算一个长度，一个空格算一个长度 字符串连接123456789String a = \"I am\";String b = \" Tom\";int age = 14;System.out.println(a + b + \" \" + \"我的年龄是\" + age);String result = \"The result 2 + 2 is \" + 2 + 2;System.out.println(result);String a=\"fafafa\";String c=result.concat(a); &quot; + &quot;可以连接两个字符串，产生一个新String对象，也可以使用一连串的字符串+进行运算 字符串在使用+号进行连接的时候，会默认把int类型自动的转换为String类型再进行连接，这种转换思想具有普适性，其他数据类型也是如此 正如上面所说的，String类型和任何类型的相加都会变为String类型的结果，上面程序的运行过程会先执行&quot;The result 2 + 2 is&quot; 加2，得到的结果再加2 ，就会变成The result 2 + 2 is 22 concat()方法用于字符串连接效果和+是一样的 获取某个位置字符12String result = \"The result 2 + 2 is \";System.out.println(result.charAt(8)); charAt()获取字符串某个位置上的字符 获取字符的位置123String result = \"The result 2 + 2 is \";System.out.println(result.indexOf(\"2\"));System.out.println(result.lastIndexOf(\"2\")); indexOf()获取字符对应位置的索引位置 lastIndexOf()获取字符对应位置的最后索引位置 判断123456789String result = \"The result 2 + 2 is \";if(result.contains(\"he result\"))&#123; System.out.println(1);&#125;result.isEmpty()System.out.println(result.startsWith(\"r\"));System.out.println(result.endsWith(\" \"));System.out.println(result.equals(\"t\"));System.out.println(result.equalsIgnoreCase(\"T\")); boolean contains()判断字符串中是否包含某一个子串 boolean isEmpty()原理就是判断长度是否为0 boolean startsWith()字符串是否以指定内容开头 boolean endsWith() 字符串是否以指定内容结尾 boolean equals(str)判断字符内容是否相同 boolean.equalsIgnorecase()判断内容是否相同，并忽略大小写。 去掉字符串空格12String result = \"The result 2 + 2 is \"; System.out.println(result.trim()); String trim()将字符串两端的多个空格去除 转换大小写123String result = \"The result 2 + 2 is \";System.out.println(result.toUpperCase());System.out.println(result.toLowerCase()); String toUpperCsae() 大转小 String toLowerCsae() 小转大 截取替换123String result = \"The result 2 + 2 is \";System.out.println(result.substring(0,3));System.out.println(result.replace(\"r\",\"h\")); String subString()获取字符串中子串 String replace() 将字符串指定字符替换。 字符串转换123456789101112String result = \"222\";int c = Integer.valueOf(result);int a = 1;String b = String.valueOf(a);String d = \"True\";Boolean e = Boolean.valueOf(d);System.out.println(c);System.out.println(b);System.out.println(e); valueOf() 字符串转换，转换什么类型就调用什么类型的valueOf()方法 StringBuffer常用操作创建对象12StringBuffer sb=new StringBuffer(\"abcd\");StringBuffer ssb=new StringBuffer(); 要初始化内容可以直接在创建时候初始化 append方法123StringBuffer sb = new StringBuffer(\"abcd\");sb.append(\"true\");System.out.println(sb.toString()); append()追加内容到当前StringBuffer对象的末尾，类似于字符串的连接。调用该方法以后StringBuffer对象的内容也发生改变 使用该方法进行字符串的连接，将比String更加节约内容应用于数据库SQL语句的连接 reverse方法123StringBuffer sb = new StringBuffer(\"abcd\");sb.reverse();System.out.println(sb.toString()); reverse()作用是将StringBuffer对象中的内容反转，然后形成新的字符串 insert方法123StringBuffer sb = new StringBuffer(\"abcd\");sb.insert(3,\"true\");System.out.println(sb.toString()); 作用是在StringBuffer对象中插入内容索引不包含最后一个，然后形成新的字符串 deleteCharAt方法1234StringBuffer sb = new StringBuffer(\"abcd\");sb.delete(0,1);sb.deleteCharAt(1);System.out.println(sb.toString()); 作用是删除指定位置的字符，然后将剩余的内容形成新的字符串 setCharAt方法123StringBuffer sb = new StringBuffer(\"abcd\");sb.setCharAt(0,'A');System.out.println(sb.toString()); setCharAt(int index, char ch)作用是修改对象中索引值为index位置的字符为新的字符ch St1ringBuilder和String类型转换12StringBuffer sb = new StringBuffer(\"abcd\");System.out.println(sb.toString()); toString()方法进行转换为String 需要注意的是，StringBuffer和String属于不同的类型，也不能直接进行强制类型转换 String，StringBuilder，StringBuffer三者的区别这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String String最慢的原因String为字符串常量，而StringBuilder和StringBuffer均为字符串变量即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的 Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢 StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多 在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 案例java中String s = new String(“abc”)创建了几个对象参考文献 Java中String的用法 String 字符串基本使用 Java中的String，StringBuilder，StringBuffer三者的区别 StringBuffer的用法 java之StringBuffer常见使用方法解析 String s=new String(“abc”)创建了几个对象?","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://datou-y.github.io/tags/字符串/"}]},{"title":"java中数组用法和实例详解","slug":"java-array","date":"2019-06-06T08:25:00.935Z","updated":"2019-06-06T10:21:36.315Z","comments":true,"path":"posts/4d11ca6.html/","link":"","permalink":"https://datou-y.github.io/posts/4d11ca6.html/","excerpt":"数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快 创建123String[] a=&#123;\"a\",\"b\",\"c\",\"d\"&#125;;String[] b=new String[5];String[] names = new String[] &#123; \"A\", \"B\", \"C\" &#125;; 数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型 创建并分配空间在 Java中可以使用new关键字来给数组分配空间","text":"数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快 创建123String[] a=&#123;\"a\",\"b\",\"c\",\"d\"&#125;;String[] b=new String[5];String[] names = new String[] &#123; \"A\", \"B\", \"C\" &#125;; 数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型 创建并分配空间在 Java中可以使用new关键字来给数组分配空间 基本操作添加元素1b[0]=\"a\"; 获取12System.out.println(b[0]);System.out.println(b.length); length属性获取数组长度 b[0] 直接通过下标获取数组对应位置元素 数组遍历12345678//普通for循环for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]);&#125;//增强for循环for(String s:a)&#123; System.out.println(s);&#125; 数组排序1234567891011121314String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;Arrays.sort(b);Arrays.sort(a);for (String s : a) &#123; System.out.println(s);&#125;for (Integer s : b) &#123; System.out.println(s);&#125; Arrays.sort()方法进行数组排序，字符串就按26个字符位置排序，数组就按大小排序 数组转换集合123456789String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;List&lt;String&gt; ls = Arrays.asList(a);for (String s : ls) &#123; System.out.println(s);&#125; 数组反转123456789101112String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;//先将数组转换为集合List&lt;String&gt; ls = Arrays.asList(a); //然后调用Collections工具方法进行反转Collections.reverse(ls);for(String s:ls)&#123; System.out.println(s);&#125; 数组获取最大值和最小值12345678910String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;//先将数组转换为集合List&lt;String&gt; ls = Arrays.asList(a);//然后调用Collections工具方法进行比较System.out.println(Collections.max(ls));System.out.println(Collections.min(ls)); 数组合并12345678910111213String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;String[] b = &#123;\"e\", \"f\", \"g\"&#125;;//先将数组转换为集合List&lt;String&gt; ls = new ArrayList&lt;String&gt;(Arrays.asList(a));//在调用集合的合并方法ls.addAll(Arrays.asList(b));Object[] o = ls.toArray();System.out.println(Arrays.toString(o));for (Object s : o) &#123; System.out.println(s);&#125; 注意这里遇到一个坑 12List&lt;String&gt; s=Arrays.asList(a);s.add(\"1\"); 这样接收的List集合和我们new创建的有区别所以add等方法是又区别的 参考ArrayList报错：UnsupportedOperationException的解决办法 数组填充12345int[] a=new int[5];Arrays.fill(a,1);for(int s:a)&#123; System.out.println(s);&#125; 参考文献 Java关于数组操作函数","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://datou-y.github.io/tags/Array/"}]},{"title":"ArrayList、LinkedList、Vector的区别和实现原理","slug":"ArryList-LinkList-Vector","date":"2019-06-06T07:37:14.550Z","updated":"2019-06-06T08:14:20.336Z","comments":true,"path":"posts/57b1f1b.html/","link":"","permalink":"https://datou-y.github.io/posts/57b1f1b.html/","excerpt":"继承关系","text":"继承关系 ArrayList 线程不安全，没有实现同步 有序的，先添加的元素放在前面，允许null值 查询，和随机访问效率快，修改比较慢 数据结构基于数组实现按照顺序将元素存储（从下表为0开始），删除元素时，删除操作完成后，需要使部分元素移位，默认的初始容量为10 LinkedList 线程不安全，没有实现同步 有序的，先添加的元素放在前面，允许null值 LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部 查询慢，修改比较慢 LinkedList是基于双向链表实现的（含有头结点） Vector Vector属于线程安全级别的大部分的方法都包含关键字synchronized Vector的效率没有ArraykList和LinkedList高 基于数组实现的 Vector提供indexOf(obj, start)接口，ArrayList没有。 线程安全实现 ArrayList不具有有线程安全性，在单线程的环境中，LinkedList也是线程不安全的，如果在并发环境下使用它们，可以用Collections类中的静态方法synchronizedList(）对ArrayList和LinkedList进行调用即可。Vector实现线程安全的，即它大部分的方法都包含关键字synchronized,但是Vector的效率没有ArraykList和LinkedList高 参考文献 ArrayList、LinkedList、Vector的区别和实现原理 源码浅析ArrayList、LinkedList和Vector的区别","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://datou-y.github.io/tags/List/"}]},{"title":"HashMap和Hashtable的区别和实现原理","slug":"hashmap-hastable","date":"2019-06-06T06:00:25.209Z","updated":"2019-06-06T08:20:55.268Z","comments":true,"path":"posts/425444d1.html/","link":"","permalink":"https://datou-y.github.io/posts/425444d1.html/","excerpt":"Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。","text":"Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap和Hashtable的区别 HashMap和Hashtable都实现了Map接口 HashMap是线程不安全的不允许键值重复,允许空键和空值;由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些. HashTable 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值 HashTable 是 synchronized 同步的,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 底层数据结构基于数组+链表实现 HashMap同步1Map m=Collections.synchronizedMap(map) Collections类不是集合，这个类里面提供了synchronizedMap方法 参考文献 HashMap和Hashtable的区别 JAVA中HashMap和Hashtable区别 HashMap和Hashtable原理","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Map","slug":"Map","permalink":"https://datou-y.github.io/tags/Map/"}]},{"title":"java中map字典用法和详细实例","slug":"java-map","date":"2019-06-05T10:52:00.847Z","updated":"2019-06-06T07:42:48.288Z","comments":true,"path":"posts/f2f0bf25.html/","link":"","permalink":"https://datou-y.github.io/posts/f2f0bf25.html/","excerpt":"HashMap字典用于存放键值对，&lt;key,value&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！","text":"HashMap字典用于存放键值对，&lt;key,value&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！ 常用方法 map创建12Map&lt;String,Integer&gt; map=new HashMap&lt;String, Integer&gt;();Map&lt;String, Integer&gt; map = Hashtable&lt;String, Integer&gt;; HashMap底层是哈希表数据结构，线程是不同步的也就是线程不安全的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法 TreeMapTreeMap可以对集合中的键进行排序 添加元素123456map.put(\"tom\",22);map.put(\"jack\",33);map.put(\"tom\",23);for (String key : map.keySet()) &#123; System.out.println(map.get(key)); &#125; put()方法在没有hashCode和equals方式 添加重复的键值（值不同）,会覆盖掉前面key值相同的值 删除元素123map.remove(\"tom\");map.clear(); map.remove(\"tom\",22); clear()方法清空集合对象 remove()方法指定key，返回删除的键值对映射的值如果key不存在删除失败，返回null如果同时指定了key，和value删除成功返回true，否则返回false 获取元素12map.size()map.get(\"toms\") size()方法获取容器大小,从1开始计算，集合索引从0开始计算 get()方法指定key，获取对应键值，如果key不存在返回null 判断123456789101112131415161718map.isEmpty()map.containsKey(\"toms\")map.containsValue(11)Set&lt;String&gt; key = map.keySet();for(String s:key)&#123; System.out.println(s);&#125;Collection&lt;Integer&gt; S=map.values();for(Integer s:S)&#123; System.out.println(s);&#125;Set&lt;Map.Entry&lt;String,Integer&gt;&gt; es=map.entrySet();for(Map.Entry e:es)&#123; System.out.println(e.getKey()); System.out.println(e.getValue());&#125; boolean isEmpty()方法判断集合是否为空 长度为0返回true否则false boolean containsKey(Object key) 判断集合中是否包含指定的key boolean containsValue(Object value)判断集合中是否包含指定的value Set keySet()方法获取所有的key返回一个Set集合 Collection values()方法获取所有的值返回一个Collection集合 entrySet() 方法获取map所有实体Set集合包含键和值 Map遍历1234Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(\"tom\", 22);map.put(\"jack\", 33);map.put(\"kom\", 23); 通过keySet() 获取key 通过key 找到value123for(String key:map.keySet())&#123; System.out.println(map.get(key));&#125; 通过Map.Entry(String,Integer) 获取，然后使用entry.getKey()获取到键，通过entry.getValue()获取到值1234for(Map.Entry e:map.entrySet())&#123; System.out.println(e.getValue()); System.out.println(e.getKey());&#125; 只遍历键或者值，通过增强for循环1234567for(String key:map.keySet())&#123; System.out.println(key);&#125;for(Integer a:map.values())&#123; System.out.println(a);&#125; 通过Iterator迭代器来遍历通过getKey获取所有键getValue获取所有值1234567Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it= map.entrySet().iterator();while (it.hasNext())&#123; Map.Entry&lt;String,Integer&gt; next=it.next(); String key=next.getKey(); Integer v=next.getValue(); System.out.println(\"key\"+key+\"value\"+v);&#125; Map合并123456789101112Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();map.put(\"tom\", 22);map.put(\"jack\", 33);map.put(\"kom\", 23);Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();map1.put(\"t\", 21);map1.put(\"g\", 2);map.putAll(map1);for (String key : map.keySet()) &#123; System.out.println(map.get(key));&#125; putAll()方法可以接收另一个Map让两个集合合并为一个Set的元素不可重复，Map的键不可重复Set元素重复元素不能存入add方法返回falseMap的重复健将覆盖旧键，将旧值返回。 fail-fast (快速失败)机制 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException 增加for循环进行遍历新增,删除操作会触发fail-fast机制，修改也就是覆盖不会触发1234567for(String key:map.keySet())&#123; map.put(\"jack\",222); map.put(\"s\",2); if(key.equals(\"jack\"))&#123; map.remove(\"jack\"); &#125;&#125; 使用迭代器迭Iterator迭代时候迭代器删除不会触发fail-fast机制只有新增会触发123456789101112Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator();while (it.hasNext())&#123; Map.Entry&lt;String,Integer&gt; s=it.next(); String key=s.getKey(); Integer value=s.getValue(); map.put(\"s\",1); map.put(\"tom\",1); if(key.equals(\"jack\"))&#123; it.remove(); &#125;&#125; 参考文献 Java集合类详解 java基础集合简介Map（三）下","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Map","slug":"Map","permalink":"https://datou-y.github.io/tags/Map/"}]},{"title":"java中List集合用法和实例详解","slug":"java-list","date":"2019-06-04T13:33:38.510Z","updated":"2019-06-06T07:42:33.669Z","comments":true,"path":"posts/50eb6371.html/","link":"","permalink":"https://datou-y.github.io/posts/50eb6371.html/","excerpt":"集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作 下面是java中集合框架主要结构图","text":"集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作 下面是java中集合框架主要结构图 集合的创建123List&lt;String&gt; ls=new ArrayList&lt;String&gt;();List&lt;String&gt; ls = new LinkedList&lt;String&gt;();List&lt;String&gt; ls = new Vector&lt;String&gt;(); List继承自Collection接口，是有序集合,即先放入的元素排在前面允许相同元素和null,实现类有ArrayList,LinkedList,Vector ArrayList非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多 LinkedList 非同步，允许相同元素和null，遍历效率低插入和删除效率高 Vector 同步，允许相同元素和null，效率低 集合常用方法集合的索引，也就是下标是从0开始，长度是从1开始 添加元素1234ls.add(\"a\"); ls.add(\"b\");ls.add(2,\"c\");ls.set(0,\"a\"); add()方法添加元素到集合中，也可以指定添加元素到集合指定位置，如果当前位置已经有了其他元素，后面的元素就依次往后移动，如果添加的位置索引不存在就会抛异常 set()方法替换掉原来位置的元素，如果索引不存在抛异常 删除元素12ls.remove(\"a\");ls.remove(0); remove()方法删除元素，可以根据元素删除如果当前元素不存在，或者已经删除就返回false，如果存在删除成功返回true。 也可以根据索引，也就是下标来删除，如果下标不存在就抛异常，返回删除后的元素信息 获取元素1ls.get(0) get()方法获取元素，根据下标获取元素，如果下标不存在抛异常 清空元素1ls.clear() 获取元素个数12ls.size()System.out.println(ls.size()); size() 获取元素个数，从1开始计算 集合是否为空1234boolean f = ls.isEmpty();if (f) &#123; System.out.println(\"full\");&#125; 集合包含某个元素12boolean f=ls.contains(\"g\");System.out.println(f); contains()方法，判断集合包含某个元素，如果存在返回true，否则返回false 获取元素对应的索引1234int a= ls.indexOf(\"e\");System.out.println(a);int b=ls.lastIndexOf(\"a\");System.out.println(b); indexOf()方法判断元素对应的索引位置，如果当前元素存在返回对应索引，不存在返回-1 lastIndexOf()方法和indexOf()一样，唯一不同就是当集合中有多个重复元素时候，会返回最后一个元素的下标，也就是索引。 集合转换为数组12345678910List&lt;String&gt; ls = new ArrayList&lt;String&gt;();ls.add(\"a\");ls.add(\"b\");ls.add(\"d\");ls.add(3, \"c\");Object[] a=ls.toArray();for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]);&#125; 集合遍历123456789101112131415161718192021List&lt;String&gt; ls = new ArrayList&lt;String&gt;();ls.add(\"a\");ls.add(\"b\");ls.add(\"c\");// 普通for 循环for(int i=0;i&lt;ls.size();i++)&#123; System.out.println(ls.get(i));&#125;//增强for循环for(String item:ls)&#123; System.out.println(item);&#125;//迭代器Iterator&lt;String&gt; iterator=personList.iterator();while (iterator.hasNext())&#123; String p=iterator.next(); System.out.println(p); &#125; fail-fast (快速失败)机制 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException 单线程环境 集合被创建后,在遍历它的过程中修改了结构,会抛异常 多线程环境 当一个线程在遍历这个集合,而另一个线程对这个集合的结构进行了修改会抛异常 12345678910List&lt;Person&gt; personList=new ArrayList&lt;Person&gt;();Person person=new Person();person.setAge(23);person.setName(\"Tom\");personList.add(person);Person person1=new Person();person1.setAge(22);person1.setName(\"jack\");personList.add(person1);Iterator&lt;Person&gt; iterator=personList.iterator(); 普通for循环遍历时候修改元素不会触发fail-fast安全机和制抛异常1234567for(int i=0;i&lt;personList.size();i++)&#123; Person p=personList.get(i); if(p.getAge()==22)&#123; personList.remove(i); &#125;&#125; 增加for循环遍历时候修改元素会触发fail-fast安全机和制抛异常12345for(Person p:personList)&#123; if(p.getAge()==22)&#123; personList.remove(p); &#125;&#125; 迭代器遍历，使用迭代器删除不会触发fail-fast安全机和制抛异常12345678while (iterator.hasNext())&#123; Person p=iterator.next(); if(p.getAge()==22)&#123; //这里要使用Iterator的remove方法移除当前对象， // 如果使用List的remove方法，则同样会出现ConcurrentModificationException iterator.remove(); &#125;&#125; 集合和数组区别 数组长度是固定的，集合长度是可变的 数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。 数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求 集合案例集合去重12345List&lt;String&gt; list=new ArrayList&lt;String&gt;();list.add(\"a\");list.add(1,\"b\");list.add(\"c\");list.add(\"a\"); 把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中1234567891011List&lt;String&gt; list1=new ArrayList&lt;String&gt;();for(int i=list.size()-1;i&gt;=0;i--)&#123; if(!list1.contains(list.get(i)))&#123; list1.add(list.get(i)); &#125;&#125;for(String s:list1)&#123; System.out.println(s);&#125; 循环list中的所有元素然后删除重复1234567891011for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = list.size() - 1; j &gt; i; j--) &#123; if (list.get(j).equals(list.get(i))) &#123; list.remove(j); &#125; &#125;&#125;for(String s:list)&#123; System.out.println(s);&#125; 通过HashSet踢除重复元素123456789HashSet h=new HashSet();h.addAll(list);list.clear();list.addAll(h);for(String s:list)&#123; System.out.println(s);&#125; 新版本的 JDK 可以支持 Stream 流操作，因此集合去重可以简单的使用下述语句来实现1234list = list.stream().distinct().collect(Collectors.toList());for(String s:list)&#123; System.out.println(s);&#125; 集合合并1234567891011121314List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(\"a\");list.add(\"b\");List&lt;String&gt; list1=new ArrayList&lt;String&gt;();list1.add(\"c\");list1.add(\"d\");list.addAll(list1);for(String s:list)&#123; System.out.println(s);&#125; 参考文献 Java集合（一）什么是集合 Java基础List详解 Java集合类详解 Java中List集合去除重复数据的方法 JAVA List合并集合","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://datou-y.github.io/tags/List/"}]},{"title":"mysql复杂的sql语句查询案例之GROUP BY系列","slug":"sql-complex-select","date":"2019-01-14T16:00:00.000Z","updated":"2019-06-09T09:46:17.784Z","comments":true,"path":"posts/1077e6d7.html/","link":"","permalink":"https://datou-y.github.io/posts/1077e6d7.html/","excerpt":"sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。 概述GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组， group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用where 再用group by 或者先用group by 再用having GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里 GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从左到右，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 group by 一般和聚合函数一起使用才有意义,比如 count sum avg等","text":"sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。 概述GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组， group by语句中select指定的字段必须是“分组依据字段”，其他字段若想出现在select中则必须包含在聚合函数中要筛选结果 可以先使用where 再用group by 或者先用group by 再用having GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里 GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里，分组层次从左到右，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组；接着第2个字段值相同的记录中，再根据第3个字段的值进行分组……依次类推。 group by 一般和聚合函数一起使用才有意义,比如 count sum avg等 常用的聚合函数 count() 计数 sum() 求和 avg() 平均数 max() 最大值 min() 最小值 语法1234SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; group by字句也和where条件语句结合在一起使用。当结合在一起时，where在前，group by 在后。即先对select xx from xx的记录集合用where进行筛选，然后再使用group by 对筛选后的结果进行分组。 使用having字句对分组后的结果进行筛选，语法和where差不多:having 条件表达式1having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)2where肯定在group by 之前，即也在having之前。3.where后的条件表达式里不允许使用聚合函数，而having可以。 当一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是： 执行where xx对全表数据做筛选，返回第1个结果集。 针对第1个结果集使用group by分组，返回第2个结果集。 针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。 针对第3个结集执行having xx进行筛选，返回第4个结果集。 针对第4个结果集排序。 sql分析 按由高到低的顺序显示个人平均分在70分以上的学生姓名和平均分，为了尽可能地提高平均分，在计算平均分前不包括分数在60分以下的成绩，并且也不计算Tom的成绩 拿到一个比较复杂的需求sql语句不要慌我们要一步步的进行需求拆分 分析： 要求显示学生姓名和平均分因此确定第1步select s_name,avg(score) from student 计算平均分前不包括分数在60分以下的成绩，并且也不计算Tom的成绩因此确定第2步 where score&gt;=60 and s_name!=’Tom’ 显示个人平均分相同名字的学生（同一个学生）考了多门科目 因此按姓名分组确定第3步 group by s_name 显示个人平均分在70分以上因此确定第4步 having avg(s_score)&gt;=70 按由高到低的顺序 因此确定第5步 order by avg(s_score) desc 常用案例学生信息班级表学生\b表成绩表 插入班级信息 12345678insert into class (class_id, class_name)values (\"A\",\"一班\");insert into class (class_id, class_name)values (\"B\",\"二班\");insert into class(class_id, class_name)values (\"C\",\"三班\"); 插入学生信息 12345678insert into student(class_id, stu_name)values (\"A\",\"Tom\");insert into student(class_id, stu_name)values(\"B\",\"Jack\");insert into student(class_id, stu_name)values (\"C\",\"Luck\"); 插入科目信息 123456insert into score(stu_id, course, score)values (8,\"数学\",80);insert into score(stu_id, course, score) values(8,\"英语\",90);insert into score(stu_id, course, score) values(8,\"语文\",70); 插入语句没有from表是into表 查询每个学生总成绩 分析 总成绩 sum(score.score) 每个学生 一个学生考了多个科目按照学生姓名分组 group by student.stu_id 1234select (select st.stu_name from student st where st.stu_id=sc.stu_id) stu_name,sum(sc.score)from student st,score scwhere st.stu_id=sc.stu_idgroup by st.stu_id; 查询语文成绩大于90的学生 分析 语文成绩大于90 where sc.score&gt;90 and sc.course=&quot;语文&quot; 123select st.stu_name,sc.scorefrom student st,score scwhere st.stu_id=sc.stu_id and sc.score&gt;90 and sc.course=\"语文\"; 查询A班所有学生信息 分析 A班 where cl.class_id=&quot;A&quot; 12select st.stu_id,st.stu_name from student stwhere st.class_id=\"A\"; 查询B班学生人数 分析 B班 where cl.class_id=B 总人数 count(*) 12select count(*) from student stwhere st.class_id=\"B\"; 查询A班语文成绩最高的学生 分析 A班 st.class_id=A 语文成绩最高 where sc.score=max(sc.score) and sc.coures=&quot;语文&quot; 123select st.stu_id,st.stu_name from student st, score sc,(select max(sc.score) max_su from score sc,class cl,student stwhere st.stu_id=sc.stu_id and st.class_id=cl.class_id and sc.course=\"语文\" and st.class_id=\"A\") twhere sc.course=\"语文\" and sc.stu_id=st.stu_id and st.class_id=\"A\" and sc.score=max_su; 查询各班级语文成绩最高的学生信息 分析 各班级 group by cl.class_id 语文成绩最高 max(sc.score) and sc.score=语文 1234567select st1.stu_name ,cl1.class_name,sc1.scorefrom student st1,class cl1,score sc1,(select max(sc.score) max_su from score sc,class cl,student stwhere st.stu_id=sc.stu_id and st.class_id=cl.class_idgroup by cl.class_id) twhere st1.stu_id=sc1.stu_id and st1.class_id=cl1.class_id and sc1.course=\"语文\"and sc1.score=max_suorder by sc1.score desc; 查询各个班级成绩最高的学生信息 分析 各班级 group by cl.class_id 成绩最高 max(sc.score)123456select st.stu_name,cl.class_name,sc.course,sc.scorefrom student st,score sc,class cl, (select max(sc1.score) max_score from student st1,score sc1,class cl1 where st1.stu_id=sc1.stu_id and st1.class_id=cl1.class_id group by cl1.class_id) twhere st.stu_id=sc.stu_id and st.class_id=cl.class_id and sc.score=max_score; 部门信息员工表 empy 部门表 dept 查询每个部门工资最高的员工 分析 每个部门 group by ep.dept_id 工资最高 max(ep.salary) 123select empy.name,salary,dept.name from empy,dept,(select dept_id,max(ep.salary) maxsal from empy ep group by ep.dept_id) twhere empy.dept_id=t.dept_id and empy.salary=maxsal and empy.dept_id=dept.id; 查询每个部门的人员信息 分析 每个部门 group by ep.dept_id 12select ep.name name,ep.salary salary,dp.name department from empy ep ,dept dpwhere ep.dept_id=dp.id; 查询每个部门的平均工资 分析： 平均工资 avg(ep.salary) 每个部门 group by dept_id 123select avg(ep.salary) avg_salary, dp.name from empy ep,dept dpwhere dp.id=ep.dept_idgroup by ep.dept_id; 查询销售部Tom的个人信息 分析 where ep.name=&quot;Tom&quot; and dp.name=&quot;销售部&quot; 12select * from empy ep,dept dpwhere ep.name=\"Tom\" and dp.name=\"销售\" and ep.dept_id=dp.id; 查询每个部门前三名员工信息 123456789select dept_id, name, salaryfrom empy e1where ( select count(*) from empy e2 where e2.dept_id=e1.dept_id and e2.salary&gt;=e1.salary ) &lt;=3 /*这里的数值表示你想取前几名*/order by dept_id, salary desc; 查询每个部门工资最高的前两名员工并且按照工资降序 分析 每个部门 group by ep.dept_id 工资最高 max(ep.salary) 前两名员工 count(*)&lt;=2 工资降序 order by ep.salary desc 12345select ep.name,ep.salary,dp.name from empy ep,dept dp,(select max(empy.salary) max_salary,empy.dept_id from empy group by empy.dept_id) twhere ep.dept_id=dp.id and ep.dept_id=t.dept_id and ep.salary=max_salary and (select count(*) from empy e2 where e2.dept_id=ep.dept_id and e2.salary=ep.salary)&lt;=2order by max_salary desc ; 查询每个部门每月发放的工资总和 分析 每个部门 group by dp.dept_id 工资总和 sum(ep.salary)12select (select dp.name from dept dp where dp.id=ep.dept_id) dept, sum(ep.salary) sum_salary from empy epgroup by ep.dept_id 参考文献 SQL中GROUP BY用法示例 查询每班分数最高的学生 mysql group by 对多个字段进行分组","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/tags/mysql/"}]},{"title":"防止表单重复提交的多种策略手段","slug":"form-submit","date":"2019-01-09T16:00:00.000Z","updated":"2019-05-29T04:36:21.097Z","comments":true,"path":"posts/9fe2dfd3.html/","link":"","permalink":"https://datou-y.github.io/posts/9fe2dfd3.html/","excerpt":"在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。 问题再现 场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 场景二：表单提交后用户点击【刷新】按钮导致表单重复提交 场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交 场景四：使用浏览器历史记录重复提交表单。","text":"在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。 问题再现 场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 场景二：表单提交后用户点击【刷新】按钮导致表单重复提交 场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交 场景四：使用浏览器历史记录重复提交表单。 问题方案利用JavaScript防止表单重复提交 表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮 用JavaScript控制Form表单只能提交一次阻止submit提交事件第二次提交 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题 利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 在服务器端，生成一个唯一的标识符，将它存入session，并且返回给前端，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。 通过重定向实现当用户提交表单，服务器端处理后立即转向其他的页面 使用Cookie处理使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单， 在数据库里添加约束在数据库里添加唯一约束或创建唯一索引，防止出现重复数据 对表单提交数据进行检验检查表单的数据是否重复或者是否符合提交要求 参考文献 防止表单重复提交的八种简单有效的策略 表单重复提交的常见应用场景","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"form","slug":"form","permalink":"https://datou-y.github.io/tags/form/"}]},{"title":"jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？","slug":"jpeg-gif-png-svg-on-web","date":"2018-06-29T03:19:21.000Z","updated":"2019-05-28T23:33:21.915Z","comments":true,"path":"posts/c7fb8024.html/","link":"","permalink":"https://datou-y.github.io/posts/c7fb8024.html/","excerpt":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。","text":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。 JPEGJEPG由联合图像专家小组（Joint Photographic Experts Group）于1992年创建，并以创建者命名。JPEG是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。 因为 JPEG 压缩在亮度和色彩上面的优越性，所以 JPEG 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。 JPEG 的压缩可以用 Photoshop 里存储为 web 格式的时候可以直接选择压缩品质，一般用于 web 的 JPG 图片选择 50%-60% 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 TinyJPG。 下面这个图，我用的是 50%的品质压缩出来的 JPG，很明显质量要比 GIF 的要好很多，而且文件尺寸也小不少。 JPEG 和 JPG 的区别：JPEG 更多的指的是 .jpg 图像格式的一种压缩算法，而 JPG 就是一种图像存储的格式。 PNG可移植网络图形（Portable Network Graphics）也是一种自1995年以来就一直存在的光栅图像格式。它与 JPEG 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。 PNG格式PNG其实可以细分为好几个格式的，有PNG 8、PNG 24和PNG 32。那么怎么区分一个 PNG 图片是什么格式的呢？ 打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 PNG 24 格式的图片。同样，PNG 8 和 PNG 32 的位深度分别是8和32。 位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 PNG 8 最多只能存储256种颜色。PNG 24 和 PNG 32又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；PNG 32中剩余的8位存储的是Alpha 通道的透明色。 然后如何生成这些不同格式的图片呢？自然是用专业的图像处理软件啦，比如可以用 Photoshop 或者 Fireworks。这里以 Photoshop 为例子，文件-&gt;存储为 Web 所用格式， 可以看到下拉这里只有 PNG-8 和 PNG-24，而没有 PNG-32 呢？是因为 Photoshop不支持这个格式嘛？并不是。 在 Photoshop 里导出 PNG-32 格式的图片是通过选择 PNG-24格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 PNG-24 格式。由此看来 PNG-24 是不支持透明的，PNG-32 是支持透明的。 PNG透明度从 Fireworks 8的优化面板里可以看到 PNG 格式存在三种透明格式：不透明、索引透明和 Alpha透明。 PNG 8透明度 从上面那个图里可以看出 PNG 8 是支持这三种不透明格式的。但是 Photoshop 只支持导出不透明和索引透明格式。在Photoshop 中如果选择 PNG 8，且勾选了透明度，那么导出的图片就是 PNG 8 索引透明，否则就是 PNG 8 不透明。 用 Photoshop 和 Fireworks 8 导出 PNG 8 的各种格式如下所示： 根据以上图片我们可以得出结论： Photoshop 导出的 PNG 8 图片都带有锯齿。 PNG 8 索引透明都带有锯齿，且 Fireworks 8 导出的 PNG 8索引透明的锯齿是白色的。 再来看看这些格式在不同浏览器下的表现情况： 根据以上图片我们可以得出结论： PNG 8 索引透明和 Alpha 透明都兼容IE 6；但美中不足的是，PNG 8Alpha透明在 IE 6下会产生锯齿。 其他格式的图片在各个浏览器下的表现一致。 Fireworks 8导出的 PNG 8索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。 PNG 24 和 PNG 32 PNG 24 是不透明的；PNG 32 是支持透明的，且是 Alpha 透明。来看下它们在不同浏览器下的表现： PNG 32 图片的透明区域在 IE 6 下将不再透明，而是颜色值为 f0f0f0 的灰色填充，在更高级版本的 IE 下是正常的。PNG 32 图片不会有锯齿。 PNG压缩本文前面提到了 JPEG 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 PNG 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 TinyPNG，这个工具可以压缩 JPEG 和 PNG 格式。 从上图这个图中，我们可以从不同角度得出一些结论： PNG 8 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以PNG 8不适合用于存储颜色复杂的图像。相反，由于其相对于 PNG 24 或者 PNG 32 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。 对比100%质量的 JPG、55%质量的 JPG、PNG 24 和 PNG 32，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 JPG 占用存储最小；压缩后，PNG 24 和 PNG 32 一样，会比55%质量的 JPG 小一些，但是由于 PNG 32 支持透明，所以对于颜色丰富的图像建议用 PNG 32 格式导出，然后用压缩工具压缩一下即可。 对比压缩前后的 PNG 24 和 PNG 32 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 web 上的 PNG 24 或 PNG 32 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。 GIF图形交换格式（Graphics Interchange Format）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 IE 6 下也支持得很好，唯一美中不足的是除了 Fireworks 8 导出的 GIF 不透明格式外，所有的其他 GIF 格式的图片都存在锯齿。 但是 GIF 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画： SVG可伸缩矢量图形（Scalable Vector Graphics），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 SVG 相对于光栅格式的图像具有以下优势： 任意伸缩图像，而不会破坏图像的清晰度和细节。 完全支持 DOM，以及 JavaScript 能够很好的访问到它。 总体来讲，SVG的文件会比 GIF 或 JPG 的会小很多。 就像其它矢量格式，SVG 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 Retina 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片： SVG用途SVG 在线条艺术，LOGO，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，SVG 和 PNG 都能很好地达到同一个目的。对于线条艺术，SVG 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 SVG 真正出色的地方是数据可视化。由于可以使用JavaScript 来操纵和创建矢量动画，诸如 D3 之类的库提供了无限的可能性。LOGO, 图标和数据可视化是 SVG 使用的优秀范例。 SVG压缩比较好的 SVG 方法应该是通过清除 SVG 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 Adobe Illustrator 编辑 SVG，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。 清理不必要的节点是缩减 SVG 尺寸的一种途径。元素标签是包含在 SVG 文件内的所有内容，包括开始和结束标签。矢量编辑软件，如 Adobe Illustrator 和 Sketch 可能会到处含有非必要元素和属性的 SVG 。SVG 压缩器可用于删除这种多余的信息。Compresso 和 SVGOMG 等在线工具可以完成此工作。 参考文章 在网页上使用JPG、PNG和SVG：新手指南 PNG使用技巧 PNG vs. GIF vs. JPEG vs. SVG - When best to use? JPG vs PNG vs GIF vs SVG – What is the Difference?","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://datou-y.github.io/tags/svg/"},{"name":"图像","slug":"图像","permalink":"https://datou-y.github.io/tags/图像/"}]},{"title":"chrome开发者工具实用小技巧","slug":"chrome-devtools","date":"2018-06-15T10:20:21.000Z","updated":"2019-05-28T01:54:06.744Z","comments":true,"path":"posts/d7262aae.html/","link":"","permalink":"https://datou-y.github.io/posts/d7262aae.html/","excerpt":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下：","text":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下： Elements面板篇 在 Elements 面板中，使用 Ctrl + F 打开搜索输入框，可以输入常规字符串或选择器来选择 HTML 元素。 在元素前面的小黑三角上用 Alt + 鼠标左键即可展开收起当前元素下的所有子元素。 css数值使用快捷键调整： Up / Down：增加减少1 Ctrl + Up / Ctrl + Down：增加减少100 Shift + Up / Shift + Down：增加减少10 Alt + Up / Alt + Down： 增加减少0.1 Up / Down 等同于鼠标滚轮 查看事件监听器。选中一个元素，然后点击 Event Listeners 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 handler，右键单击选择 Show function definition 即可在 Source 面板中打开且定位到当前事件的处理函数的所在位置。 点击颜色方格会打开 chrome 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( toggle color picker )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，Color Palettes 里分3小块，分别是：Material Design，一组符合 Material Design 规范的颜色；Page Colors，一组从页面的 CSS 自动生成的颜色；Custom，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 chrome 的 DevTools 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。 可视化 Shadow DOM。在 dom 元素列表中，都是我们写的看得见的元素。其实在构建 dom 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 Settings -&gt; Preferences -&gt; Elements 下的 Show user agent shadow DOM 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。 给元素添加状态。元素有4种用户行为状态：:active、:hover、:focus、:visited。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 Styles面板中进行设置。 使用 Tab 键可以在 CSS 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 Shift + Tab。但是再使用快捷键切换选定之前需要先让光标在 Styles 面板，处于输入状态即可。 Console面板篇 使用 $0-$4 选择元素。$0 返回最后一次选择的元素，$1 返回仅在最后一次之前选择的元素，以此类推。$(selector) 返回带有指定 CSS 选择器的第一个DOM元素的引用。$$(selector) 返回 CSS 选择所有匹配的元素数组。 如果页面使用了类 Jquery 库，则 $(selector) 功能将被覆盖， $ 将与该库的实现对应。 一些实用的方法: console.log()、console.info()、console.warn()、console.error()打印不同的状态信息 使用CSS设置控制台输出样式，利用CSS格式说明符%c。 copy(object)，将指定对象的字符串表示复制到剪贴板。 getEventListeners(object)，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 Event Listeners 面板那边 show function definition 那样的功能。 inspect(elem)， 跳转到 Elements 面板的指定元素节点 console.time(str) 和 console.timeEnd(str) 返回这中间间隔的时间。下图的 4.24e+3ms 是数字的科学计数法表示，表示的实际值是：4.24*10*10*10ms，即4.24秒。 Sources面板篇 Ctrl + Shift + F，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 className 或者 id 把这个文件找出来。 Ctrl + P，根据文件名查找所有站内资源文件。 漂亮打印。对于 Sources 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。 在 Sources 面板中找到图片资源，然后在图片上右键即可获取图片的 Data URI。 使用 console.dir( ele ) 将 DOM 元素格式化为 JavaScript 对象 在 Sources 面板编辑文件小技巧 使用 Ctrl + p 打开输入框输入 :20:30 回车后，光标位置将跳转到当前文件的第20行第30列 使用使用 Alt + - 和 Alt + = 可以在上一个鼠标位置和下一个鼠标位置之间跳转 使用 Ctrl + 鼠标左键可以添加多个光标输入位置 使用 Alt + 鼠标拖动可以拉出一块矩形选区 参考文章 chrome-devtools","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://datou-y.github.io/tags/chrome/"}]},{"title":"hexo主题的安装和使用","slug":"hexo-themes","date":"2018-06-04T07:20:21.000Z","updated":"2019-05-28T11:59:26.173Z","comments":true,"path":"posts/4a1d4f4f.html/","link":"","permalink":"https://datou-y.github.io/posts/4a1d4f4f.html/","excerpt":"Hexo博客框架有很多第三方主题，我们可以到主题官网去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是bubuzou 简单使用 官网下载好主题后放在博客的themes文件夹下 然后修改根目录_config.yml文件的theme配置为当前下载的主题文件夹名称 然后根据每个主题的使用文档修改下载的对应主题文件夹下的_config.yml来配置对应主题功能 这里我以bubuzou主题为例","text":"Hexo博客框架有很多第三方主题，我们可以到主题官网去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是bubuzou 简单使用 官网下载好主题后放在博客的themes文件夹下 然后修改根目录_config.yml文件的theme配置为当前下载的主题文件夹名称 然后根据每个主题的使用文档修改下载的对应主题文件夹下的_config.yml来配置对应主题功能 这里我以bubuzou主题为例 配置这个主题需要注意的点 他的评论，文章阅读次数，功能用的LeanCloud需要自己注册，对应的LeanCloud统计次数class是Timer不是Counter否则会出现访问次数没有 LeanCloud官网 主题文档 bubuzou 参考文献 hexo的安装和主题的替换 hexo教程系列 Hexo博客使用LeanCloud统计页面访问次数 leanCloud的使用","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo Themes","slug":"Hexo-Themes","permalink":"https://datou-y.github.io/tags/Hexo-Themes/"}]},{"title":"hexo-abbrlink插件使用","slug":"hexo-abbrlink","date":"2018-06-01T06:20:21.000Z","updated":"2019-05-28T11:56:36.075Z","comments":true,"path":"posts/32d54ad4.html/","link":"","permalink":"https://datou-y.github.io/posts/32d54ad4.html/","excerpt":"这是一个Hexo plugin基于文章标题用来生成静态文章链接。查看官方文档hexo-abbrlink获得详细使用信息 Quick StartHow to installAdd plugin to Hexo:1npm install hexo-abbrlink --save Modify permalink in config.yml file:1permalink: posts/:abbrlink.html/ There are two settings:12alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)rep -- Represent (the generated link could be presented in hex or dec value)","text":"这是一个Hexo plugin基于文章标题用来生成静态文章链接。查看官方文档hexo-abbrlink获得详细使用信息 Quick StartHow to installAdd plugin to Hexo:1npm install hexo-abbrlink --save Modify permalink in config.yml file:1permalink: posts/:abbrlink.html/ There are two settings:12alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)rep -- Represent (the generated link could be presented in hex or dec value) 1234# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex SampleThe generated link will look like the following: crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.html crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html LimitationMaximum number of posts is 65535 for crc16. (For a personal blog site, this number is decent) More infosee this(Chinese) ThanksForNoahDragon","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://datou-y.github.io/tags/Hexo/"},{"name":"Hexo Plugins","slug":"Hexo-Plugins","permalink":"https://datou-y.github.io/tags/Hexo-Plugins/"}]},{"title":"快速、简洁且高效的博客框架Hexo","slug":"hexo-cli","date":"2018-05-30T10:20:21.000Z","updated":"2019-05-28T12:35:06.404Z","comments":true,"path":"posts/4a17b156.html/","link":"","permalink":"https://datou-y.github.io/posts/4a17b156.html/","excerpt":"欢迎来到 Hexo! 这是一个快速、简洁且高效的博客框架，查看官方文档 documentation 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 troubleshooting 找到答案，或者你可以询问我GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"欢迎来到 Hexo! 这是一个快速、简洁且高效的博客框架，查看官方文档 documentation 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 troubleshooting 找到答案，或者你可以询问我GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Clean cache1$ hexo clean 参考文献 Easy Hexo 👨‍💻","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://datou-y.github.io/tags/Hexo/"}]}]}