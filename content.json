{"meta":{"title":"随记","subtitle":null,"description":"良好的学习习惯，能够提高工作、生活效率。所以阶段总结反省，随记很重要。","author":"daTou","url":"https://datou-y.github.io","root":"/"},"pages":[],"posts":[{"title":"java中数组用法和实例详解","slug":"java-array","date":"2019-06-06T08:25:00.935Z","updated":"2019-06-06T09:51:01.115Z","comments":true,"path":"posts/4d11ca6.html/","link":"","permalink":"https://datou-y.github.io/posts/4d11ca6.html/","excerpt":"数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快 创建123String[] a=&#123;\"a\",\"b\",\"c\",\"d\"&#125;;String[] b=new String[5];String[] names = new String[] &#123; \"A\", \"B\", \"C\" &#125;; 数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型 创建并分配空间在 Java中可以使用new关键字来给数组分配空间","text":"数组是最常见的一种数据结构，它是相同类型的用一个标识符封装到一起的基本类型数据序列或者对象序列。数组使用一个统一的数组名和不同的下标来唯一确定数组中的元素。实质上，数组是一个简单的线性序列，因此访问速度很快 创建123String[] a=&#123;\"a\",\"b\",\"c\",\"d\"&#125;;String[] b=new String[5];String[] names = new String[] &#123; \"A\", \"B\", \"C\" &#125;; 数据类型[] 数组名; 数据类型既可以是基本数据类型，也可以是引用数据类型 创建并分配空间在 Java中可以使用new关键字来给数组分配空间 基本操作添加元素1b[0]=\"a\"; 获取12System.out.println(b[0]);System.out.println(b.length); length属性获取数组长度 b[0] 直接通过下标获取数组对应位置元素 数组遍历12345678//普通for循环for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]);&#125;//增强for循环for(String s:a)&#123; System.out.println(s);&#125; 数组排序1234567891011121314String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;Arrays.sort(b);Arrays.sort(a);for (String s : a) &#123; System.out.println(s);&#125;for (Integer s : b) &#123; System.out.println(s);&#125; Arrays.sort()方法进行数组排序，字符串就按26个字符位置排序，数组就按大小排序 数组转换集合123456789String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;List&lt;String&gt; ls = Arrays.asList(a);for (String s : ls) &#123; System.out.println(s);&#125; 数组反转123456789101112String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;//先将数组转换为集合List&lt;String&gt; ls = Arrays.asList(a); //然后调用Collections工具方法进行反转Collections.reverse(ls);for(String s:ls)&#123; System.out.println(s);&#125; 数组获取最大值和最小值12345678910String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;int[] b = new int[5];b[0] = 2;b[1] = 3;b[2] = 1;//先将数组转换为集合List&lt;String&gt; ls = Arrays.asList(a);//然后调用Collections工具方法进行比较System.out.println(Collections.max(ls));System.out.println(Collections.min(ls)); 数组合并12345678910111213String[] a = &#123;\"b\", \"c\", \"a\", \"d\"&#125;;String[] b = &#123;\"e\", \"f\", \"g\"&#125;;//先将数组转换为集合List&lt;String&gt; ls = new ArrayList&lt;String&gt;(Arrays.asList(a));//在调用集合的合并方法ls.addAll(Arrays.asList(b));Object[] o = ls.toArray();System.out.println(Arrays.toString(o));for (Object s : o) &#123; System.out.println(s);&#125; 注意这里遇到一个坑 12List&lt;String&gt; s=Arrays.asList(a);s.add(\"1\"); 这样接收的List集合和我们new创建的有区别所以add等方法是又区别的 参考ArrayList报错：UnsupportedOperationException的解决办法 数组填充12345int[] a=new int[5];Arrays.fill(a,1);for(int s:a)&#123; System.out.println(s);&#125; 参考文献 Java关于数组操作函数","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://datou-y.github.io/tags/Array/"}]},{"title":"ArrayList、LinkedList、Vector的区别和实现原理","slug":"ArryList-LinkList-Vector","date":"2019-06-06T07:37:14.550Z","updated":"2019-06-06T08:14:20.336Z","comments":true,"path":"posts/57b1f1b.html/","link":"","permalink":"https://datou-y.github.io/posts/57b1f1b.html/","excerpt":"继承关系","text":"继承关系 ArrayList 线程不安全，没有实现同步 有序的，先添加的元素放在前面，允许null值 查询，和随机访问效率快，修改比较慢 数据结构基于数组实现按照顺序将元素存储（从下表为0开始），删除元素时，删除操作完成后，需要使部分元素移位，默认的初始容量为10 LinkedList 线程不安全，没有实现同步 有序的，先添加的元素放在前面，允许null值 LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部 查询慢，修改比较慢 LinkedList是基于双向链表实现的（含有头结点） Vector Vector属于线程安全级别的大部分的方法都包含关键字synchronized Vector的效率没有ArraykList和LinkedList高 基于数组实现的 Vector提供indexOf(obj, start)接口，ArrayList没有。 线程安全实现 ArrayList不具有有线程安全性，在单线程的环境中，LinkedList也是线程不安全的，如果在并发环境下使用它们，可以用Collections类中的静态方法synchronizedList(）对ArrayList和LinkedList进行调用即可。Vector实现线程安全的，即它大部分的方法都包含关键字synchronized,但是Vector的效率没有ArraykList和LinkedList高 参考文献 ArrayList、LinkedList、Vector的区别和实现原理 源码浅析ArrayList、LinkedList和Vector的区别","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://datou-y.github.io/tags/List/"}]},{"title":"HashMap和Hashtable的区别和实现原理","slug":"hashmap-hastable","date":"2019-06-06T06:00:25.209Z","updated":"2019-06-06T08:20:55.268Z","comments":true,"path":"posts/425444d1.html/","link":"","permalink":"https://datou-y.github.io/posts/425444d1.html/","excerpt":"Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。","text":"Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap和Hashtable的区别 HashMap和Hashtable都实现了Map接口 HashMap是线程不安全的不允许键值重复,允许空键和空值;由于非线程安全,HashMap 的效率要较 HashTable 的效率高一些. HashTable 是线程安全的一个集合,不允许 null 值作为一个 key 值或者 Value 值 HashTable 是 synchronized 同步的,多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 底层数据结构基于数组+链表实现 HashMap同步1Map m=Collections.synchronizedMap(map) Collections类不是集合，这个类里面提供了synchronizedMap方法 参考文献 HashMap和Hashtable的区别 JAVA中HashMap和Hashtable区别 HashMap和Hashtable原理","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Map","slug":"Map","permalink":"https://datou-y.github.io/tags/Map/"}]},{"title":"java中map字典用法和详细实例","slug":"java-map","date":"2019-06-05T10:52:00.847Z","updated":"2019-06-06T07:42:48.288Z","comments":true,"path":"posts/f2f0bf25.html/","link":"","permalink":"https://datou-y.github.io/posts/f2f0bf25.html/","excerpt":"HashMap字典用于存放键值对，&lt;key,value&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！","text":"HashMap字典用于存放键值对，&lt;key,value&gt;，通过key来查找value,顾名思义key不能为空，唯一且不重复，不然底层怎么查呢！ 常用方法 map创建12Map&lt;String,Integer&gt; map=new HashMap&lt;String, Integer&gt;();Map&lt;String, Integer&gt; map = Hashtable&lt;String, Integer&gt;; HashMap底层是哈希表数据结构，线程是不同步的也就是线程不安全的，可以存入null键，null值。要保证键的唯一性，需要覆盖hashCode方法，和equals方法 TreeMapTreeMap可以对集合中的键进行排序 添加元素123456map.put(\"tom\",22);map.put(\"jack\",33);map.put(\"tom\",23);for (String key : map.keySet()) &#123; System.out.println(map.get(key)); &#125; put()方法在没有hashCode和equals方式 添加重复的键值（值不同）,会覆盖掉前面key值相同的值 删除元素123map.remove(\"tom\");map.clear(); map.remove(\"tom\",22); clear()方法清空集合对象 remove()方法指定key，返回删除的键值对映射的值如果key不存在删除失败，返回null如果同时指定了key，和value删除成功返回true，否则返回false 获取元素12map.size()map.get(\"toms\") size()方法获取容器大小,从1开始计算，集合索引从0开始计算 get()方法指定key，获取对应键值，如果key不存在返回null 判断123456789101112131415161718map.isEmpty()map.containsKey(\"toms\")map.containsValue(11)Set&lt;String&gt; key = map.keySet();for(String s:key)&#123; System.out.println(s);&#125;Collection&lt;Integer&gt; S=map.values();for(Integer s:S)&#123; System.out.println(s);&#125;Set&lt;Map.Entry&lt;String,Integer&gt;&gt; es=map.entrySet();for(Map.Entry e:es)&#123; System.out.println(e.getKey()); System.out.println(e.getValue());&#125; boolean isEmpty()方法判断集合是否为空 长度为0返回true否则false boolean containsKey(Object key) 判断集合中是否包含指定的key boolean containsValue(Object value)判断集合中是否包含指定的value Set keySet()方法获取所有的key返回一个Set集合 Collection values()方法获取所有的值返回一个Collection集合 entrySet() 方法获取map所有实体Set集合包含键和值 Map遍历1234Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(\"tom\", 22);map.put(\"jack\", 33);map.put(\"kom\", 23); 通过keySet() 获取key 通过key 找到value123for(String key:map.keySet())&#123; System.out.println(map.get(key));&#125; 通过Map.Entry(String,Integer) 获取，然后使用entry.getKey()获取到键，通过entry.getValue()获取到值1234for(Map.Entry e:map.entrySet())&#123; System.out.println(e.getValue()); System.out.println(e.getKey());&#125; 只遍历键或者值，通过增强for循环1234567for(String key:map.keySet())&#123; System.out.println(key);&#125;for(Integer a:map.values())&#123; System.out.println(a);&#125; 通过Iterator迭代器来遍历通过getKey获取所有键getValue获取所有值1234567Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it= map.entrySet().iterator();while (it.hasNext())&#123; Map.Entry&lt;String,Integer&gt; next=it.next(); String key=next.getKey(); Integer v=next.getValue(); System.out.println(\"key\"+key+\"value\"+v);&#125; Map合并123456789101112Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();map.put(\"tom\", 22);map.put(\"jack\", 33);map.put(\"kom\", 23);Map&lt;String, Integer&gt; map1 = new HashMap&lt;String, Integer&gt;();map1.put(\"t\", 21);map1.put(\"g\", 2);map.putAll(map1);for (String key : map.keySet()) &#123; System.out.println(map.get(key));&#125; putAll()方法可以接收另一个Map让两个集合合并为一个Set的元素不可重复，Map的键不可重复Set元素重复元素不能存入add方法返回falseMap的重复健将覆盖旧键，将旧值返回。 fail-fast (快速失败)机制 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException 增加for循环进行遍历新增,删除操作会触发fail-fast机制，修改也就是覆盖不会触发1234567for(String key:map.keySet())&#123; map.put(\"jack\",222); map.put(\"s\",2); if(key.equals(\"jack\"))&#123; map.remove(\"jack\"); &#125;&#125; 使用迭代器迭Iterator迭代时候迭代器删除不会触发fail-fast机制只有新增会触发123456789101112Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator();while (it.hasNext())&#123; Map.Entry&lt;String,Integer&gt; s=it.next(); String key=s.getKey(); Integer value=s.getValue(); map.put(\"s\",1); map.put(\"tom\",1); if(key.equals(\"jack\"))&#123; it.remove(); &#125;&#125; 参考文献 Java集合类详解 java基础集合简介Map（三）下","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"Map","slug":"Map","permalink":"https://datou-y.github.io/tags/Map/"}]},{"title":"java中List集合用法和实例详解","slug":"java-list","date":"2019-06-04T13:33:38.510Z","updated":"2019-06-06T07:42:33.669Z","comments":true,"path":"posts/50eb6371.html/","link":"","permalink":"https://datou-y.github.io/posts/50eb6371.html/","excerpt":"集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作 下面是java中集合框架主要结构图","text":"集合是存储海量数据的容器，在编程中用于对数据集中的处理，方便对数据进行增，删，改，查，等操作 下面是java中集合框架主要结构图 集合的创建123List&lt;String&gt; ls=new ArrayList&lt;String&gt;();List&lt;String&gt; ls = new LinkedList&lt;String&gt;();List&lt;String&gt; ls = new Vector&lt;String&gt;(); List继承自Collection接口，是有序集合,即先放入的元素排在前面允许相同元素和null,实现类有ArrayList,LinkedList,Vector ArrayList非同步，允许相同元素和null，实现了动态大小的数组，遍历效率高，用的多 LinkedList 非同步，允许相同元素和null，遍历效率低插入和删除效率高 Vector 同步，允许相同元素和null，效率低 集合常用方法集合的索引，也就是下标是从0开始，长度是从1开始 添加元素1234ls.add(\"a\"); ls.add(\"b\");ls.add(2,\"c\");ls.set(0,\"a\"); add()方法添加元素到集合中，也可以指定添加元素到集合指定位置，如果当前位置已经有了其他元素，后面的元素就依次往后移动，如果添加的位置索引不存在就会抛异常 set()方法替换掉原来位置的元素，如果索引不存在抛异常 删除元素12ls.remove(\"a\");ls.remove(0); remove()方法删除元素，可以根据元素删除如果当前元素不存在，或者已经删除就返回false，如果存在删除成功返回true。 也可以根据索引，也就是下标来删除，如果下标不存在就抛异常，返回删除后的元素信息 获取元素1ls.get(0) get()方法获取元素，根据下标获取元素，如果下标不存在抛异常 清空元素1ls.clear() 获取元素个数12ls.size()System.out.println(ls.size()); size() 获取元素个数，从1开始计算 集合是否为空1234boolean f = ls.isEmpty();if (f) &#123; System.out.println(\"full\");&#125; 集合包含某个元素12boolean f=ls.contains(\"g\");System.out.println(f); contains()方法，判断集合包含某个元素，如果存在返回true，否则返回false 获取元素对应的索引1234int a= ls.indexOf(\"e\");System.out.println(a);int b=ls.lastIndexOf(\"a\");System.out.println(b); indexOf()方法判断元素对应的索引位置，如果当前元素存在返回对应索引，不存在返回-1 lastIndexOf()方法和indexOf()一样，唯一不同就是当集合中有多个重复元素时候，会返回最后一个元素的下标，也就是索引。 集合转换为数组12345678910List&lt;String&gt; ls = new ArrayList&lt;String&gt;();ls.add(\"a\");ls.add(\"b\");ls.add(\"d\");ls.add(3, \"c\");Object[] a=ls.toArray();for(int i=0;i&lt;a.length;i++)&#123; System.out.println(a[i]);&#125; 集合遍历123456789101112131415161718192021List&lt;String&gt; ls = new ArrayList&lt;String&gt;();ls.add(\"a\");ls.add(\"b\");ls.add(\"c\");// 普通for 循环for(int i=0;i&lt;ls.size();i++)&#123; System.out.println(ls.get(i));&#125;//增强for循环for(String item:ls)&#123; System.out.println(item);&#125;//迭代器Iterator&lt;String&gt; iterator=personList.iterator();while (iterator.hasNext())&#123; String p=iterator.next(); System.out.println(p); &#125; fail-fast (快速失败)机制 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出ConcurrentModificationException 单线程环境 集合被创建后,在遍历它的过程中修改了结构,会抛异常 多线程环境 当一个线程在遍历这个集合,而另一个线程对这个集合的结构进行了修改会抛异常 12345678910List&lt;Person&gt; personList=new ArrayList&lt;Person&gt;();Person person=new Person();person.setAge(23);person.setName(\"Tom\");personList.add(person);Person person1=new Person();person1.setAge(22);person1.setName(\"jack\");personList.add(person1);Iterator&lt;Person&gt; iterator=personList.iterator(); 普通for循环遍历时候修改元素不会触发fail-fast安全机和制抛异常1234567for(int i=0;i&lt;personList.size();i++)&#123; Person p=personList.get(i); if(p.getAge()==22)&#123; personList.remove(i); &#125;&#125; 增加for循环遍历时候修改元素会触发fail-fast安全机和制抛异常12345for(Person p:personList)&#123; if(p.getAge()==22)&#123; personList.remove(p); &#125;&#125; 迭代器遍历，使用迭代器删除不会触发fail-fast安全机和制抛异常12345678while (iterator.hasNext())&#123; Person p=iterator.next(); if(p.getAge()==22)&#123; //这里要使用Iterator的remove方法移除当前对象， // 如果使用List的remove方法，则同样会出现ConcurrentModificationException iterator.remove(); &#125;&#125; 集合和数组区别 数组长度是固定的，集合长度是可变的 数组的存放的类型只能是一种（基本类型/引用类型）,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。 数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求 集合案例集合去重12345List&lt;String&gt; list=new ArrayList&lt;String&gt;();list.add(\"a\");list.add(1,\"b\");list.add(\"c\");list.add(\"a\"); 把list里的对象遍历一遍，用list.contain()，如果不存在就放入到另外一个list集合中1234567891011List&lt;String&gt; list1=new ArrayList&lt;String&gt;();for(int i=list.size()-1;i&gt;=0;i--)&#123; if(!list1.contains(list.get(i)))&#123; list1.add(list.get(i)); &#125;&#125;for(String s:list1)&#123; System.out.println(s);&#125; 循环list中的所有元素然后删除重复1234567891011for (int i = 0; i &lt; list.size() - 1; i++) &#123; for (int j = list.size() - 1; j &gt; i; j--) &#123; if (list.get(j).equals(list.get(i))) &#123; list.remove(j); &#125; &#125;&#125;for(String s:list)&#123; System.out.println(s);&#125; 通过HashSet踢除重复元素123456789HashSet h=new HashSet();h.addAll(list);list.clear();list.addAll(h);for(String s:list)&#123; System.out.println(s);&#125; 新版本的 JDK 可以支持 Stream 流操作，因此集合去重可以简单的使用下述语句来实现1234list = list.stream().distinct().collect(Collectors.toList());for(String s:list)&#123; System.out.println(s);&#125; 集合合并1234567891011121314List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(\"a\");list.add(\"b\");List&lt;String&gt; list1=new ArrayList&lt;String&gt;();list1.add(\"c\");list1.add(\"d\");list.addAll(list1);for(String s:list)&#123; System.out.println(s);&#125; 参考文献 Java集合（一）什么是集合 Java基础List详解 Java集合类详解 Java中List集合去除重复数据的方法 JAVA List合并集合","categories":[{"name":"java","slug":"java","permalink":"https://datou-y.github.io/categories/java/"}],"tags":[{"name":"List","slug":"List","permalink":"https://datou-y.github.io/tags/List/"}]},{"title":"mysql复杂的sql语句查询案例之GROUP BY系列","slug":"sql-complex-select","date":"2019-01-14T16:00:00.000Z","updated":"2019-05-29T03:45:03.901Z","comments":true,"path":"posts/1077e6d7.html/","link":"","permalink":"https://datou-y.github.io/posts/1077e6d7.html/","excerpt":"sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。 概述GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组， GROUP BY必须得配合聚合函数来用,聚合后的表其他列不能再select查询项中分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等。","text":"sql语句高效是决定程序运行是否流程，稳定，快速的一个重要标准。在开发项目中我们往往忽略了sql语句的重要性，作为后端人员sql语句还是非常重要的。 概述GROUP BY我们可以先从字面上来理解，GROUP表示分组，BY后面写字段名，就表示根据哪个字段进行分组， GROUP BY必须得配合聚合函数来用,聚合后的表其他列不能再select查询项中分组之后你可以计数（COUNT），求和（SUM），求平均数（AVG）等。 常用的聚合函数 count() 计数 sum() 求和 avg() 平均数 max() 最大值 min() 最小值 语法1234SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; 案例学生信息班级表学生\b表成绩表 参考文献 SQL中GROUP BY用法示例 查询每班分数最高的学生","categories":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://datou-y.github.io/tags/mysql/"}]},{"title":"防止表单重复提交的多种策略手段","slug":"form-submit","date":"2019-01-09T16:00:00.000Z","updated":"2019-05-29T04:36:21.097Z","comments":true,"path":"posts/9fe2dfd3.html/","link":"","permalink":"https://datou-y.github.io/posts/9fe2dfd3.html/","excerpt":"在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。 问题再现 场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 场景二：表单提交后用户点击【刷新】按钮导致表单重复提交 场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交 场景四：使用浏览器历史记录重复提交表单。","text":"在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应，那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，或者网页被恶意刷新，致使同一条记录重复插入到数据库中，我们在开发中必须防止表单重复提交。 问题再现 场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交 场景二：表单提交后用户点击【刷新】按钮导致表单重复提交 场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交 场景四：使用浏览器历史记录重复提交表单。 问题方案利用JavaScript防止表单重复提交 表单提交之后，将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮 用JavaScript控制Form表单只能提交一次阻止submit提交事件第二次提交 另外还有一种做法就是提交表单后，将提交按钮隐藏起来，这种做法和将提交按钮设置为不可用是差不多的，个人觉得将提交按钮隐藏影响到页面布局的美观，并且可能会让用户误以为是bug(怎么我一点击按钮，按钮就不见了呢？用户可能会有这样的疑问)，我个人在开发中用得比较多的是表单提交后，将提交按钮设置为不可用，反正使用JavaScript防止表单重复提交的做法都是差不多的，目的都是让表单只能提交一次，这样就可以做到表单不重复提交了。 使用JavaScript防止表单重复提交的做法只对上述提交到导致表单重复提交的三种场景中的【场景一】有效，而对于【场景二】和【场景三】是没有用，依然无法解决表单重复提交问题 利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 在服务器端，生成一个唯一的标识符，将它存入session，并且返回给前端，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。 通过重定向实现当用户提交表单，服务器端处理后立即转向其他的页面 使用Cookie处理使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单， 在数据库里添加约束在数据库里添加唯一约束或创建唯一索引，防止出现重复数据 对表单提交数据进行检验检查表单的数据是否重复或者是否符合提交要求 参考文献 防止表单重复提交的八种简单有效的策略 表单重复提交的常见应用场景","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"form","slug":"form","permalink":"https://datou-y.github.io/tags/form/"}]},{"title":"jpg、gif、png和svg用于web上，我们该如何选择最合适的图像格式？","slug":"jpeg-gif-png-svg-on-web","date":"2018-06-29T03:19:21.000Z","updated":"2019-05-28T23:33:21.915Z","comments":true,"path":"posts/c7fb8024.html/","link":"","permalink":"https://datou-y.github.io/posts/c7fb8024.html/","excerpt":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。","text":"要是问你，你知道当下都有哪些图像格式嘛？我猜你肯定说不全，因为现在图像格式真的太多了，但是应该能说出这几个常用的格式：jpg、gif、png和svg。然后我再问你，知不知道这几个格式有什么区别？各自的适用场景又是什么呢？logo应该是选择 svg 还是 png ？而截图是选 jpg 还是 png 好？在不生成过大文件的前提下，文件的最优质量是多少？了解每个图像格式的工作原理以及它们各自的利弊可以帮助回答这些问题。 在过去几年中，数字化设计和前端开发里大量的研究和测试工具已经帮助我们搞清楚了这些问题。在本文中，我将展示一下每种格式的工作原理，它们各自的优点以及在网页使用时的压缩与保存方法。 先来看几个概念 有损(Lossless)和无损(Lossy)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。 索引色(Indexed color)和直接色(Direct color)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。 光栅格式(raster)和矢量格式(vector)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 Photoshop 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。 JPEGJEPG由联合图像专家小组（Joint Photographic Experts Group）于1992年创建，并以创建者命名。JPEG是一种有损光栅图像格式，这意味着每次压缩保存JPEG时，一些信息将发生不可逆转地丢失；且存储的颜色无限制，这就对存储照片这种颜色非常丰富复杂的图像就很友好了。 因为 JPEG 压缩在亮度和色彩上面的优越性，所以 JPEG 非常适合用于照片、色彩梯度明显的图像比如渐变和阴影这些地方。 JPEG 的压缩可以用 Photoshop 里存储为 web 格式的时候可以直接选择压缩品质，一般用于 web 的 JPG 图片选择 50%-60% 质量的即可，因为它兼顾不错的图像质量和较小的文件尺寸。另外也可以用在线压缩工具 TinyJPG。 下面这个图，我用的是 50%的品质压缩出来的 JPG，很明显质量要比 GIF 的要好很多，而且文件尺寸也小不少。 JPEG 和 JPG 的区别：JPEG 更多的指的是 .jpg 图像格式的一种压缩算法，而 JPG 就是一种图像存储的格式。 PNG可移植网络图形（Portable Network Graphics）也是一种自1995年以来就一直存在的光栅图像格式。它与 JPEG 不同，因为它是一种无损格式，并且是目前网络上最常见的无损格式。这意味着由于它的压缩算法，当文件被保存和压缩时，不会丢失任何信息。 PNG格式PNG其实可以细分为好几个格式的，有PNG 8、PNG 24和PNG 32。那么怎么区分一个 PNG 图片是什么格式的呢？ 打开上面这张图片的属性面板，从详细信息里看到有一个属性叫做位深度，它的值是24，那么就表示他是 PNG 24 格式的图片。同样，PNG 8 和 PNG 32 的位深度分别是8和32。 位深度表示图像能够存储颜色的最大数值。8位就是2的8次方（2^8=256）种颜色，所以 PNG 8 最多只能存储256种颜色。PNG 24 和 PNG 32又叫真彩色，最多存储2的24次方种颜色，可以达到人眼分辨的极限了；PNG 32中剩余的8位存储的是Alpha 通道的透明色。 然后如何生成这些不同格式的图片呢？自然是用专业的图像处理软件啦，比如可以用 Photoshop 或者 Fireworks。这里以 Photoshop 为例子，文件-&gt;存储为 Web 所用格式， 可以看到下拉这里只有 PNG-8 和 PNG-24，而没有 PNG-32 呢？是因为 Photoshop不支持这个格式嘛？并不是。 在 Photoshop 里导出 PNG-32 格式的图片是通过选择 PNG-24格式，并且勾选下面的透明度，这样生成的图片位数才是32位的，如果不勾选透明度的话就是 PNG-24 格式。由此看来 PNG-24 是不支持透明的，PNG-32 是支持透明的。 PNG透明度从 Fireworks 8的优化面板里可以看到 PNG 格式存在三种透明格式：不透明、索引透明和 Alpha透明。 PNG 8透明度 从上面那个图里可以看出 PNG 8 是支持这三种不透明格式的。但是 Photoshop 只支持导出不透明和索引透明格式。在Photoshop 中如果选择 PNG 8，且勾选了透明度，那么导出的图片就是 PNG 8 索引透明，否则就是 PNG 8 不透明。 用 Photoshop 和 Fireworks 8 导出 PNG 8 的各种格式如下所示： 根据以上图片我们可以得出结论： Photoshop 导出的 PNG 8 图片都带有锯齿。 PNG 8 索引透明都带有锯齿，且 Fireworks 8 导出的 PNG 8索引透明的锯齿是白色的。 再来看看这些格式在不同浏览器下的表现情况： 根据以上图片我们可以得出结论： PNG 8 索引透明和 Alpha 透明都兼容IE 6；但美中不足的是，PNG 8Alpha透明在 IE 6下会产生锯齿。 其他格式的图片在各个浏览器下的表现一致。 Fireworks 8导出的 PNG 8索引透明带有白色锯齿，但是如果图片是放到白色的背景的容器下，那么这个白色锯齿就完全看不出来了，表现得和正常效果一样。 PNG 24 和 PNG 32 PNG 24 是不透明的；PNG 32 是支持透明的，且是 Alpha 透明。来看下它们在不同浏览器下的表现： PNG 32 图片的透明区域在 IE 6 下将不再透明，而是颜色值为 f0f0f0 的灰色填充，在更高级版本的 IE 下是正常的。PNG 32 图片不会有锯齿。 PNG压缩本文前面提到了 JPEG 在照片片这类颜色丰富的图像上的优秀表现，所以现在将它和 PNG 的3种格式进行对比。主要是对比压缩前后的存储体积以及表现效果等方面。用的是免费的在线压缩工具 TinyPNG，这个工具可以压缩 JPEG 和 PNG 格式。 从上图这个图中，我们可以从不同角度得出一些结论： PNG 8 格式的图片颜色过度处理得很突兀，能看到很明显的波浪褶皱，这就是因为它最多只能存储256种颜色导致的，所以PNG 8不适合用于存储颜色复杂的图像。相反，由于其相对于 PNG 24 或者 PNG 32 有先天的存储体积小优势，所以它非常适合应用于图标、颜色简单的或透明的图像上。 对比100%质量的 JPG、55%质量的 JPG、PNG 24 和 PNG 32，肉眼上看他们的图像表现效果都差不多，但是各自所占用的存储空间却是差得有些离谱。压缩前，当属55%质量的 JPG 占用存储最小；压缩后，PNG 24 和 PNG 32 一样，会比55%质量的 JPG 小一些，但是由于 PNG 32 支持透明，所以对于颜色丰富的图像建议用 PNG 32 格式导出，然后用压缩工具压缩一下即可。 对比压缩前后的 PNG 24 和 PNG 32 两者的存储体积相差巨大，但是表现效果却相差无几，所以用于 web 上的 PNG 24 或 PNG 32 图像一定要记得压缩，这对于客户端的性能优化将提供非常大的帮助。 GIF图形交换格式（Graphics Interchange Format）也是一种光栅格式，最多只能存储256种颜色，支持透明度，而且在 IE 6 下也支持得很好，唯一美中不足的是除了 Fireworks 8 导出的 GIF 不透明格式外，所有的其他 GIF 格式的图片都存在锯齿。 但是 GIF 也不是一无是处，最大的优点就是支持简单的动画。如下面简单的交通灯动画： SVG可伸缩矢量图形（Scalable Vector Graphics），顾名思义它是矢量的，而非光栅格式。区别于光栅格式的依靠像素点来存储图像，矢量图是通过XML格式来数据化的记录图像的信息。所以 SVG 相对于光栅格式的图像具有以下优势： 任意伸缩图像，而不会破坏图像的清晰度和细节。 完全支持 DOM，以及 JavaScript 能够很好的访问到它。 总体来讲，SVG的文件会比 GIF 或 JPG 的会小很多。 就像其它矢量格式，SVG 图片能不丢失任何细节地放大到任何大小。打个比方，同一个图标，可以以多种尺寸使用，并且在任何屏幕分辨率（比如 Retina 显示器）中都将看起来很清晰，而不需要存成多个文件。比如下面这个这个图对比，右边的是矢量图，左边的是其他格式图片： SVG用途SVG 在线条艺术，LOGO，图标，插画和数据可视化方面用途广泛。但它不适用于写实图像和有许多细节的复杂图片。在一些情况下，SVG 和 PNG 都能很好地达到同一个目的。对于线条艺术，SVG 通常能生成较小的文件。但是这不是必然的，实际情况会根据矢量图像究竟有多少个锚点，它甚至可能会生成比PNG更大的文件。 SVG 真正出色的地方是数据可视化。由于可以使用JavaScript 来操纵和创建矢量动画，诸如 D3 之类的库提供了无限的可能性。LOGO, 图标和数据可视化是 SVG 使用的优秀范例。 SVG压缩比较好的 SVG 方法应该是通过清除 SVG 矢量图形中不必要的锚点、元素和属性来减少文件大小。锚点绘制了矢量图像，因此，你需要确保已移除的锚点不会影响矢量图形的最终形状。如果您使用 Adobe Illustrator 编辑 SVG，请确保使用导 -&gt; 导出为，而不是文件 -&gt; 另存为进行保存，因为这样才能生成一个最小化的文件。 清理不必要的节点是缩减 SVG 尺寸的一种途径。元素标签是包含在 SVG 文件内的所有内容，包括开始和结束标签。矢量编辑软件，如 Adobe Illustrator 和 Sketch 可能会到处含有非必要元素和属性的 SVG 。SVG 压缩器可用于删除这种多余的信息。Compresso 和 SVGOMG 等在线工具可以完成此工作。 参考文章 在网页上使用JPG、PNG和SVG：新手指南 PNG使用技巧 PNG vs. GIF vs. JPEG vs. SVG - When best to use? JPG vs PNG vs GIF vs SVG – What is the Difference?","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://datou-y.github.io/tags/svg/"},{"name":"图像","slug":"图像","permalink":"https://datou-y.github.io/tags/图像/"}]},{"title":"chrome开发者工具实用小技巧","slug":"chrome-devtools","date":"2018-06-15T10:20:21.000Z","updated":"2019-05-28T01:54:06.744Z","comments":true,"path":"posts/d7262aae.html/","link":"","permalink":"https://datou-y.github.io/posts/d7262aae.html/","excerpt":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下：","text":"chrome 浏览器是每个前端开发者最常用的浏览器，因为界面简洁友好，开发者工具功能强大且简单易用，大大提升了开发效率。所以很有必要了解 chrome 开发者工具都有哪些很常用或实用的功能。写这篇文章的时候，chrome的版本如下： Elements面板篇 在 Elements 面板中，使用 Ctrl + F 打开搜索输入框，可以输入常规字符串或选择器来选择 HTML 元素。 在元素前面的小黑三角上用 Alt + 鼠标左键即可展开收起当前元素下的所有子元素。 css数值使用快捷键调整： Up / Down：增加减少1 Ctrl + Up / Ctrl + Down：增加减少100 Shift + Up / Shift + Down：增加减少10 Alt + Up / Alt + Down： 增加减少0.1 Up / Down 等同于鼠标滚轮 查看事件监听器。选中一个元素，然后点击 Event Listeners 面板，可以看到当前元素绑定的所有事件。然后找到任一事件类型下的 handler，右键单击选择 Show function definition 即可在 Source 面板中打开且定位到当前事件的处理函数的所在位置。 点击颜色方格会打开 chrome 的调色板。如下图第1块是着色和阴影选择器。第2块像笔那个按钮( toggle color picker )是取色器，蓝色的时候表示激活状态，就可以在页面任何一处进行取色；右边绿色圆形的是当前的颜色值，点击会将当前颜色值的代码复制到剪贴板；再右边的两块条分别表示色调选择器和不透明度选择器。第3块是表示当前颜色的显示模式，后边的按钮可以切换显示模式。第4块，Color Palettes 里分3小块，分别是：Material Design，一组符合 Material Design 规范的颜色；Page Colors，一组从页面的 CSS 自动生成的颜色；Custom，自定义颜色。第5块颜色面板，长按颜色块可以弹出10个当前颜色由浅至深的小色块，这个功能对于精确定制网页主题颜色非常有帮助。第6块是自定义颜色，这里可以添加删除自定义颜色，并且会永久保存在 chrome 的 DevTools 里，不会因为刷新或关闭浏览器而消失。第7块是生成了一些和页面相关的颜色值。 可视化 Shadow DOM。在 dom 元素列表中，都是我们写的看得见的元素。其实在构建 dom 的时候，也存在一部分东西是我们没写的，但是实际存在而被浏览器隐藏起来的元素。如果想看到这些元素就可以通过勾选 Settings -&gt; Preferences -&gt; Elements 下的 Show user agent shadow DOM 来显示这样构建的元素。这样一来就可以很好的这些元素的样式了。 给元素添加状态。元素有4种用户行为状态：:active、:hover、:focus、:visited。可以通过2中方式主动触发用户行为。选中一个元素，然后右键点击选中一个状态即可，如果有设置对于的样式，就可以看到区别。另外一种方式是在 Styles面板中进行设置。 使用 Tab 键可以在 CSS 样式规则中进行遍历选定，选定的目标包括：选择器、属性和属性值。如果想跳回上一个目标，使用 Shift + Tab。但是再使用快捷键切换选定之前需要先让光标在 Styles 面板，处于输入状态即可。 Console面板篇 使用 $0-$4 选择元素。$0 返回最后一次选择的元素，$1 返回仅在最后一次之前选择的元素，以此类推。$(selector) 返回带有指定 CSS 选择器的第一个DOM元素的引用。$$(selector) 返回 CSS 选择所有匹配的元素数组。 如果页面使用了类 Jquery 库，则 $(selector) 功能将被覆盖， $ 将与该库的实现对应。 一些实用的方法: console.log()、console.info()、console.warn()、console.error()打印不同的状态信息 使用CSS设置控制台输出样式，利用CSS格式说明符%c。 copy(object)，将指定对象的字符串表示复制到剪贴板。 getEventListeners(object)，返回一个在指定元素上绑定的所有事件监听器的数组。但是这里看不了事件的处理函数，也没有像 Event Listeners 面板那边 show function definition 那样的功能。 inspect(elem)， 跳转到 Elements 面板的指定元素节点 console.time(str) 和 console.timeEnd(str) 返回这中间间隔的时间。下图的 4.24e+3ms 是数字的科学计数法表示，表示的实际值是：4.24*10*10*10ms，即4.24秒。 Sources面板篇 Ctrl + Shift + F，根据文件内容查找所有站内资源文件，返回找出匹配的文件内容。这个功能很好用。比如我在别人的站点看到一个效果，但是不知道写到哪个文件里了，这个时候我就可以根据关键的 className 或者 id 把这个文件找出来。 Ctrl + P，根据文件名查找所有站内资源文件。 漂亮打印。对于 Sources 里的资源文件，可以将杂乱的或是压缩过的内容按照一定的缩进和换行规则进行打印输出。 在 Sources 面板中找到图片资源，然后在图片上右键即可获取图片的 Data URI。 使用 console.dir( ele ) 将 DOM 元素格式化为 JavaScript 对象 在 Sources 面板编辑文件小技巧 使用 Ctrl + p 打开输入框输入 :20:30 回车后，光标位置将跳转到当前文件的第20行第30列 使用使用 Alt + - 和 Alt + = 可以在上一个鼠标位置和下一个鼠标位置之间跳转 使用 Ctrl + 鼠标左键可以添加多个光标输入位置 使用 Alt + 鼠标拖动可以拉出一块矩形选区 参考文章 chrome-devtools","categories":[{"name":"web综合","slug":"web综合","permalink":"https://datou-y.github.io/categories/web综合/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"https://datou-y.github.io/tags/chrome/"}]},{"title":"hexo主题的安装和使用","slug":"hexo-themes","date":"2018-06-04T07:20:21.000Z","updated":"2019-05-28T11:59:26.173Z","comments":true,"path":"posts/4a1d4f4f.html/","link":"","permalink":"https://datou-y.github.io/posts/4a1d4f4f.html/","excerpt":"Hexo博客框架有很多第三方主题，我们可以到主题官网去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是bubuzou 简单使用 官网下载好主题后放在博客的themes文件夹下 然后修改根目录_config.yml文件的theme配置为当前下载的主题文件夹名称 然后根据每个主题的使用文档修改下载的对应主题文件夹下的_config.yml来配置对应主题功能 这里我以bubuzou主题为例","text":"Hexo博客框架有很多第三方主题，我们可以到主题官网去选取自己喜欢的主题,然后根据自己的喜好进行安装配置修改。我的博客用的主题是bubuzou 简单使用 官网下载好主题后放在博客的themes文件夹下 然后修改根目录_config.yml文件的theme配置为当前下载的主题文件夹名称 然后根据每个主题的使用文档修改下载的对应主题文件夹下的_config.yml来配置对应主题功能 这里我以bubuzou主题为例 配置这个主题需要注意的点 他的评论，文章阅读次数，功能用的LeanCloud需要自己注册，对应的LeanCloud统计次数class是Timer不是Counter否则会出现访问次数没有 LeanCloud官网 主题文档 bubuzou 参考文献 hexo的安装和主题的替换 hexo教程系列 Hexo博客使用LeanCloud统计页面访问次数 leanCloud的使用","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo Themes","slug":"Hexo-Themes","permalink":"https://datou-y.github.io/tags/Hexo-Themes/"}]},{"title":"hexo-abbrlink插件使用","slug":"hexo-abbrlink","date":"2018-06-01T06:20:21.000Z","updated":"2019-05-28T11:56:36.075Z","comments":true,"path":"posts/32d54ad4.html/","link":"","permalink":"https://datou-y.github.io/posts/32d54ad4.html/","excerpt":"这是一个Hexo plugin基于文章标题用来生成静态文章链接。查看官方文档hexo-abbrlink获得详细使用信息 Quick StartHow to installAdd plugin to Hexo:1npm install hexo-abbrlink --save Modify permalink in config.yml file:1permalink: posts/:abbrlink.html/ There are two settings:12alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)rep -- Represent (the generated link could be presented in hex or dec value)","text":"这是一个Hexo plugin基于文章标题用来生成静态文章链接。查看官方文档hexo-abbrlink获得详细使用信息 Quick StartHow to installAdd plugin to Hexo:1npm install hexo-abbrlink --save Modify permalink in config.yml file:1permalink: posts/:abbrlink.html/ There are two settings:12alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)rep -- Represent (the generated link could be presented in hex or dec value) 1234# abbrlink configabbrlink: alg: crc32 #support crc16(default) and crc32 rep: hex #support dec(default) and hex SampleThe generated link will look like the following: crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.html crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html LimitationMaximum number of posts is 65535 for crc16. (For a personal blog site, this number is decent) More infosee this(Chinese) ThanksForNoahDragon","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://datou-y.github.io/tags/Hexo/"},{"name":"Hexo Plugins","slug":"Hexo-Plugins","permalink":"https://datou-y.github.io/tags/Hexo-Plugins/"}]},{"title":"快速、简洁且高效的博客框架Hexo","slug":"hexo-cli","date":"2018-05-30T10:20:21.000Z","updated":"2019-05-28T12:35:06.404Z","comments":true,"path":"posts/4a17b156.html/","link":"","permalink":"https://datou-y.github.io/posts/4a17b156.html/","excerpt":"欢迎来到 Hexo! 这是一个快速、简洁且高效的博客框架，查看官方文档 documentation 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 troubleshooting 找到答案，或者你可以询问我GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"欢迎来到 Hexo! 这是一个快速、简洁且高效的博客框架，查看官方文档 documentation 获取更多信息 如果你使用 Hexo遇到一些问题，可以在 troubleshooting 找到答案，或者你可以询问我GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Clean cache1$ hexo clean 参考文献 Easy Hexo 👨‍💻","categories":[{"name":"博客","slug":"博客","permalink":"https://datou-y.github.io/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://datou-y.github.io/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://datou-y.github.io/tags/Hexo/"}]}]}